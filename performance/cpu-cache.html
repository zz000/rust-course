<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CPU缓存性能优化 todo - Rust语言圣经(Rust教程 Rust Course)</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../assets/ferris.css">
        <link rel="stylesheet" href="../assets/theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../into-rust.html">进入Rust编程世界</a></li><li class="chapter-item expanded affix "><a href="../about-book.html">关于本书</a></li><li class="chapter-item expanded affix "><a href="../sth-you-should-not-do.html">避免从入门到放弃</a></li><li class="chapter-item expanded "><a href="../first-try/intro.html"><strong aria-hidden="true">1.</strong> 寻找牛刀，以便小试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../first-try/installation.html"><strong aria-hidden="true">1.1.</strong> 安装Rust环境</a></li><li class="chapter-item "><a href="../first-try/editor.html"><strong aria-hidden="true">1.2.</strong> 墙推VSCode!</a></li><li class="chapter-item "><a href="../first-try/cargo.html"><strong aria-hidden="true">1.3.</strong> 认识Cargo</a></li><li class="chapter-item "><a href="../first-try/hello-world.html"><strong aria-hidden="true">1.4.</strong> 不仅仅是Hello world</a></li></ol></li><li class="chapter-item expanded "><a href="../basic/intro.html"><strong aria-hidden="true">2.</strong> Rust基础入门</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/variable.html"><strong aria-hidden="true">2.1.</strong> 变量绑定与解构</a></li><li class="chapter-item "><a href="../basic/base-type/index.html"><strong aria-hidden="true">2.2.</strong> 基本类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/base-type/numbers.html"><strong aria-hidden="true">2.2.1.</strong> 数值类型</a></li><li class="chapter-item "><a href="../basic/base-type/char-bool.html"><strong aria-hidden="true">2.2.2.</strong> 字符、布尔、元类型</a></li><li class="chapter-item "><a href="../basic/base-type/statement-expression.html"><strong aria-hidden="true">2.2.3.</strong> 语句与表达式</a></li><li class="chapter-item "><a href="../basic/base-type/function.html"><strong aria-hidden="true">2.2.4.</strong> 函数</a></li></ol></li><li class="chapter-item "><a href="../basic/ownership/index.html"><strong aria-hidden="true">2.3.</strong> 所有权和借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/ownership/ownership.html"><strong aria-hidden="true">2.3.1.</strong> 所有权</a></li><li class="chapter-item "><a href="../basic/ownership/borrowing.html"><strong aria-hidden="true">2.3.2.</strong> 引用与借用</a></li></ol></li><li class="chapter-item "><a href="../basic/compound-type/intro.html"><strong aria-hidden="true">2.4.</strong> 复合类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/compound-type/string-slice.html"><strong aria-hidden="true">2.4.1.</strong> 字符串与切片</a></li><li class="chapter-item "><a href="../basic/compound-type/tuple.html"><strong aria-hidden="true">2.4.2.</strong> 元组</a></li><li class="chapter-item "><a href="../basic/compound-type/struct.html"><strong aria-hidden="true">2.4.3.</strong> 结构体</a></li><li class="chapter-item "><a href="../basic/compound-type/enum.html"><strong aria-hidden="true">2.4.4.</strong> 枚举</a></li><li class="chapter-item "><a href="../basic/compound-type/array.html"><strong aria-hidden="true">2.4.5.</strong> 数组</a></li></ol></li><li class="chapter-item "><a href="../basic/flow-control.html"><strong aria-hidden="true">2.5.</strong> 流程控制</a></li><li class="chapter-item "><a href="../basic/match-pattern/intro.html"><strong aria-hidden="true">2.6.</strong> 模式匹配</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/match-pattern/match-if-let.html"><strong aria-hidden="true">2.6.1.</strong> match和if let</a></li><li class="chapter-item "><a href="../basic/match-pattern/option.html"><strong aria-hidden="true">2.6.2.</strong> 解构Option</a></li><li class="chapter-item "><a href="../basic/match-pattern/pattern-match.html"><strong aria-hidden="true">2.6.3.</strong> 模式适用场景</a></li><li class="chapter-item "><a href="../basic/match-pattern/all-patterns.html"><strong aria-hidden="true">2.6.4.</strong> 全模式列表</a></li></ol></li><li class="chapter-item "><a href="../basic/method.html"><strong aria-hidden="true">2.7.</strong> 方法Method</a></li><li class="chapter-item "><a href="../basic/trait/intro.html"><strong aria-hidden="true">2.8.</strong> 泛型和特征</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/trait/generic.html"><strong aria-hidden="true">2.8.1.</strong> 泛型Generics</a></li><li class="chapter-item "><a href="../basic/trait/trait.html"><strong aria-hidden="true">2.8.2.</strong> 特征Trait</a></li><li class="chapter-item "><a href="../basic/trait/trait-object.html"><strong aria-hidden="true">2.8.3.</strong> 特征对象</a></li><li class="chapter-item "><a href="../basic/trait/advance-trait.html"><strong aria-hidden="true">2.8.4.</strong> 进一步深入特征</a></li></ol></li><li class="chapter-item "><a href="../basic/collections/intro.html"><strong aria-hidden="true">2.9.</strong> 集合类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/collections/vector.html"><strong aria-hidden="true">2.9.1.</strong> 动态数组Vector</a></li><li class="chapter-item "><a href="../basic/collections/hashmap.html"><strong aria-hidden="true">2.9.2.</strong> KV存储HashMap</a></li></ol></li><li class="chapter-item "><a href="../basic/converse.html"><strong aria-hidden="true">2.10.</strong> 类型转换</a></li><li class="chapter-item "><a href="../basic/result-error/intro.html"><strong aria-hidden="true">2.11.</strong> 返回值和错误</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/result-error/panic.html"><strong aria-hidden="true">2.11.1.</strong> panic深入剖析!</a></li><li class="chapter-item "><a href="../basic/result-error/result.html"><strong aria-hidden="true">2.11.2.</strong> 返回值Result和?</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../advance/intro.html"><strong aria-hidden="true">3.</strong> Rust高级进阶</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/lifetime/intro.html"><strong aria-hidden="true">3.1.</strong> 生命周期</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/lifetime/basic.html"><strong aria-hidden="true">3.1.1.</strong> 认识生命周期</a></li><li class="chapter-item "><a href="../advance/lifetime/advance.html"><strong aria-hidden="true">3.1.2.</strong> 深入生命周期</a></li></ol></li><li class="chapter-item "><a href="../advance/functional-programing/intro.html"><strong aria-hidden="true">3.2.</strong> 函数式编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/functional-programing/closure.html"><strong aria-hidden="true">3.2.1.</strong> 闭包closure</a></li><li class="chapter-item "><a href="../advance/functional-programing/iterator.html"><strong aria-hidden="true">3.2.2.</strong> 迭代器iterator</a></li></ol></li><li class="chapter-item "><a href="../advance/crate-module/intro.html"><strong aria-hidden="true">3.3.</strong> 包和模块</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/crate-module/crate.html"><strong aria-hidden="true">3.3.1.</strong> 包crate</a></li><li class="chapter-item "><a href="../advance/crate-module/module.html"><strong aria-hidden="true">3.3.2.</strong> 模块Module</a></li><li class="chapter-item "><a href="../advance/crate-module/use.html"><strong aria-hidden="true">3.3.3.</strong> 使用use引入模块及受限可见性</a></li></ol></li><li class="chapter-item "><a href="../advance/comment.html"><strong aria-hidden="true">3.4.</strong> 注释和文档</a></li><li class="chapter-item "><a href="../advance/custom-type.html"><strong aria-hidden="true">3.5.</strong> 深入类型之newtype和Sized</a></li><li class="chapter-item "><a href="../advance/formatted-output.html"><strong aria-hidden="true">3.6.</strong> 格式化输出</a></li><li class="chapter-item "><a href="../advance/smart-pointer/intro.html"><strong aria-hidden="true">3.7.</strong> 智能指针</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/smart-pointer/box.html"><strong aria-hidden="true">3.7.1.</strong> Box堆对象分配</a></li><li class="chapter-item "><a href="../advance/smart-pointer/deref.html"><strong aria-hidden="true">3.7.2.</strong> Deref解引用</a></li><li class="chapter-item "><a href="../advance/smart-pointer/drop.html"><strong aria-hidden="true">3.7.3.</strong> Drop释放资源</a></li><li class="chapter-item "><a href="../advance/smart-pointer/rc-arc.html"><strong aria-hidden="true">3.7.4.</strong> Rc与Arc实现1vN所有权机制</a></li><li class="chapter-item "><a href="../advance/smart-pointer/cell-refcell.html"><strong aria-hidden="true">3.7.5.</strong> Cell与RefCell内部可变性</a></li></ol></li><li class="chapter-item "><a href="../advance/circle-self-ref/intro.html"><strong aria-hidden="true">3.8.</strong> 循环引用与自引用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/circle-self-ref/circle-reference.html"><strong aria-hidden="true">3.8.1.</strong> Weak与循环引用</a></li><li class="chapter-item "><a href="../advance/circle-self-ref/self-referential.html"><strong aria-hidden="true">3.8.2.</strong> 结构体中的自引用</a></li></ol></li><li class="chapter-item "><a href="../advance/concurrency-with-threads/intro.html"><strong aria-hidden="true">3.9.</strong> 多线程并发编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/concurrency-with-threads/concurrency-parallelism.html"><strong aria-hidden="true">3.9.1.</strong> 并发和并行</a></li><li class="chapter-item "><a href="../advance/concurrency-with-threads/thread.html"><strong aria-hidden="true">3.9.2.</strong> 使用多线程</a></li><li class="chapter-item "><a href="../advance/concurrency-with-threads/message-passing.html"><strong aria-hidden="true">3.9.3.</strong> 线程同步：消息传递</a></li><li class="chapter-item "><a href="../advance/concurrency-with-threads/sync1.html"><strong aria-hidden="true">3.9.4.</strong> 线程同步：锁、Condvar和信号量</a></li><li class="chapter-item "><a href="../advance/concurrency-with-threads/sync2.html"><strong aria-hidden="true">3.9.5.</strong> 线程同步：Atomic原子操作与内存顺序</a></li><li class="chapter-item "><a href="../advance/concurrency-with-threads/send-sync.html"><strong aria-hidden="true">3.9.6.</strong> 基于Send和Sync的线程安全</a></li><li class="chapter-item "><a href="../advance/concurrency-with-threads/web-server.html"><strong aria-hidden="true">3.9.7.</strong> 实践应用：多线程Web服务器 todo</a></li></ol></li><li class="chapter-item "><a href="../advance/unsafe/intro.html"><strong aria-hidden="true">3.10.</strong> Unsafe Rust todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/unsafe/raw-pointer.html"><strong aria-hidden="true">3.10.1.</strong> 原生指针 todo</a></li><li class="chapter-item "><a href="../advance/unsafe/ffi.html"><strong aria-hidden="true">3.10.2.</strong> FFI外部语言用 todo</a></li></ol></li><li class="chapter-item "><a href="../advance/global-variable.html"><strong aria-hidden="true">3.11.</strong> 全局变量</a></li><li class="chapter-item "><a href="../advance/errors/intro.html"><strong aria-hidden="true">3.12.</strong> 错误处理 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/errors/simplify.html"><strong aria-hidden="true">3.12.1.</strong> 简化错误处理 todo</a></li><li class="chapter-item "><a href="../advance/errors/user-define.html"><strong aria-hidden="true">3.12.2.</strong> 自定义错误 todo</a></li><li class="chapter-item "><a href="../advance/errors/pretty-format.html"><strong aria-hidden="true">3.12.3.</strong> 让错误输出更优雅 todo</a></li><li class="chapter-item "><a href="../advance/errors/panic-codes.html"><strong aria-hidden="true">3.12.4.</strong> 会导致panic的代码 todo</a></li></ol></li><li class="chapter-item "><a href="../advance/hrtb.html"><strong aria-hidden="true">3.13.</strong> 高阶特征约束(HRTB) todo</a></li></ol></li><li class="chapter-item expanded "><a href="../async/intro.html"><strong aria-hidden="true">4.</strong> async/await异步编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../async/getting-started.html"><strong aria-hidden="true">4.1.</strong> async编程入门</a></li><li class="chapter-item "><a href="../async/future-excuting.html"><strong aria-hidden="true">4.2.</strong> 底层探秘: Future执行与任务调度</a></li><li class="chapter-item "><a href="../async/pin-unpin.html"><strong aria-hidden="true">4.3.</strong> 定海神针Pin和Unpin</a></li><li class="chapter-item "><a href="../async/async-await.html"><strong aria-hidden="true">4.4.</strong> async/await和Stream流处理</a></li><li class="chapter-item "><a href="../async/multi-futures-simultaneous.html"><strong aria-hidden="true">4.5.</strong> 同时运行多个Future</a></li><li class="chapter-item "><a href="../async/pain-points-and-workarounds.html"><strong aria-hidden="true">4.6.</strong> 一些疑难问题的解决办法</a></li><li class="chapter-item "><a href="../async/web-server.html"><strong aria-hidden="true">4.7.</strong> 实践应用：Async Web服务器</a></li></ol></li><li class="chapter-item expanded "><a href="../tokio/intro.html"><strong aria-hidden="true">5.</strong> tokio使用指南 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tokio/overview.html"><strong aria-hidden="true">5.1.</strong> tokio概览</a></li><li class="chapter-item "><a href="../tokio/getting-startted.html"><strong aria-hidden="true">5.2.</strong> 使用初印象</a></li><li class="chapter-item "><a href="../tokio/spawning.html"><strong aria-hidden="true">5.3.</strong> 创建异步任务</a></li></ol></li><li class="chapter-item expanded "><a href="../fight-with-compiler/intro.html"><strong aria-hidden="true">6.</strong> 对抗编译检查 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../fight-with-compiler/phantom-data.html"><strong aria-hidden="true">6.1.</strong> 幽灵数据(todo)</a></li><li class="chapter-item "><a href="../fight-with-compiler/lifetime/intro.html"><strong aria-hidden="true">6.2.</strong> 生命周期</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../fight-with-compiler/lifetime/too-long1.html"><strong aria-hidden="true">6.2.1.</strong> 生命周期过大-01</a></li><li class="chapter-item "><a href="../fight-with-compiler/lifetime/too-long2.html"><strong aria-hidden="true">6.2.2.</strong> 生命周期过大-02</a></li><li class="chapter-item "><a href="../fight-with-compiler/lifetime/loop.html"><strong aria-hidden="true">6.2.3.</strong> 循环中的生命周期</a></li><li class="chapter-item "><a href="../fight-with-compiler/lifetime/closure-with-static.html"><strong aria-hidden="true">6.2.4.</strong> 闭包碰到特征对象-01</a></li></ol></li><li class="chapter-item "><a href="../fight-with-compiler/borrowing/intro.html"><strong aria-hidden="true">6.3.</strong> 重复借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../fight-with-compiler/borrowing/ref-exist-in-out-fn.html"><strong aria-hidden="true">6.3.1.</strong> 同时在函数内外使用引用</a></li><li class="chapter-item "><a href="../fight-with-compiler/borrowing/borrow-distinct-fields-of-struct.html"><strong aria-hidden="true">6.3.2.</strong> 智能指针引起的重复借用错误</a></li></ol></li><li class="chapter-item "><a href="../fight-with-compiler/unconstrained.html"><strong aria-hidden="true">6.4.</strong> 类型未限制(todo)</a></li></ol></li><li class="chapter-item expanded "><a href="../pitfalls/index.html"><strong aria-hidden="true">7.</strong> Rust陷阱系列</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../pitfalls/use-vec-in-for.html"><strong aria-hidden="true">7.1.</strong> for循环中使用外部数组</a></li><li class="chapter-item "><a href="../pitfalls/stack-overflow.html"><strong aria-hidden="true">7.2.</strong> 线程类型导致的栈溢出</a></li><li class="chapter-item "><a href="../pitfalls/arithmetic-overflow.html"><strong aria-hidden="true">7.3.</strong> 算术溢出导致的panic</a></li><li class="chapter-item "><a href="../pitfalls/closure-with-lifetime.html"><strong aria-hidden="true">7.4.</strong> 闭包中奇怪的生命周期</a></li><li class="chapter-item "><a href="../pitfalls/the-disabled-mutability.html"><strong aria-hidden="true">7.5.</strong> 可变变量不可变？</a></li><li class="chapter-item "><a href="../pitfalls/multiple-mutable-references.html"><strong aria-hidden="true">7.6.</strong> 可变借用失败引发的深入思考</a></li><li class="chapter-item "><a href="../pitfalls/lazy-iterators.html"><strong aria-hidden="true">7.7.</strong> 不太勤快的迭代器</a></li><li class="chapter-item "><a href="../pitfalls/weird-ranges.html"><strong aria-hidden="true">7.8.</strong> 奇怪的序列x..y</a></li><li class="chapter-item "><a href="../pitfalls/iterator-everywhere.html"><strong aria-hidden="true">7.9.</strong> 无处不在的迭代器</a></li><li class="chapter-item "><a href="../pitfalls/main-with-channel-blocked.html"><strong aria-hidden="true">7.10.</strong> 线程间传递消息导致主线程无法结束</a></li></ol></li><li class="chapter-item expanded "><a href="../practice/intro.html"><strong aria-hidden="true">8.</strong> Rust最佳实践 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../practice/third-party-libs.html"><strong aria-hidden="true">8.1.</strong> 日常开发三方库精选</a></li><li class="chapter-item "><a href="../practice/coding-tips.html"><strong aria-hidden="true">8.2.</strong> 一些写代码的技巧 todo</a></li><li class="chapter-item "><a href="../practice/best-pratice.html"><strong aria-hidden="true">8.3.</strong> 最佳实践 todo</a></li><li class="chapter-item "><a href="../practice/good-sourcecode.html"><strong aria-hidden="true">8.4.</strong> 值得学习的源代码 todo</a></li><li class="chapter-item "><a href="../practice/style-guide/intro.html"><strong aria-hidden="true">8.5.</strong> 代码规范 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../practice/style-guide/naming.html"><strong aria-hidden="true">8.5.1.</strong> 命名规范</a></li><li class="chapter-item "><a href="../practice/style-guide/code.html"><strong aria-hidden="true">8.5.2.</strong> 代码风格(todo)</a></li><li class="chapter-item "><a href="../practice/style-guide/mark.html"><strong aria-hidden="true">8.5.3.</strong> 代码标记 todo</a></li><li class="chapter-item "><a href="../practice/style-guide/clippy.html"><strong aria-hidden="true">8.5.4.</strong> Clippy todo</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> 如何实现一个链表 todo</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Javascript 和 WASM todo</div></li><li class="chapter-item expanded "><a href="../converse/intro.html"><strong aria-hidden="true">11.</strong> 进阶类型转换</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../converse/enum-int.html"><strong aria-hidden="true">11.1.</strong> 枚举和整数</a></li></ol></li><li class="chapter-item expanded "><a href="../errorindex/intro.html"><strong aria-hidden="true">12.</strong> 复杂错误索引 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../errorindex/borrowing/intro.html"><strong aria-hidden="true">12.1.</strong> 所有权和借用 todo</a></li><li class="chapter-item "><a href="../errorindex/lifetime/intro.html"><strong aria-hidden="true">12.2.</strong> 生命周期 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../cargo/intro.html"><strong aria-hidden="true">13.</strong> Cargo详解 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../cargo/commands.html"><strong aria-hidden="true">13.1.</strong> 常用命令 todo</a></li><li class="chapter-item "><a href="../cargo/layout.html"><strong aria-hidden="true">13.2.</strong> 项目结构 todo</a></li><li class="chapter-item "><a href="../cargo/cargo-toml-lock.html"><strong aria-hidden="true">13.3.</strong> Cargo.toml和Cargo.lock todo</a></li><li class="chapter-item "><a href="../cargo/dependency.html"><strong aria-hidden="true">13.4.</strong> 依赖管理 todo</a></li><li class="chapter-item "><a href="../cargo/cache.html"><strong aria-hidden="true">13.5.</strong> 构建缓存 todo</a></li><li class="chapter-item "><a href="../cargo/version.html"><strong aria-hidden="true">13.6.</strong> 版本管理 todo</a></li><li class="chapter-item "><a href="../cargo/workspace.html"><strong aria-hidden="true">13.7.</strong> 工作空间 todo</a></li><li class="chapter-item "><a href="../cargo/feature.html"><strong aria-hidden="true">13.8.</strong> 条件编译、条件依赖 todo</a></li><li class="chapter-item "><a href="../cargo/manifest.html"><strong aria-hidden="true">13.9.</strong> 配置参数 todo</a></li><li class="chapter-item "><a href="../cargo/build-js.html"><strong aria-hidden="true">13.10.</strong> 自定义构建脚本 todo</a></li><li class="chapter-item "><a href="../cargo/profile.html"><strong aria-hidden="true">13.11.</strong> Cargo profile todo</a></li></ol></li><li class="chapter-item expanded "><a href="../test/intro.html"><strong aria-hidden="true">14.</strong> 测试 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../test/unit.html"><strong aria-hidden="true">14.1.</strong> 单元测试 todo</a></li><li class="chapter-item "><a href="../test/intergration.html"><strong aria-hidden="true">14.2.</strong> 集成测试 todo</a></li><li class="chapter-item "><a href="../test/benchmark.html"><strong aria-hidden="true">14.3.</strong> 性能测试 todo</a></li><li class="chapter-item "><a href="../test/ci.html"><strong aria-hidden="true">14.4.</strong> 持续集成 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../traits/intro.html"><strong aria-hidden="true">15.</strong> 常见特征解析 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../traits/from-into.html"><strong aria-hidden="true">15.1.</strong> 类型转换From/Into todo</a></li><li class="chapter-item "><a href="../traits/as-ref-as-mut.html"><strong aria-hidden="true">15.2.</strong> AsRef, AsMut todo</a></li><li class="chapter-item "><a href="../traits/borrow-family.html"><strong aria-hidden="true">15.3.</strong> Borrow, BorrowMut, ToOwned todo</a></li><li class="chapter-item "><a href="../traits/deref.html"><strong aria-hidden="true">15.4.</strong> Deref和引用隐式转换 todo</a></li><li class="chapter-item "><a href="../traits/cow.html"><strong aria-hidden="true">15.5.</strong> 写时拷贝Cow todo</a></li><li class="chapter-item "><a href="../traits/eq.html"><strong aria-hidden="true">15.6.</strong> Eq todo</a></li></ol></li><li class="chapter-item expanded "><a href="../memory/intro.html"><strong aria-hidden="true">16.</strong> 深入内存 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../memory/pointer-ref.html"><strong aria-hidden="true">16.1.</strong> 指针和引用 todo</a></li><li class="chapter-item "><a href="../memory/uninit.html"><strong aria-hidden="true">16.2.</strong> 未初始化内存 todo</a></li><li class="chapter-item "><a href="../memory/allocation.html"><strong aria-hidden="true">16.3.</strong> 内存分配 todo</a></li><li class="chapter-item "><a href="../memory/layout.html"><strong aria-hidden="true">16.4.</strong> 内存布局 todo</a></li><li class="chapter-item "><a href="../memory/virtual.html"><strong aria-hidden="true">16.5.</strong> 虚拟内存 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../web/intro.html"><strong aria-hidden="true">17.</strong> Web应用开发 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../web/serialization.html"><strong aria-hidden="true">17.1.</strong> 编解码与序列化 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../object-oriented/intro.html"><strong aria-hidden="true">18.</strong> 面向对象 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../object-oriented/characteristics.html"><strong aria-hidden="true">18.1.</strong> 为何OO todo</a></li><li class="chapter-item "><a href="../object-oriented/design-pattern.html"><strong aria-hidden="true">18.2.</strong> 设计模式 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../macro/intro.html"><strong aria-hidden="true">19.</strong> 宏编程 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../macro/procedure-macro.html"><strong aria-hidden="true">19.1.</strong> 过程宏(todo)</a></li></ol></li><li class="chapter-item expanded "><a href="../performance/intro.html"><strong aria-hidden="true">20.</strong> 性能调优 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../performance/deep-into-move.html"><strong aria-hidden="true">20.1.</strong> 深入理解move</a></li><li class="chapter-item "><a href="../performance/early-optimise.html"><strong aria-hidden="true">20.2.</strong> 糟糕的提前优化 todo</a></li><li class="chapter-item "><a href="../performance/clone-copy.html"><strong aria-hidden="true">20.3.</strong> Clone和Copy todo</a></li><li class="chapter-item "><a href="../performance/benchmark.html"><strong aria-hidden="true">20.4.</strong> Benchmark性能测试(todo)</a></li><li class="chapter-item "><a href="../performance/runtime-check.html"><strong aria-hidden="true">20.5.</strong> 减少Runtime check(todo)</a></li><li class="chapter-item expanded "><a href="../performance/cpu-cache.html" class="active"><strong aria-hidden="true">20.6.</strong> CPU缓存性能优化 todo</a></li><li class="chapter-item "><a href="../performance/calculate.html"><strong aria-hidden="true">20.7.</strong> 计算性能优化 todo</a></li><li class="chapter-item "><a href="../performance/heap-stack.html"><strong aria-hidden="true">20.8.</strong> 堆和栈 todo</a></li><li class="chapter-item "><a href="../performance/allocator.html"><strong aria-hidden="true">20.9.</strong> 内存allocator todo</a></li><li class="chapter-item "><a href="../performance/tools.html"><strong aria-hidden="true">20.10.</strong> 常用性能测试工具 todo</a></li><li class="chapter-item "><a href="../performance/enum.html"><strong aria-hidden="true">20.11.</strong> Enum内存优化 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../compiler/intro.html"><strong aria-hidden="true">21.</strong> 编译器 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../compiler/attributes.html"><strong aria-hidden="true">21.1.</strong> 常见属性标记 todo</a></li><li class="chapter-item "><a href="../compiler/speed-up.html"><strong aria-hidden="true">21.2.</strong> 提升编译速度 todo</a></li><li class="chapter-item "><a href="../compiler/optimization/intro.html"><strong aria-hidden="true">21.3.</strong> 编译器优化 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../compiler/optimization/option.html"><strong aria-hidden="true">21.3.1.</strong> Option枚举 todo</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../monitor/intro.html"><strong aria-hidden="true">22.</strong> 日志和监控 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../monitor/log.html"><strong aria-hidden="true">22.1.</strong> 日志 todo</a></li><li class="chapter-item "><a href="../monitor/observability.html"><strong aria-hidden="true">22.2.</strong> 可观测性 todo</a></li><li class="chapter-item "><a href="../monitor/apm.html"><strong aria-hidden="true">22.3.</strong> 监控(APM) todo</a></li></ol></li><li class="chapter-item expanded "><a href="../std/intro.html"><strong aria-hidden="true">23.</strong> 标准库解析 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../std/search.html"><strong aria-hidden="true">23.1.</strong> 如何寻找你想要的内容 todo</a></li><li class="chapter-item "><a href="../std/vector.html"><strong aria-hidden="true">23.2.</strong> Vector常用方法 todo</a></li><li class="chapter-item "><a href="../std/hashmap.html"><strong aria-hidden="true">23.3.</strong> HashMap todo</a></li><li class="chapter-item "><a href="../std/iterator.html"><strong aria-hidden="true">23.4.</strong> Iterator常用方法 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../appendix/intro.html"><strong aria-hidden="true">24.</strong> 附录</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../appendix/keywords.html"><strong aria-hidden="true">24.1.</strong> A-关键字</a></li><li class="chapter-item "><a href="../appendix/operators.html"><strong aria-hidden="true">24.2.</strong> B-运算符与符号</a></li><li class="chapter-item "><a href="../appendix/expressions.html"><strong aria-hidden="true">24.3.</strong> C-表达式</a></li><li class="chapter-item "><a href="../appendix/derive.html"><strong aria-hidden="true">24.4.</strong> D-派生特征derive</a></li><li class="chapter-item "><a href="../appendix/prelude.html"><strong aria-hidden="true">24.5.</strong> E-prelude模块 todo</a></li><li class="chapter-item "><a href="../appendix/difficulties.html"><strong aria-hidden="true">24.6.</strong> F-难点索引</a></li><li class="chapter-item "><a href="../appendix/rust-version.html"><strong aria-hidden="true">24.7.</strong> G-Rust版本说明</a></li><li class="chapter-item "><a href="../appendix/rust-versions/intro.html"><strong aria-hidden="true">24.8.</strong> H-Rust更新版本列表</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../appendix/rust-versions/1.58.html"><strong aria-hidden="true">24.8.1.</strong> 1.58</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust语言圣经(Rust教程 Rust Course)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-course" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-course/edit/main/book/contents/performance/cpu-cache.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cpu缓存性能优化"><a class="header" href="#cpu缓存性能优化">CPU缓存性能优化</a></h1>
<p>https://github.com/TC5027/blog/blob/master/false_sharing.md</p>
<h1 id="on-a-use-of-the-repr-attribute-in-rust"><a class="header" href="#on-a-use-of-the-repr-attribute-in-rust">On a use of the &quot;repr&quot; attribute in Rust</a></h1>
<p>Consider we work with the following struct representing a counter,</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counter(u64);
<span class="boring">}
</span></code></pre></pre>
<p>and we want to increment it with random <code>u8</code> values with the help of a for loop : </p>
<pre><pre class="playground"><code class="language-rust edition2021">use rand::Rng;
fn main() {
	let mut counter = Counter(0);
	let mut rng = rand::thread_rng();
	
	for _ in 0..1_000_000 {
		counter.0 += rng.gen::&lt;u8&gt;() as u64;
	}
}
</code></pre></pre>
<p>This takes 1.90ms to run on my laptop using <code>cargo run --release</code>. Remember this timing as it will be our reference value :)
Now suppose we were given this struct, holding not 1 but 2 counters : </p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counters {
	c1 : u64,
	c2 : u64
}
<span class="boring">}
</span></code></pre></pre>
<p>Using the same approach, performing the increments for the 2 counters in a single-threaded fashion, we would expect to be twice slower (in fact it takes 3.71ms to execute).
Can we do better ? Well, as our 2 counters are independent, we could spawn 2 threads, assign them one counter and increment concurrently ! Given I have 4 CPUs on my laptop, I would expect to be just as fast as the first scenario. Let's see !</p>
<p>First thing, we could create a local variable in each thread which would be incremented and then we would set the counter value to this incremented one (spoiler : good idea). But we could also save these 2 variables and share the <code>Counter</code> between the 2 threads with an <code>Arc</code> (spoiler : definitely not worth). Let's do this second option ! ^^</p>
<p>Doing the following code, </p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	let counters = Arc::new(Counters{c1:0, c2:0});
	let counters_clone = counters.clone();
	
	let handler1 = thread::spawn(move || {
		let mut rng = rand::thread_rng();
		for _ in 0..1_000_000 {
			counters.c1 += rng.gen::&lt;u8&gt;() as u64;
		}
	});
	let handler2 = thread::spawn(move || {
		let mut rng = rand::thread_rng();
		for _ in 0..1_000_000 {
			counters_clone.c2 += rng.gen::&lt;u8&gt;() as u64;
		}
	});
	handler1.join(); handler2.join();
}
</code></pre></pre>
<p>we end up with an error : </p>
<p><strong>cannot assign to data in an <code>Arc</code></strong>
<strong>cannot assign</strong>
<strong>help: trait <code>DerefMut</code> is required to modify through a dereference, but it is not implemented for <code>std::sync::Arc&lt;Counters&gt;</code>rustc(E0594)</strong></p>
<p>Unlucky. Maybe we could use <strong>atomic types</strong>. These types provide operations that synchronize updates between threads. In fact, as an equivalent of <code>+=</code> we could use the <code>fetch_add</code> method which has the following signature : <code>pub fn fetch_add(&amp;self, val: u64, order: Ordering) -&gt; u64</code>. What should be highlighted is the <code>&amp;self</code>. We could expect a <code>&amp;mut self</code> given the modification we want to perform using it but thanks to the property that an atomic operation is performed without interruptions we don't need exclusive access to the variable to safely update it.
We can solve the error replacing the counter's type by <code>AtomicU64</code> as like that we only require <code>Arc</code> to implement the <code>Deref</code> trait (given the signature of <code>fetch_add</code>) and it is the case !</p>
<p>We so have to change a bit our struct to : </p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counters {
	c1 : AtomicU64,
	c2 : AtomicU64,
}
<span class="boring">}
</span></code></pre></pre>
<p>and our code to :</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let counters = Arc::new(Counters{
        c1 :  AtomicU64::new(0),
        c2 : AtomicU64::new(0)
    });
    let counters_clone = counters.clone();
    let handler1 = thread::spawn(move || {
        let mut rng = rand::thread_rng();
        for _ in 0..1_000_000 {
            counters.c1.fetch_add(rng.gen::&lt;u8&gt;() as u64,Relaxed);
        }
    });
    let handler2 = thread::spawn(move || {
        let mut rng = rand::thread_rng();
        for _ in 0..1_000_000 {
            counters_clone.c2.fetch_add(rng.gen::&lt;u8&gt;() as u64,Relaxed);
        }
    });
    handler1.join();handler2.join();
}
</code></pre></pre>
<p>We could naturally expect the operation on Atomics to be a bit slower than the ones on <code>u64</code> but let's see !
30.22ms .. ok... that's terrible ^^
Do Atomics operations explain all this ?
I ran a benchmark to compare <code>+=</code> and <code>fetch_add( ,Relaxed)</code> to figure it out : </p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut sum = 0;
let start = Instant::now();
for _ in 0..10_000_000 {
	sum += rng.gen::&lt;u8&gt;() as u64;
}
println!(&quot;time spent u64 sum : {:?}&quot;, start.elapsed());
let atomic_sum = AtomicU64::new(0);
let start = Instant::now();
for _ in 0..10_000_000 {
	atomic_sum.fetch_add(rng.gen::&lt;u8&gt;() as u64, Relaxed);
}
println!(&quot;time spent AtomicU64 sum : {:?}&quot;, start.elapsed());
<span class="boring">}
</span></code></pre></pre>
<p>The <code>u64</code> sums takes 20.07ms while the <code>AtomicU64</code> one takes 70.28ms. So we should only be 3 times slower than 2ms but we are 15 times slower how can it be ???</p>
<p>Hint : CPU cache... but why should we care ?
CPU cache is a data storage, located close to CPU, offering a fast access to data.
In a computer, when the CPU needs to read or write a value, it checks if it is present inside the cache or not. If it is the case then the CPU directly uses the cached data. Otherwise, the cache allocates a new entry and copies data from main memory, an entry being of fixed size and called <em>cache line</em>.
CPU cache is relatively small compared to RAM but much faster, and that's why a program should be designed to use as much as possible data lying in cache, based on a locality principle, to avoid expensive access to RAM.</p>
<p>If we represent our current situation it looks like this :
<img src="https://github.com/TC5027/blog/blob/master/pngs/false_sharing.png" alt="figure" /></p>
<p>The red square corresponds to the first counter and the green one to the second. They can potentially lie in the same cache line !</p>
<p>If data is modified through CPU 0 in its L1 cache we expect our computer to reflect the changes both in memory and in the other L1 cache. To ensure this coherency, there exists coherence protocols which can force the <strong>whole cache line</strong> impacted by the change to be propagated through the whole system, in order to update the copies of the value changed.</p>
<p>With that in mind, what is happening in our code comes from that : we suffer from coherency protocol due to our 2 counters lying on the same cache line. Updating first counter through CPU 0 involves an update in the system of the data stored in the cache line where the second counter (unchanged) potentially lies. During this update, CPU 1 cannot access the second counter whereas it is clearly independent from the change made by CPU 0, and that's why we are slow.
How can we solve then ? well by making sure that the counters lie on different cache lines and that's where we can use the <code>repr</code> attribute.</p>
<p>In Rust, we can specify the alignment we want for our type with the <code>repr(align)</code> attribute. We use it like this : </p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(align(64))]
struct CachePadded(AtomicU64);
<span class="boring">}
</span></code></pre></pre>
<p>A data of alignment X is stored in memory at address multiple of X. Knowing this, giving to our counters an alignment equal to the size of a cache line, we ensure that the 2 counters won't be stored in the same cache line !</p>
<p>We can get the size of cache lines with command <code>getconf LEVEL1_DCACHE_LINESIZE</code>. On my laptop the output value is 64.</p>
<p>With those changes we have now a timing of 7.16ms which seems decent given we work with Atomics. Mission succeeded ! </p>
<p>Finally given my remark at the beginning, I wanted to share a potentially better solution, using local variables in the threads, and channels to communicate these local variables back to the main thread :</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc::channel;
fn main() {
    let (s1,t1) = channel();
    let (s2,t2) = channel();
    let h1 = thread::spawn(move || {
        let mut local_counter = 0;
        let mut rng = rand::thread_rng();
        for _ in 0..1_000_000 {
            local_counter += rng.gen::&lt;u8&gt;() as u64;
        }
        s1.send(local_counter)
    });
    let h2 = thread::spawn(move || {
        let mut local_counter = 0;
        let mut rng = rand::thread_rng();
        for _ in 0..1_000_000 {
            local_counter += rng.gen::&lt;u8&gt;() as u64;
        }
        s2.send(local_counter)
    });
    
    h1.join();
    h2.join();
    let counter = Counters{c1: t1.recv().unwrap(),c2: t2.recv().unwrap()};
}
</code></pre></pre>
<p>It takes 2.03 ms to execute :)</p>
<h2 id="动态和静态分发"><a class="header" href="#动态和静态分发">动态和静态分发</a></h2>
<p>https://www.reddit.com/r/rust/comments/ruavjm/is_there_a_difference_in_performance_between/</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../performance/runtime-check.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../performance/calculate.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../performance/runtime-check.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../performance/calculate.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../assets/ferris.js"></script>


    </body>
</html>
