<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust语言圣经(Rust教程 Rust Course)</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/ferris.css">
        <link rel="stylesheet" href="assets/theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="into-rust.html">进入Rust编程世界</a></li><li class="chapter-item expanded affix "><a href="about-book.html">关于本书</a></li><li class="chapter-item expanded affix "><a href="sth-you-should-not-do.html">避免从入门到放弃</a></li><li class="chapter-item expanded "><a href="first-try/intro.html"><strong aria-hidden="true">1.</strong> 寻找牛刀，以便小试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="first-try/installation.html"><strong aria-hidden="true">1.1.</strong> 安装Rust环境</a></li><li class="chapter-item "><a href="first-try/editor.html"><strong aria-hidden="true">1.2.</strong> 墙推VSCode!</a></li><li class="chapter-item "><a href="first-try/cargo.html"><strong aria-hidden="true">1.3.</strong> 认识Cargo</a></li><li class="chapter-item "><a href="first-try/hello-world.html"><strong aria-hidden="true">1.4.</strong> 不仅仅是Hello world</a></li></ol></li><li class="chapter-item expanded "><a href="basic/intro.html"><strong aria-hidden="true">2.</strong> Rust基础入门</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic/variable.html"><strong aria-hidden="true">2.1.</strong> 变量绑定与解构</a></li><li class="chapter-item "><a href="basic/base-type/index.html"><strong aria-hidden="true">2.2.</strong> 基本类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic/base-type/numbers.html"><strong aria-hidden="true">2.2.1.</strong> 数值类型</a></li><li class="chapter-item "><a href="basic/base-type/char-bool.html"><strong aria-hidden="true">2.2.2.</strong> 字符、布尔、元类型</a></li><li class="chapter-item "><a href="basic/base-type/statement-expression.html"><strong aria-hidden="true">2.2.3.</strong> 语句与表达式</a></li><li class="chapter-item "><a href="basic/base-type/function.html"><strong aria-hidden="true">2.2.4.</strong> 函数</a></li></ol></li><li class="chapter-item "><a href="basic/ownership/index.html"><strong aria-hidden="true">2.3.</strong> 所有权和借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic/ownership/ownership.html"><strong aria-hidden="true">2.3.1.</strong> 所有权</a></li><li class="chapter-item "><a href="basic/ownership/borrowing.html"><strong aria-hidden="true">2.3.2.</strong> 引用与借用</a></li></ol></li><li class="chapter-item "><a href="basic/compound-type/intro.html"><strong aria-hidden="true">2.4.</strong> 复合类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic/compound-type/string-slice.html"><strong aria-hidden="true">2.4.1.</strong> 字符串与切片</a></li><li class="chapter-item "><a href="basic/compound-type/tuple.html"><strong aria-hidden="true">2.4.2.</strong> 元组</a></li><li class="chapter-item "><a href="basic/compound-type/struct.html"><strong aria-hidden="true">2.4.3.</strong> 结构体</a></li><li class="chapter-item "><a href="basic/compound-type/enum.html"><strong aria-hidden="true">2.4.4.</strong> 枚举</a></li><li class="chapter-item "><a href="basic/compound-type/array.html"><strong aria-hidden="true">2.4.5.</strong> 数组</a></li></ol></li><li class="chapter-item "><a href="basic/flow-control.html"><strong aria-hidden="true">2.5.</strong> 流程控制</a></li><li class="chapter-item "><a href="basic/match-pattern/intro.html"><strong aria-hidden="true">2.6.</strong> 模式匹配</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic/match-pattern/match-if-let.html"><strong aria-hidden="true">2.6.1.</strong> match和if let</a></li><li class="chapter-item "><a href="basic/match-pattern/option.html"><strong aria-hidden="true">2.6.2.</strong> 解构Option</a></li><li class="chapter-item "><a href="basic/match-pattern/pattern-match.html"><strong aria-hidden="true">2.6.3.</strong> 模式适用场景</a></li><li class="chapter-item "><a href="basic/match-pattern/all-patterns.html"><strong aria-hidden="true">2.6.4.</strong> 全模式列表</a></li></ol></li><li class="chapter-item "><a href="basic/method.html"><strong aria-hidden="true">2.7.</strong> 方法Method</a></li><li class="chapter-item "><a href="basic/trait/intro.html"><strong aria-hidden="true">2.8.</strong> 泛型和特征</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic/trait/generic.html"><strong aria-hidden="true">2.8.1.</strong> 泛型Generics</a></li><li class="chapter-item "><a href="basic/trait/trait.html"><strong aria-hidden="true">2.8.2.</strong> 特征Trait</a></li><li class="chapter-item "><a href="basic/trait/trait-object.html"><strong aria-hidden="true">2.8.3.</strong> 特征对象</a></li><li class="chapter-item "><a href="basic/trait/advance-trait.html"><strong aria-hidden="true">2.8.4.</strong> 进一步深入特征</a></li></ol></li><li class="chapter-item "><a href="basic/collections/intro.html"><strong aria-hidden="true">2.9.</strong> 集合类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic/collections/vector.html"><strong aria-hidden="true">2.9.1.</strong> 动态数组Vector</a></li><li class="chapter-item "><a href="basic/collections/hashmap.html"><strong aria-hidden="true">2.9.2.</strong> KV存储HashMap</a></li></ol></li><li class="chapter-item "><a href="basic/converse.html"><strong aria-hidden="true">2.10.</strong> 类型转换</a></li><li class="chapter-item "><a href="basic/result-error/intro.html"><strong aria-hidden="true">2.11.</strong> 返回值和错误</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic/result-error/panic.html"><strong aria-hidden="true">2.11.1.</strong> panic深入剖析!</a></li><li class="chapter-item "><a href="basic/result-error/result.html"><strong aria-hidden="true">2.11.2.</strong> 返回值Result和?</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="advance/intro.html"><strong aria-hidden="true">3.</strong> Rust高级进阶</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="advance/lifetime/intro.html"><strong aria-hidden="true">3.1.</strong> 生命周期</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="advance/lifetime/basic.html"><strong aria-hidden="true">3.1.1.</strong> 认识生命周期</a></li><li class="chapter-item "><a href="advance/lifetime/advance.html"><strong aria-hidden="true">3.1.2.</strong> 深入生命周期</a></li></ol></li><li class="chapter-item "><a href="advance/functional-programing/intro.html"><strong aria-hidden="true">3.2.</strong> 函数式编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="advance/functional-programing/closure.html"><strong aria-hidden="true">3.2.1.</strong> 闭包closure</a></li><li class="chapter-item "><a href="advance/functional-programing/iterator.html"><strong aria-hidden="true">3.2.2.</strong> 迭代器iterator</a></li></ol></li><li class="chapter-item "><a href="advance/crate-module/intro.html"><strong aria-hidden="true">3.3.</strong> 包和模块</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="advance/crate-module/crate.html"><strong aria-hidden="true">3.3.1.</strong> 包crate</a></li><li class="chapter-item "><a href="advance/crate-module/module.html"><strong aria-hidden="true">3.3.2.</strong> 模块Module</a></li><li class="chapter-item "><a href="advance/crate-module/use.html"><strong aria-hidden="true">3.3.3.</strong> 使用use引入模块及受限可见性</a></li></ol></li><li class="chapter-item "><a href="advance/comment.html"><strong aria-hidden="true">3.4.</strong> 注释和文档</a></li><li class="chapter-item "><a href="advance/custom-type.html"><strong aria-hidden="true">3.5.</strong> 深入类型之newtype和Sized</a></li><li class="chapter-item "><a href="advance/formatted-output.html"><strong aria-hidden="true">3.6.</strong> 格式化输出</a></li><li class="chapter-item "><a href="advance/smart-pointer/intro.html"><strong aria-hidden="true">3.7.</strong> 智能指针</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="advance/smart-pointer/box.html"><strong aria-hidden="true">3.7.1.</strong> Box堆对象分配</a></li><li class="chapter-item "><a href="advance/smart-pointer/deref.html"><strong aria-hidden="true">3.7.2.</strong> Deref解引用</a></li><li class="chapter-item "><a href="advance/smart-pointer/drop.html"><strong aria-hidden="true">3.7.3.</strong> Drop释放资源</a></li><li class="chapter-item "><a href="advance/smart-pointer/rc-arc.html"><strong aria-hidden="true">3.7.4.</strong> Rc与Arc实现1vN所有权机制</a></li><li class="chapter-item "><a href="advance/smart-pointer/cell-refcell.html"><strong aria-hidden="true">3.7.5.</strong> Cell与RefCell内部可变性</a></li></ol></li><li class="chapter-item "><a href="advance/circle-self-ref/intro.html"><strong aria-hidden="true">3.8.</strong> 循环引用与自引用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="advance/circle-self-ref/circle-reference.html"><strong aria-hidden="true">3.8.1.</strong> Weak与循环引用</a></li><li class="chapter-item "><a href="advance/circle-self-ref/self-referential.html"><strong aria-hidden="true">3.8.2.</strong> 结构体中的自引用</a></li></ol></li><li class="chapter-item "><a href="advance/concurrency-with-threads/intro.html"><strong aria-hidden="true">3.9.</strong> 多线程并发编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="advance/concurrency-with-threads/concurrency-parallelism.html"><strong aria-hidden="true">3.9.1.</strong> 并发和并行</a></li><li class="chapter-item "><a href="advance/concurrency-with-threads/thread.html"><strong aria-hidden="true">3.9.2.</strong> 使用多线程</a></li><li class="chapter-item "><a href="advance/concurrency-with-threads/message-passing.html"><strong aria-hidden="true">3.9.3.</strong> 线程同步：消息传递</a></li><li class="chapter-item "><a href="advance/concurrency-with-threads/sync1.html"><strong aria-hidden="true">3.9.4.</strong> 线程同步：锁、Condvar和信号量</a></li><li class="chapter-item "><a href="advance/concurrency-with-threads/sync2.html"><strong aria-hidden="true">3.9.5.</strong> 线程同步：Atomic原子操作与内存顺序</a></li><li class="chapter-item "><a href="advance/concurrency-with-threads/send-sync.html"><strong aria-hidden="true">3.9.6.</strong> 基于Send和Sync的线程安全</a></li><li class="chapter-item "><a href="advance/concurrency-with-threads/web-server.html"><strong aria-hidden="true">3.9.7.</strong> 实践应用：多线程Web服务器 todo</a></li></ol></li><li class="chapter-item "><a href="advance/unsafe/intro.html"><strong aria-hidden="true">3.10.</strong> Unsafe Rust todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="advance/unsafe/raw-pointer.html"><strong aria-hidden="true">3.10.1.</strong> 原生指针 todo</a></li><li class="chapter-item "><a href="advance/unsafe/ffi.html"><strong aria-hidden="true">3.10.2.</strong> FFI外部语言用 todo</a></li></ol></li><li class="chapter-item "><a href="advance/global-variable.html"><strong aria-hidden="true">3.11.</strong> 全局变量</a></li><li class="chapter-item "><a href="advance/errors/intro.html"><strong aria-hidden="true">3.12.</strong> 错误处理 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="advance/errors/simplify.html"><strong aria-hidden="true">3.12.1.</strong> 简化错误处理 todo</a></li><li class="chapter-item "><a href="advance/errors/user-define.html"><strong aria-hidden="true">3.12.2.</strong> 自定义错误 todo</a></li><li class="chapter-item "><a href="advance/errors/pretty-format.html"><strong aria-hidden="true">3.12.3.</strong> 让错误输出更优雅 todo</a></li><li class="chapter-item "><a href="advance/errors/panic-codes.html"><strong aria-hidden="true">3.12.4.</strong> 会导致panic的代码 todo</a></li></ol></li><li class="chapter-item "><a href="advance/hrtb.html"><strong aria-hidden="true">3.13.</strong> 高阶特征约束(HRTB) todo</a></li></ol></li><li class="chapter-item expanded "><a href="async/intro.html"><strong aria-hidden="true">4.</strong> async/await异步编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="async/getting-started.html"><strong aria-hidden="true">4.1.</strong> async编程入门</a></li><li class="chapter-item "><a href="async/future-excuting.html"><strong aria-hidden="true">4.2.</strong> 底层探秘: Future执行与任务调度</a></li><li class="chapter-item "><a href="async/pin-unpin.html"><strong aria-hidden="true">4.3.</strong> 定海神针Pin和Unpin</a></li><li class="chapter-item "><a href="async/async-await.html"><strong aria-hidden="true">4.4.</strong> async/await和Stream流处理</a></li><li class="chapter-item "><a href="async/multi-futures-simultaneous.html"><strong aria-hidden="true">4.5.</strong> 同时运行多个Future</a></li><li class="chapter-item "><a href="async/pain-points-and-workarounds.html"><strong aria-hidden="true">4.6.</strong> 一些疑难问题的解决办法</a></li><li class="chapter-item "><a href="async/web-server.html"><strong aria-hidden="true">4.7.</strong> 实践应用：Async Web服务器</a></li></ol></li><li class="chapter-item expanded "><a href="tokio/intro.html"><strong aria-hidden="true">5.</strong> tokio使用指南 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tokio/overview.html"><strong aria-hidden="true">5.1.</strong> tokio概览</a></li><li class="chapter-item "><a href="tokio/getting-startted.html"><strong aria-hidden="true">5.2.</strong> 使用初印象</a></li><li class="chapter-item "><a href="tokio/spawning.html"><strong aria-hidden="true">5.3.</strong> 创建异步任务</a></li></ol></li><li class="chapter-item expanded "><a href="fight-with-compiler/intro.html"><strong aria-hidden="true">6.</strong> 对抗编译检查 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="fight-with-compiler/phantom-data.html"><strong aria-hidden="true">6.1.</strong> 幽灵数据(todo)</a></li><li class="chapter-item "><a href="fight-with-compiler/lifetime/intro.html"><strong aria-hidden="true">6.2.</strong> 生命周期</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="fight-with-compiler/lifetime/too-long1.html"><strong aria-hidden="true">6.2.1.</strong> 生命周期过大-01</a></li><li class="chapter-item "><a href="fight-with-compiler/lifetime/too-long2.html"><strong aria-hidden="true">6.2.2.</strong> 生命周期过大-02</a></li><li class="chapter-item "><a href="fight-with-compiler/lifetime/loop.html"><strong aria-hidden="true">6.2.3.</strong> 循环中的生命周期</a></li><li class="chapter-item "><a href="fight-with-compiler/lifetime/closure-with-static.html"><strong aria-hidden="true">6.2.4.</strong> 闭包碰到特征对象-01</a></li></ol></li><li class="chapter-item "><a href="fight-with-compiler/borrowing/intro.html"><strong aria-hidden="true">6.3.</strong> 重复借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="fight-with-compiler/borrowing/ref-exist-in-out-fn.html"><strong aria-hidden="true">6.3.1.</strong> 同时在函数内外使用引用</a></li><li class="chapter-item "><a href="fight-with-compiler/borrowing/borrow-distinct-fields-of-struct.html"><strong aria-hidden="true">6.3.2.</strong> 智能指针引起的重复借用错误</a></li></ol></li><li class="chapter-item "><a href="fight-with-compiler/unconstrained.html"><strong aria-hidden="true">6.4.</strong> 类型未限制(todo)</a></li></ol></li><li class="chapter-item expanded "><a href="pitfalls/index.html"><strong aria-hidden="true">7.</strong> Rust陷阱系列</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pitfalls/use-vec-in-for.html"><strong aria-hidden="true">7.1.</strong> for循环中使用外部数组</a></li><li class="chapter-item "><a href="pitfalls/stack-overflow.html"><strong aria-hidden="true">7.2.</strong> 线程类型导致的栈溢出</a></li><li class="chapter-item "><a href="pitfalls/arithmetic-overflow.html"><strong aria-hidden="true">7.3.</strong> 算术溢出导致的panic</a></li><li class="chapter-item "><a href="pitfalls/closure-with-lifetime.html"><strong aria-hidden="true">7.4.</strong> 闭包中奇怪的生命周期</a></li><li class="chapter-item "><a href="pitfalls/the-disabled-mutability.html"><strong aria-hidden="true">7.5.</strong> 可变变量不可变？</a></li><li class="chapter-item "><a href="pitfalls/multiple-mutable-references.html"><strong aria-hidden="true">7.6.</strong> 可变借用失败引发的深入思考</a></li><li class="chapter-item "><a href="pitfalls/lazy-iterators.html"><strong aria-hidden="true">7.7.</strong> 不太勤快的迭代器</a></li><li class="chapter-item "><a href="pitfalls/weird-ranges.html"><strong aria-hidden="true">7.8.</strong> 奇怪的序列x..y</a></li><li class="chapter-item "><a href="pitfalls/iterator-everywhere.html"><strong aria-hidden="true">7.9.</strong> 无处不在的迭代器</a></li><li class="chapter-item "><a href="pitfalls/main-with-channel-blocked.html"><strong aria-hidden="true">7.10.</strong> 线程间传递消息导致主线程无法结束</a></li></ol></li><li class="chapter-item expanded "><a href="practice/intro.html"><strong aria-hidden="true">8.</strong> Rust最佳实践 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="practice/third-party-libs.html"><strong aria-hidden="true">8.1.</strong> 日常开发三方库精选</a></li><li class="chapter-item "><a href="practice/coding-tips.html"><strong aria-hidden="true">8.2.</strong> 一些写代码的技巧 todo</a></li><li class="chapter-item "><a href="practice/best-pratice.html"><strong aria-hidden="true">8.3.</strong> 最佳实践 todo</a></li><li class="chapter-item "><a href="practice/good-sourcecode.html"><strong aria-hidden="true">8.4.</strong> 值得学习的源代码 todo</a></li><li class="chapter-item "><a href="practice/style-guide/intro.html"><strong aria-hidden="true">8.5.</strong> 代码规范 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="practice/style-guide/naming.html"><strong aria-hidden="true">8.5.1.</strong> 命名规范</a></li><li class="chapter-item "><a href="practice/style-guide/code.html"><strong aria-hidden="true">8.5.2.</strong> 代码风格(todo)</a></li><li class="chapter-item "><a href="practice/style-guide/mark.html"><strong aria-hidden="true">8.5.3.</strong> 代码标记 todo</a></li><li class="chapter-item "><a href="practice/style-guide/clippy.html"><strong aria-hidden="true">8.5.4.</strong> Clippy todo</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> 如何实现一个链表 todo</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Javascript 和 WASM todo</div></li><li class="chapter-item expanded "><a href="converse/intro.html"><strong aria-hidden="true">11.</strong> 进阶类型转换</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="converse/enum-int.html"><strong aria-hidden="true">11.1.</strong> 枚举和整数</a></li></ol></li><li class="chapter-item expanded "><a href="errorindex/intro.html"><strong aria-hidden="true">12.</strong> 复杂错误索引 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="errorindex/borrowing/intro.html"><strong aria-hidden="true">12.1.</strong> 所有权和借用 todo</a></li><li class="chapter-item "><a href="errorindex/lifetime/intro.html"><strong aria-hidden="true">12.2.</strong> 生命周期 todo</a></li></ol></li><li class="chapter-item expanded "><a href="cargo/intro.html"><strong aria-hidden="true">13.</strong> Cargo详解 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cargo/commands.html"><strong aria-hidden="true">13.1.</strong> 常用命令 todo</a></li><li class="chapter-item "><a href="cargo/layout.html"><strong aria-hidden="true">13.2.</strong> 项目结构 todo</a></li><li class="chapter-item "><a href="cargo/cargo-toml-lock.html"><strong aria-hidden="true">13.3.</strong> Cargo.toml和Cargo.lock todo</a></li><li class="chapter-item "><a href="cargo/dependency.html"><strong aria-hidden="true">13.4.</strong> 依赖管理 todo</a></li><li class="chapter-item "><a href="cargo/cache.html"><strong aria-hidden="true">13.5.</strong> 构建缓存 todo</a></li><li class="chapter-item "><a href="cargo/version.html"><strong aria-hidden="true">13.6.</strong> 版本管理 todo</a></li><li class="chapter-item "><a href="cargo/workspace.html"><strong aria-hidden="true">13.7.</strong> 工作空间 todo</a></li><li class="chapter-item "><a href="cargo/feature.html"><strong aria-hidden="true">13.8.</strong> 条件编译、条件依赖 todo</a></li><li class="chapter-item "><a href="cargo/manifest.html"><strong aria-hidden="true">13.9.</strong> 配置参数 todo</a></li><li class="chapter-item "><a href="cargo/build-js.html"><strong aria-hidden="true">13.10.</strong> 自定义构建脚本 todo</a></li><li class="chapter-item "><a href="cargo/profile.html"><strong aria-hidden="true">13.11.</strong> Cargo profile todo</a></li></ol></li><li class="chapter-item expanded "><a href="test/intro.html"><strong aria-hidden="true">14.</strong> 测试 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="test/unit.html"><strong aria-hidden="true">14.1.</strong> 单元测试 todo</a></li><li class="chapter-item "><a href="test/intergration.html"><strong aria-hidden="true">14.2.</strong> 集成测试 todo</a></li><li class="chapter-item "><a href="test/benchmark.html"><strong aria-hidden="true">14.3.</strong> 性能测试 todo</a></li><li class="chapter-item "><a href="test/ci.html"><strong aria-hidden="true">14.4.</strong> 持续集成 todo</a></li></ol></li><li class="chapter-item expanded "><a href="traits/intro.html"><strong aria-hidden="true">15.</strong> 常见特征解析 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/from-into.html"><strong aria-hidden="true">15.1.</strong> 类型转换From/Into todo</a></li><li class="chapter-item "><a href="traits/as-ref-as-mut.html"><strong aria-hidden="true">15.2.</strong> AsRef, AsMut todo</a></li><li class="chapter-item "><a href="traits/borrow-family.html"><strong aria-hidden="true">15.3.</strong> Borrow, BorrowMut, ToOwned todo</a></li><li class="chapter-item "><a href="traits/deref.html"><strong aria-hidden="true">15.4.</strong> Deref和引用隐式转换 todo</a></li><li class="chapter-item "><a href="traits/cow.html"><strong aria-hidden="true">15.5.</strong> 写时拷贝Cow todo</a></li><li class="chapter-item "><a href="traits/eq.html"><strong aria-hidden="true">15.6.</strong> Eq todo</a></li></ol></li><li class="chapter-item expanded "><a href="memory/intro.html"><strong aria-hidden="true">16.</strong> 深入内存 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="memory/pointer-ref.html"><strong aria-hidden="true">16.1.</strong> 指针和引用 todo</a></li><li class="chapter-item "><a href="memory/uninit.html"><strong aria-hidden="true">16.2.</strong> 未初始化内存 todo</a></li><li class="chapter-item "><a href="memory/allocation.html"><strong aria-hidden="true">16.3.</strong> 内存分配 todo</a></li><li class="chapter-item "><a href="memory/layout.html"><strong aria-hidden="true">16.4.</strong> 内存布局 todo</a></li><li class="chapter-item "><a href="memory/virtual.html"><strong aria-hidden="true">16.5.</strong> 虚拟内存 todo</a></li></ol></li><li class="chapter-item expanded "><a href="web/intro.html"><strong aria-hidden="true">17.</strong> Web应用开发 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="web/serialization.html"><strong aria-hidden="true">17.1.</strong> 编解码与序列化 todo</a></li></ol></li><li class="chapter-item expanded "><a href="object-oriented/intro.html"><strong aria-hidden="true">18.</strong> 面向对象 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="object-oriented/characteristics.html"><strong aria-hidden="true">18.1.</strong> 为何OO todo</a></li><li class="chapter-item "><a href="object-oriented/design-pattern.html"><strong aria-hidden="true">18.2.</strong> 设计模式 todo</a></li></ol></li><li class="chapter-item expanded "><a href="macro/intro.html"><strong aria-hidden="true">19.</strong> 宏编程 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="macro/procedure-macro.html"><strong aria-hidden="true">19.1.</strong> 过程宏(todo)</a></li></ol></li><li class="chapter-item expanded "><a href="performance/intro.html"><strong aria-hidden="true">20.</strong> 性能调优 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="performance/deep-into-move.html"><strong aria-hidden="true">20.1.</strong> 深入理解move</a></li><li class="chapter-item "><a href="performance/early-optimise.html"><strong aria-hidden="true">20.2.</strong> 糟糕的提前优化 todo</a></li><li class="chapter-item "><a href="performance/clone-copy.html"><strong aria-hidden="true">20.3.</strong> Clone和Copy todo</a></li><li class="chapter-item "><a href="performance/benchmark.html"><strong aria-hidden="true">20.4.</strong> Benchmark性能测试(todo)</a></li><li class="chapter-item "><a href="performance/runtime-check.html"><strong aria-hidden="true">20.5.</strong> 减少Runtime check(todo)</a></li><li class="chapter-item "><a href="performance/cpu-cache.html"><strong aria-hidden="true">20.6.</strong> CPU缓存性能优化 todo</a></li><li class="chapter-item "><a href="performance/calculate.html"><strong aria-hidden="true">20.7.</strong> 计算性能优化 todo</a></li><li class="chapter-item "><a href="performance/heap-stack.html"><strong aria-hidden="true">20.8.</strong> 堆和栈 todo</a></li><li class="chapter-item "><a href="performance/allocator.html"><strong aria-hidden="true">20.9.</strong> 内存allocator todo</a></li><li class="chapter-item "><a href="performance/tools.html"><strong aria-hidden="true">20.10.</strong> 常用性能测试工具 todo</a></li><li class="chapter-item "><a href="performance/enum.html"><strong aria-hidden="true">20.11.</strong> Enum内存优化 todo</a></li></ol></li><li class="chapter-item expanded "><a href="compiler/intro.html"><strong aria-hidden="true">21.</strong> 编译器 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compiler/attributes.html"><strong aria-hidden="true">21.1.</strong> 常见属性标记 todo</a></li><li class="chapter-item "><a href="compiler/speed-up.html"><strong aria-hidden="true">21.2.</strong> 提升编译速度 todo</a></li><li class="chapter-item "><a href="compiler/optimization/intro.html"><strong aria-hidden="true">21.3.</strong> 编译器优化 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compiler/optimization/option.html"><strong aria-hidden="true">21.3.1.</strong> Option枚举 todo</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="monitor/intro.html"><strong aria-hidden="true">22.</strong> 日志和监控 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="monitor/log.html"><strong aria-hidden="true">22.1.</strong> 日志 todo</a></li><li class="chapter-item "><a href="monitor/observability.html"><strong aria-hidden="true">22.2.</strong> 可观测性 todo</a></li><li class="chapter-item "><a href="monitor/apm.html"><strong aria-hidden="true">22.3.</strong> 监控(APM) todo</a></li></ol></li><li class="chapter-item expanded "><a href="std/intro.html"><strong aria-hidden="true">23.</strong> 标准库解析 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/search.html"><strong aria-hidden="true">23.1.</strong> 如何寻找你想要的内容 todo</a></li><li class="chapter-item "><a href="std/vector.html"><strong aria-hidden="true">23.2.</strong> Vector常用方法 todo</a></li><li class="chapter-item "><a href="std/hashmap.html"><strong aria-hidden="true">23.3.</strong> HashMap todo</a></li><li class="chapter-item "><a href="std/iterator.html"><strong aria-hidden="true">23.4.</strong> Iterator常用方法 todo</a></li></ol></li><li class="chapter-item expanded "><a href="appendix/intro.html"><strong aria-hidden="true">24.</strong> 附录</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="appendix/keywords.html"><strong aria-hidden="true">24.1.</strong> A-关键字</a></li><li class="chapter-item "><a href="appendix/operators.html"><strong aria-hidden="true">24.2.</strong> B-运算符与符号</a></li><li class="chapter-item "><a href="appendix/expressions.html"><strong aria-hidden="true">24.3.</strong> C-表达式</a></li><li class="chapter-item "><a href="appendix/derive.html"><strong aria-hidden="true">24.4.</strong> D-派生特征derive</a></li><li class="chapter-item "><a href="appendix/prelude.html"><strong aria-hidden="true">24.5.</strong> E-prelude模块 todo</a></li><li class="chapter-item "><a href="appendix/difficulties.html"><strong aria-hidden="true">24.6.</strong> F-难点索引</a></li><li class="chapter-item "><a href="appendix/rust-version.html"><strong aria-hidden="true">24.7.</strong> G-Rust版本说明</a></li><li class="chapter-item "><a href="appendix/rust-versions/intro.html"><strong aria-hidden="true">24.8.</strong> H-Rust更新版本列表</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="appendix/rust-versions/1.58.html"><strong aria-hidden="true">24.8.1.</strong> 1.58</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust语言圣经(Rust教程 Rust Course)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-course" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="进入-rust-编程世界"><a class="header" href="#进入-rust-编程世界">进入 Rust 编程世界</a></h1>
<h2 id="rust-发展历程"><a class="header" href="#rust-发展历程">Rust 发展历程</a></h2>
<p>Rust 最早是 Mozilla 雇员 Graydon Hoare 的个人项目。从 2009 年开始，得到了 Mozilla 研究院的资助。2010 年项目对外公布，2010 ～ 2011 年间实现自举。自此以后，Rust 在设计变化 -&gt; 崩溃的边缘反复横跳（历程极其艰辛）。终于，在 2015 年 5 月 15 日发布 1.0 版。</p>
<p>在此研发过程中，Rust 建立了一个强大且活跃社区，形成了一整套完善稳定的项目贡献机制（Rust 能够飞速发展，与这一点密不可分）。Rust 现在由 <a href="https://github.com/rust-lang/rust">Rust 项目开发者社区</a> 维护。</p>
<p>大家可能疑惑 Rust 为啥用了这么久才到 1.0 版本？与之相比，Go 语言 2009 年发布，却在 2012 年仅用 3 年就发布了 1.0 版本。</p>
<ul>
<li>首先，因为 Rust 语言特性较为复杂，所以需要全盘考虑的问题非常多；</li>
<li>其次，Rust 当时的参与者太多，七嘴八舌的声音很多，众口难调，而 Rust 开发团队又非常重视社区的意见；</li>
<li>最后，一旦 1.0 快速发布，那么后续大部分语言特性就无法再修改，对于有完美强迫症的 Rust 开发者团队来说，某种程度上的不完美是不可接受的。</li>
</ul>
<p>因此，Rust 语言用了足足 6 年时间，才发布了尽善尽美的 1.0 版本。</p>
<h2 id="为何又来了一门新语言"><a class="header" href="#为何又来了一门新语言">为何又来了一门新语言？</a></h2>
<p>简而言之，因为还缺一门无 GC、性能高、工程性强、语言级安全性以及能同时得到工程派和学院派认可的语言，而 Rust 算是这样的语言。你也可以回忆下熟悉的语言，看是不是有另外一门语言可以同时满足这些需求：)</p>
<p>Rust 最为人诟病的点，也就一个：学习曲线陡峭。不过其实严格来说，当语言生态起来后，这个不算问题。</p>
<h3 id="缓解内卷"><a class="header" href="#缓解内卷">缓解内卷</a></h3>
<p>有人说 Rust 作为新语言会增加内卷，其实恰恰相反，Rust 可以缓解内卷。为何不说 C++内卷，说 Java、Python、JS 内卷？不就是后几个相对简单、上手容易嘛？而 Rust 怎么看也是 C++ 级别的上手难度。</p>
<p>其实从我内心不可告人的角度出发，并不希望 Rust 大众化，因为这样可以保饭碗、保薪资，还能更有行业内地位。但是从对 Rust 的喜爱角度出发，我还是希望能卷一些。但是，目前来看真的卷不动，现在全世界范围内 Rust 的需求都大于供给，特别是优秀的 Rust 程序员更是难寻。</p>
<p>与 Go 语言相比，成为一个优秀的 Rust 程序员所需的门槛高得多，例如融汇贯通 Rust 语言各种中高级特性、闭着眼睛趟过各种坑、不用回忆无需查找就能立刻写出最合适的包/模块/方法、性能/安全/工程性的权衡选择信手拈来、深层性能优化易如反掌、异步编程小菜一碟，更别说 Rust 之外的操作系统、网络、算法等等相关知识。</p>
<p>所以，Rust 可以缓解内卷，而不是增加内卷。可以说是程序员的福音，不再是被随意替换的螺丝钉。</p>
<h3 id="效率"><a class="header" href="#效率">效率</a></h3>
<p>下面从三个角度来谈谈 Rust 的效率：学习、运行、开发。</p>
<h4 id="学习效率"><a class="header" href="#学习效率">学习效率</a></h4>
<p>众所周知，Rust 学习曲线陡峭。最初我对此说法还嗤之以鼻，随着不断的深入，我现在也很认可这个说法。Rust 之难，不在于语言特性，这些都可以很容易学到，而在于：</p>
<ul>
<li>实践中如何融会贯通的运用</li>
<li>遇到了坑时（生命周期、借用错误，自引用等）如何迅速、正确的解决</li>
<li>大量的标准库方法记忆及熟练使用，这些是保证开发效率的关键</li>
<li>心智负担较重，特别是初中级阶段</li>
</ul>
<p>好在，针对这些，目前国内有了一门非常全面的 <a href="https://github.com/sunface/rust-course">Rust 学习教程</a>（非官方那本书），可以有效降低 Rust 的学习和使用门槛。</p>
<h4 id="运行效率"><a class="header" href="#运行效率">运行效率</a></h4>
<p>得益于各种零开销抽象、深入到底层的优化潜力、优质的标准库和第三方库实现，Rust 具备非常优秀的性能，和 C、C++ 是 <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust.html">一个级别</a>。</p>
<p>同时 Rust 有一个极大的好处：只要按照正确的方式使用 Rust，无需性能优化，就能实现非常优秀的表现，不可谓不惊艳。</p>
<p>现在有不少用 Rust 重写的工具、平台都超过了原来用 C、C++ 实现的版本，将老前辈拍死在沙滩上，俨然成为一种潮流～～</p>
<h4 id="开发效率"><a class="header" href="#开发效率">开发效率</a></h4>
<p>Rust 的开发效率可以用先抑后扬来形容。在刚开始上手写项目时，你的开发速度将显著慢于 Go、Java 等语言，不过，一旦开始熟悉标准库常用的方法，开发效率将大幅提升，甚至当形成肌肉记忆后，开发效率将不会慢于这些语言，而且原生就能写出高质量、安全、高效的代码，可以说中高级 Rust 程序员就是高效程序员的代名词。</p>
<h3 id="个人的好处"><a class="header" href="#个人的好处">个人的好处</a></h3>
<p>学习 Rust 对个人也有极大的好处。</p>
<h4 id="成为更好的程序员"><a class="header" href="#成为更好的程序员">成为更好的程序员</a></h4>
<p>要学好 Rust，你需要深入理解内存、堆栈、引用、变量作用域等这些其它高级语言往往不会深入接触的内容。另外，Rust 会通过语法、编译器和 clippy 这些静态检查工具半帮助半强迫的让你成为更优秀的程序员，写出更好的代码。</p>
<p>同时，当你掌握了 Rust，你就会自发性的想要去做一些更偏底层的事情，这些都可以帮助你更加了解操作系统、网络、性能优化等底层知识，也会间接或者直接的接触到各种算法和数据结构的实现。</p>
<p>慢慢的，你就在成为那个更好的程序员，也是更优秀的自己。</p>
<h4 id="增加不可替代性"><a class="header" href="#增加不可替代性">增加不可替代性</a></h4>
<p>语言难学，也有好处。一旦掌握，你将具备较强的不可替代性，不再是一个简单的工具人角色。看看现在内卷严重的 Java，工具人有多少！一个人离职，另外一个人很快就能替补上。</p>
<p>当然，我不是说 Rust 会给公司带来这种隐形的维护成本，毕竟这其实是一种双赢，公司收获了更优秀的程序员（不可否认的是 Rust 程序员普遍确实水平更高，毕竟都是有很好的其它语言基础、也很有追求的自驱型人才），而你也收获了更稳定的工作环境，甚至是更高的收入。</p>
<h3 id="团队的好处"><a class="header" href="#团队的好处">团队的好处</a></h3>
<p>先不说安全、可靠性等对公司团队非常友好的特性，就说 Rust 程序只要能跑起来，那代码质量其实就是相当不错的，因为 Rust 编译器、clippy 啥的实在是严师厉友，甚至有些鸡毛。</p>
<p>正因为这较高的质量下限，我们在 review 时并不用担心潜在的各种坑，因此可以实现快速的开发、review、merge 流程。</p>
<p>而且由于 Rust 语言拥有异常强大的编译器和语言特性，因此 Rust 的代码天然就会比其它语言有更少的 Bug。同时 Rust 拥有非常完善的工具链，最好的包管理工具，这些叠加在一起，决定了 Rust 非常适合大型开发者团队的协作开发。</p>
<p>也许 Rust 在开发速度上不是最快的，但是从开发 + 维护的角度来看，这个成本在各个语言中绝对是很小的。当然，如果你的公司就追求做出来能用就行，那 Rust 确实有些灰姑娘的感觉。</p>
<p>还有一点很重要，现在的 Rust 程序员往往拥有更出众的能力和学习自驱性，因此团队招到的人天然就保持了较高的底线。如果你有幸招到一个优秀的 Rust 程序员，那真是捡到宝了，他也会同时带动周围的人一起慢慢优秀（优秀的 Rust 程序员比较好辨别，门槛低的语言就并没有那么好辨别）。总之，一个这样的程序员会给团队带来远超他薪资的潜在回报和长远收益。</p>
<h3 id="开源"><a class="header" href="#开源">开源</a></h3>
<p>目前 Rust 的主战场是在开源上，Go 的成功也证明了农村包围城市的可行性。</p>
<ul>
<li>UI 层开发，Rust 的 WASM 发展的如火如荼，隐隐有王者风范，在 JS 的基础设施领域，Rust 也是如鱼得水，例如 <code>swc</code>、 <code>deno</code> 等。同时 <code>nextjs</code> 也是押宝 Rust，可以说 Rust 在前端的成功完全是无心插柳柳成荫。</li>
<li>基础设施层，数据库、搜索引擎、网络设施、云原生等都在出现 Rust 的身影，而且还不少。</li>
<li>系统开发，目前 Linux 已经将 Rust 列为即将支持的内核开发语言，是继 C 语言后第二门支持内核开发的语言，不过刚开始将主要支持驱动开发。</li>
<li>系统工具，现在最流行的就是用 Rust 重写之前 C、C++ 写的一票系统工具，还都获得了挺高的关注和很好的效果，例如 sd, exa, ripgrep, fd, bat 等。</li>
<li>操作系统，现在在使用 Rust 开发的操作系统有好几个，其中最有名的可能就是谷歌的 Fuchsia，Rust 在其中扮演非常重要的角色。</li>
<li>区块链，目前 Rust 和 Go 可以说各领风骚，未来 Rust 可能会一统江湖。</li>
</ul>
<p>类似的还有很多，我们就不一一列举。总之，现在有大量的项目在被用 Rust 重写，同时还有海量的项目在等待被重写，这些都是赚取 star 和认可的好机会。在其它语言杀成一片红海时，Rust 还留了一大片蓝海等待大家的探索！</p>
<h3 id="相比其他语言-rust-的优势"><a class="header" href="#相比其他语言-rust-的优势">相比其他语言 Rust 的优势</a></h3>
<p>由于篇幅有限，我们这里不会讲述详细的对比，就是简单介绍下 Rust 的优势。并不是说 Rust 就优于这些语言，大家轻喷：)</p>
<h4 id="go"><a class="header" href="#go">Go</a></h4>
<p>Rust 语言表达能力更强，性能更高。同时线程安全方面 Rust 也更强，不容易写出错误的代码。包管理 Rust 也更好，Go 虽然在 1.10 版本后提供了包管理，但是目前还比不上 Rust 的。</p>
<h4 id="c"><a class="header" href="#c">C++</a></h4>
<p>与 C++ 相比，Rust 的性能相差无几，但是在安全性方面会更优，特别是使用第三方库时，Rust 的严格要求会让第三方库的质量明显高很多。</p>
<p>语言本身的学习，Rust 的前中期学习曲线会更陡峭，但是对于未来使用场景和生态的学习，C++ 会更难，更复杂。</p>
<h4 id="java"><a class="header" href="#java">Java</a></h4>
<p>除了极少部分纯粹的数字计算性能，Rust 的性能是全面领先于 Java 的。同时 Rust 占用内存小的多，因此实现同等规模的服务，Rust 所需的硬件成本会显著降低。</p>
<h4 id="python"><a class="header" href="#python">Python</a></h4>
<p>性能自然是 Rust 完胜，同时 Rust 对运行环境要求较低，这两点差不多就足够抉择了。不过 Python 和 Rust 的彼此适用面其实也不太冲突。</p>
<h3 id="使用现状"><a class="header" href="#使用现状">使用现状</a></h3>
<ul>
<li>AWS 从 2017 年开始就用 Rust 实现了无服务器计算平台： AWS Lambda 和 AWS Fargate，并且用 Rust 重写了 Bottlerocket OS 和 AWS Nitro 系统，这两个是弹性计算云 (EC2) 的重要服务</li>
<li>Cloudflare 是 Rust 的重度用户，DNS、无服务计算、网络包监控等基础设施都与 Rust 密不可分</li>
<li>Dropbox 的底层存储服务完全由 Rust 重写，达到了数万 PB 的规模</li>
<li>Google 除了在安卓系统的部分模块中使用 Rust 外，还在它最新的操作系统 Fuchsia 中重度使用 Rust</li>
<li>Facebook 使用 Rust 来增强自己的网页端、移动端和 API 服务的性能，同时还写了 Hack 编程语言的虚拟机</li>
<li>Microsoft 使用 Rust 为 Azure 平台提供一些组件，其中包括 IoT 的核心服务</li>
<li>Github 和 npmjs.com，使用 Rust 提供高达每天 13 亿次的 npm 包下载</li>
<li>Rust 目前已经成为全世界区块链平台的首选开发语言</li>
<li>TiDB，国内最有名的开源分布式数据库</li>
</ul>
<p>尤其值得一提的是，AWS 实际上在押宝 Rust，未来对 Rust 的使用可能很快会上升到 <strong>first-class</strong> 的地位。</p>
<h2 id="rust-语言版本更新"><a class="header" href="#rust-语言版本更新">Rust 语言版本更新</a></h2>
<p>与其它语言相比，Rust 的更新迭代较为频繁（得益于精心设计过的发布流程以及 Rust 语言开发者团队的严格管理）：</p>
<ul>
<li>每 6 周发布一个迭代版本</li>
<li>2-3 年发布一个新的大版本：Rust 2018 edition，Rust 2021 edtion</li>
</ul>
<p>好处在于，可以满足不同的用户群体的需求：</p>
<ul>
<li>对于活跃的 Rust 用户，他们总是能很快获取到新的语言内容，毕竟，尝鲜是技术爱好者的共同特点：)</li>
<li>对于一般的用户，edition 大版本的发布会告诉他们：Rust 语言相比上次大版本发布，有了重大的改进，值得一看</li>
<li>对于 Rust 语言开发者，可以让他们的工作成果更快的被世人所知，不必锦衣夜行</li>
</ul>
<p>好了，相信大家听了这么多 Rust 的优点，已经迫不及待想要开始学习旅程，那么容我引用一句 CS 的经典台词：Ok, Let's go.</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>连续 6 年最受欢迎的语言当然不是浪得虚名。 无 GC、效率高、工程性强、强安全性以及能同时得到工程派和学院派认可，这些令 Rust 拥有了自己的特色和生存空间。社区的友善，生态的快速发展，大公司的重仓跟进，一切的一切都在说明 Rust 的未来。</p>
<p>当然，语言毕竟只是工具，我们不能神话它，但是可以给它一个机会，也许，你最终能收获自己的真爱。：)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-语言圣经-rust-course"><a class="header" href="#rust-语言圣经-rust-course">Rust 语言圣经 (Rust course)</a></h1>
<ul>
<li>官方网址： https://course.rs</li>
<li>修订时间： <strong>尚未发行</strong></li>
<li>Rust 版本： Rust edition 2021</li>
<li>QQ 交流群：1009730433</li>
</ul>
<h3 id="教程简介"><a class="header" href="#教程简介">教程简介</a></h3>
<p><code>Rust 语言圣经</code>涵盖从<strong>入门到精通</strong>所需的全部 Rust 知识，目录及内容都经过深思熟虑的设计，同时语言生动幽默，行文流畅自如，摆脱技术书籍常有的机器味和晦涩感。</p>
<p>在 Rust 基础教学的同时，我们还提供了：</p>
<ul>
<li><strong>深入度</strong>，在基础教学的同时，提供了深入剖析，浅尝辄止并不能让我们站上紫禁之巅</li>
<li><strong>性能优化</strong>，选择 Rust，意味着就要追求性能，因此你需要体系化的了解性能优化</li>
<li><strong>专题</strong>，将 Rust 高级内容通过专题的方式一一呈现，内容内聚性极强</li>
<li><strong>难点索引</strong>，作为一本工具书，优秀的索引能力非常重要，遗忘不可怕，找不到才可怕</li>
<li><strong>场景化模版</strong>，程序员上网查询如何操作是常事，没有人能记住所有代码，场景化模版可解君忧</li>
<li><strong>开源库推荐</strong>, 根据场景推荐高质量的开源库，降低 Rust 上手门槛</li>
</ul>
<p>总之在写作过程中我们始终铭记初心：为中国用户打造一本<strong>全面的、深入的、持续更新的</strong> Rust 教程。 新手用来入门，老手用来提高，高手用来提升生产力。</p>
<h3 id="开源说明"><a class="header" href="#开源说明">开源说明</a></h3>
<p>Rust 语言圣经是<strong>完全开源</strong>的电子书，每个章节都至少用时 4-6 个小时才能初步完稿，牺牲了大量休闲娱乐，陪伴家人的时间。而且还没有任何钱赚，<strong>如果大家觉得这本书的作者真的用心了，希望你能帮我们点一个 🌟<a href="https://github.com/sunface/rust-course">star</a></strong>，感激不尽！：）</p>
<p>在开源版权上，我们选择了 <a href="https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;ved=2ahUKEwigkv-KtMT0AhXFdXAKHdI4BCcQFnoECAQQAw&amp;url=https%3A%2F%2Fchoosealicense.com%2Fno-permission%2F&amp;usg=AOvVaw3M2Q4IbdhnpJ2K71TF7SPB">No License</a>，这意味着<strong>读者可以随意的 fork 和阅读，但是不能私下修改后再包装分发。</strong></p>
<p>如果有这方面的需求，请联系我们。我们不会收钱，只是希望知道谁通过什么方式分发了这本书的部分内容，望理解。</p>
<h3 id="rust-社区"><a class="header" href="#rust-社区">Rust 社区</a></h3>
<p>与国外的 Rust 发展如火如荼相比，国内的近况不是特别理想。导致目前这种状况的原因，我个人认为有以下几点：</p>
<ol>
<li>上手难度大，学习曲线陡峭</li>
<li>英文资料难学（阅读较难的技术内容，需要精准阅读，因此对外语能力要求较高），中文资料也不太好学（内容全面度、实时性，晦涩难懂等）</li>
<li>没有体系化的学习路线，新人往往扫完一遍入门书籍，就不知道何去何从</li>
</ol>
<p>为此，我整了一本书和一个社区，欢迎大家的加入：</p>
<ul>
<li>QQ 群：1009730433</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="避免从入门到放弃"><a class="header" href="#避免从入门到放弃">避免从入门到放弃</a></h1>
<p>很多人都在学Rust ing，也有很多人在放弃 ing。想要顺利学完 Rust，大家需要谨记本文列出的内容，否则这极有可能是又又又一次从入门到放弃之旅。</p>
<p>Rust 是一门全新的语言，它会带给你前所未有的体验，提升你的通用编程水平，甚至于赋予你全新的编程思想。在此时此刻，大家可能还半信半疑，但是当学完它再回头看时，可能你也会认同这些貌似浮夸的赞美。</p>
<h2 id="避免试一试的心态"><a class="header" href="#避免试一试的心态">避免试一试的心态</a></h2>
<p>在学习Go、Python等编程语言时，你可能会一边工作，一边轻松愉快的学习它们，但是Rust不行。原因如文章开头所说，在学习Rust的同时你会收获很多语言之外的知识，因此 Rust 在入门阶段比很多编程语言要更难，但是一旦入门，你将收获一个全新的自己，成为一个更加优秀的程序员。</p>
<p>在学习过程中，一开始可能会轻松愉快，但是在开始Rust核心概念时(所有权、借用、生命周期、智能指针等)，难度可能会陡然提升，此时就需要认真对待起来，否则会为后面埋下很多难以填补的坑，结果最后你可能只有两个选择：重新学一遍 or 放弃。</p>
<p>因此，在学习过程中，给大家三点建议：</p>
<ul>
<li>要提前做好会遇到困难的准备，因为如上面所说，学习Rust不仅仅是在学习一门编程语言</li>
<li>不要抱着试一试的心态去试一试，否则是浪费时间和消耗学习的激情，作为连续六年全世界最受喜欢的语言，Rust不仅仅是值得试一试 :)</li>
<li>深入学习一本好书或教程</li>
</ul>
<p>总之, Rust 入门难，但是在你一次次克服艰难险阻的同时，也一次次收获了与众不同的编程经验，最后历经九九八十一难，立地成大佬。 给自己一个机会，也给 Rust 一个机会 ：）</p>
<h2 id="深入学习一本好书"><a class="header" href="#深入学习一本好书">深入学习一本好书</a></h2>
<p>Rust跟其它语言不一样，你无法看了一遍语法，然后就能上手写代码，对，我说的就是对比 Go 语言，后者的简单易用是有目共睹的。</p>
<p>这些年，我遇到过太多在网上看了一遍菜鸟教程(或其它简易教程)就上手写demo甚至项目的同学，无一例外，都各种碰壁、趟坑，最后要么放弃，要么回炉重造，之前的时间和精力基本等同浪费。</p>
<p>因此，大家一定要舍得投入时间，沉下心去读一本好书，这本书会带你深入浅出地学习使用Rust所需的各种知识，还会带你提前趟坑，这些坑往往是需要大量的时间才能领悟的。</p>
<p>在以前我可能会推荐看官方那本书的英文原版 + async book + nomicon这几本书的组合，但是现在有了一本更适合中国用户的书籍，那就是 <a href="https://github.com/sunface/rust-course">&lt;&lt;Rust语言圣经&gt;&gt;</a>，内容好坏大家一读即知，光就文字而言，那绝对是行云流水般的阅读体验，可以极大提升你的学习效率，也不再因为反复读也读不懂一句话而烦闷不堪。</p>
<h2 id="千万别从链表或图开始练手"><a class="header" href="#千万别从链表或图开始练手">千万别从链表或图开始练手</a></h2>
<p>CS课程中我们会学习大量的常用数据结构和算法，因此大家都养成了一种好习惯：学习一门新语言，先用它写个链表或图试试。</p>
<p>我的天，在Rust中千万别这么干，你是在扼杀自己之前的努力！因为不像其它语言，链表在Rust中简直是地狱一般的难度，我见过太多英雄好汉难过链表关，最终黯然退幕。我不希望正在阅读此文的你也成为其中一个 :（ </p>
<p>这些自引用类型的数据结构(包含了字段，该字段又引用了自身)，它们是恶魔，它们不仅仅在蹂躏着新手，还在折磨着老手，有意思的是，它们的难恰恰是Rust的优点导致的：无gc也无手动内存管理，内存安全。</p>
<p>这两点的实现并不是凭空产生的，而是通过Rust一套非常强大、优美的机制提供了支持，这些机制一旦你学到，就会被它巧妙的构思和设计而征服，进而被 Rust 深深吸引！但是一切选择都有利弊，这种机制的弊端就在于实现链表这种数据结构时，会变得非常非常复杂。</p>
<p>你需要糅合各种知识，才能解决这个问题，但是这显然不是一个新手应该独自去面对的。总之，不会链表对于Rust的学习和写项目，真的没有任何影响，直接使用大神已经写好的数据结构包就可以。</p>
<p>如果想要练手，我们可以换个方向开始，当然如果你就是喜欢征服困难，那没问题，就从链表开始。但是无论选择哪个，之前提到的那本书都会给你莫大的帮助，包括如何实现一个链表！</p>
<h2 id="仔细阅读编译错误"><a class="header" href="#仔细阅读编译错误">仔细阅读编译错误</a></h2>
<p>在一些编程语言中，你可能习惯了编译器给出的错误只要看前面(或后面)几行就行，大部分是不怎么用到的信息，总之编译器总感觉笨笨的。</p>
<p>但是 Rust 不是，它为我们提供了一个强大无比的编译器，而且会提示我们该如何修改代码以解决错误，简直就是一个优秀的老师！</p>
<p>因此在使用 Rust 过程中，如果错误你不知该如何解决，不妨仔细阅读下编译器或者IDE给出的错误提示，绝大多数时候，你都可以通过这些提示顺利的解决问题。</p>
<p>同时也不要忽略编译器给出的警告信息(warnings)，因为里面包含了 <code>cargo clippy</code> 给出的 <code>lint</code> 提示，这些提示不仅仅包含代码风格，甚至包含了一些隐藏很深的错误！至于这些错误为何不是 <code>error</code> 形式出现，随着学习的深入，你将逐渐理解 Rust 的各种设计选择，包括这个问题。</p>
<h2 id="不要强制自己使用其它编程语言的最佳实践来写rust"><a class="header" href="#不要强制自己使用其它编程语言的最佳实践来写rust">不要强制自己使用其它编程语言的最佳实践来写Rust</a></h2>
<p>大多数其它编程语言适用的最佳实践在Rust中也可以很好的使用，但是 Rust 并不是一门专门的面向对象或者函数式语言，因此在使用自己喜欢的编程风格时，也要考虑遵循 Rust 应有的实践。</p>
<p>例如纯面向对象或纯函数式编程，在 Rust 中就并不是一个很好的选择。如果你有过Go语言的编程经验，相信能更加理解我这里想表达的含义。</p>
<p>不过大家也不用担心，在书中我们以专题的形式专门讲解 Rust 的最佳实践，看完后自然就明白了。</p>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<p>对于新手而言，最应该避免的就是从<strong>链表开始练手</strong>，最应该做的就是认真仔细地学习一本优秀的书。</p>
<p>总之，认真学 Rust，既然选择了，就相信自己，你的前方会是星辰大海！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="寻找牛刀以便小试"><a class="header" href="#寻找牛刀以便小试">寻找牛刀，以便小试</a></h1>
<p>其实对于写这种章节，我内心是拒绝的，因为真的很无趣。对于一本书而言，这也更像是一种浪费纸张的行为（好在咱无纸化：-D)。不过没有办法，如果不安装 Rust 环境，总不能让大家用空气运行吧，so，我恶趣味的起了一个这样的章节名。</p>
<p>在本章中，你将学习以下内容：</p>
<ol>
<li>在 MacOS、Linux、Windows 上安装 Rust 以及相关工具链</li>
<li>搭建 VSCode 所需的环境</li>
<li>简单介绍 Cargo</li>
<li>实现一个酷炫多国语言版本的“世界，你好”的程序，并且谈谈对 Rust 语言的初印象</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装-rust"><a class="header" href="#安装-rust">安装 Rust</a></h1>
<p><code>rustup</code> 是 Rust 的安装程序，也是它的版本管理程序。
强烈建议使用 <code>rustup</code> 来安装 Rust，当然如果你有异心，请寻找其它安装方式，然后再从下一节开始阅读。</p>
<blockquote>
<p>haha，开个玩笑。读者乃大大，怎么能弃之不顾。</p>
<p>注意：如果你不想用或者不能用 rustup，请参见 <a href="https://forge.rust-lang.org/infra/other-installation-methods.html#other-rust-installation-methods">Rust 其它安装方法</a></p>
</blockquote>
<p>至于版本，现在 Rust 稳定版特性越来越全了，因此下载最新稳定版本即可。由于你用的 Rust 版本可能跟本书写作时不一样，一些编译错误和警告可能也会有所不同。</p>
<h2 id="在-linux-或-macos-上安装-rustup"><a class="header" href="#在-linux-或-macos-上安装-rustup">在 Linux 或 MacOS 上安装 <code>rustup</code></a></h2>
<p>打开终端并输入下面命令：</p>
<pre><code class="language-console">curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>这个命令将下载一个脚本并开始安装 <code>rustup</code> 工具，此工具将安装 Rust 的最新稳定版本。可能会提示你输入管理员密码。</p>
<p>如果安装成功，将出现下面这行：</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>OK，这样就已经完成 Rust 安装啦。</p>
<h3 id="安装-c-语言编译器非必需"><a class="header" href="#安装-c-语言编译器非必需">安装 C 语言编译器：（非必需）</a></h3>
<p>Rust 对运行环境的依赖和 Go 语言很像，几乎所有环境都可以无需安装任何依赖直接运行。但是，Rust 会依赖 <code>libc</code> 和链接器 <code>linker</code>。所以如果遇到了提示链接器无法执行的错误，你需要再手动安装一个 C 语言编译器：</p>
<p><strong>MacOS 下：</strong></p>
<pre><code class="language-console">xcode-select --install
</code></pre>
<p><strong>Linux 下：</strong></p>
<p>Linux 用户一般应按照相应发行版的文档来安装 <code>GCC</code> 或 <code>Clang</code>。</p>
<p>例如，如果你使用 Ubuntu，则可安装 <code>build-essential</code>。</p>
<h2 id="在-windows-上安装-rustup"><a class="header" href="#在-windows-上安装-rustup">在 Windows 上安装 <code>rustup</code></a></h2>
<p>Windows 上安装 Rust 需要有 <code>C++</code> 环境，以下为安装的两种方式：</p>
<p><strong>1. <code>x86_64-pc-windows-msvc</code>（官方推荐）</strong></p>
<p>先安装 <a href="https://visualstudio.microsoft.com/zh-hans/visual-cpp-build-tools/">Microsoft C++ Build Tools</a>，安装勾选 C++ 环境即可。安装时 可自行修改缓存路径与安装路径，避免占用过多 C 盘空间。</p>
<p>准备好 C++ 环境后开始安装 Rust：</p>
<p>在 <a href="https://www.rust-lang.org/learn/get-started">RUSTUP-INIT</a> 下载系统相对应的 Rust 安装程序，一路默认即可。</p>
<pre><code class="language-shell">PS C:\Users\Hehongyuan&gt; rustup-init.exe 
......
Current installation options:

   default host triple: x86_64-pc-windows-msvc
     default toolchain: stable (default)
               profile: default
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
</code></pre>
<p><strong>2、<code>x86_64-pc-windows-gnu</code></strong></p>
<p>相比于 MSVC 版本来说，GNU 版本具有更轻量，更靠近 Linux 的优势。</p>
<p>首先，根据 <a href="https://www.msys2.org/">MSYS2 官网</a> 配置 MSYS。</p>
<p>若您觉得下载太慢，可以试试由 <a href="https://github.com/Caviar-X">Caviar-X</a> 提供的 <a href="https://github.pigeons.icu/msys2/msys2-installer/releases/download/2021-11-30/msys2-x86_64-20211130.exe">代理</a>。</p>
<p>在安装 <code>mingw-toolchain</code> 后，请将 <code>%MSYS 安装路径%\mingw64\bin</code> 添加到系统变量 <code>PATH</code> 中。</p>
<p>配置好后，在 MSYS 中输入下面的命令来安装 rustup。</p>
<pre><code class="language-bash">curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>之后，根据以下输出进行配置。</p>
<pre><code class="language-text">Current installation options:

   default host triple: x86_64-pc-windows-msvc
     default toolchain: stable (default)
               profile: default
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
&gt;2

I'm going to ask you the value of each of these installation options.
You may simply press the Enter key to leave unchanged.

Default host triple? [x86_64-pc-windows-msvc]
x86_64-pc-windows-gnu

Default toolchain? (stable/beta/nightly/none) [stable]
stable

Profile (which tools and data to install)? (minimal/default/complete) [default]
complete

Modify PATH variable? (Y/n)
Y

Current installation options:

   default host triple: x86_64-pc-windows-gnu
     default toolchain: stable
               profile: complete
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
&gt;
</code></pre>
<p>再之后，按下 1，等待。完成后，您就已经安装了 Rust 和 <code>rustup</code>。</p>
<h2 id="卸载"><a class="header" href="#卸载">卸载</a></h2>
<p>要卸载 Rust 和 <code>rustup</code>，在终端执行以下命令即可卸载：</p>
<pre><code class="language-bash">rustup self uninstall
</code></pre>
<h2 id="检查安装是否成功"><a class="header" href="#检查安装是否成功">检查安装是否成功</a></h2>
<p>检查是否正确安装了 Rust，可打开终端并输入下面这行，此时能看到最新发布的稳定版本的版本号、提交哈希值和提交日期：</p>
<pre><code class="language-bash">rustc -V
rustc 1.56.1 (59eed8a2a 2021-11-01)

cargo -V
cargo 1.57.0 (b2e52d7ca 2021-10-21)
</code></pre>
<blockquote>
<p>注：若发现版本号不同，以您的版本号为准</p>
</blockquote>
<p>恭喜，你已成功安装 Rust！如果没看到此信息，并且你使用的是 Windows，请检查 Rust 或 <code>%USERPROFILE%\.cargo\bin</code> 是否在 <code>%PATH%</code> 系统变量中。</p>
<p>如果都正确，但 Rust 仍然无法正常工作，那么你可以在很多地方获得帮助。最简单的是<strong>加入 Rust 编程学院这个大家庭，QQ 群：1009730433</strong>.</p>
<h2 id="本地文档"><a class="header" href="#本地文档">本地文档</a></h2>
<p>安装 Rust 的同时也会在本地安装一个文档服务，方便我们离线阅读：运行 <code>rustup doc</code> 让浏览器打开本地文档。</p>
<p>每当遇到标准库提供的类型或函数不知道怎么用时，都可以在 API 文档中查找到！具体参见 <a href="first-try/../std/search.html">在标准库寻找你想要的内容</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="墙推-vscode"><a class="header" href="#墙推-vscode">墙推 VSCode!</a></h2>
<p><code>VSCode</code> 从 15 年刚开始推出，我就在使用了。做为第一个吃螃蟹的人，可以说见证了它一路的快速发展，直到现在它已经成为开源世界最火的 IDE 之一（弱弱的说一句，之一也许可以去掉）。</p>
<p>顺便歪楼说一句：我预言过三件事：</p>
<ol>
<li>在 13 年预言 <code>Golang</code> 会火遍全世界。同时创建了 14-19 年最火的 Golang 隐修会社区，可惜因为某些原因被封停了，甚是遗憾。</li>
<li>在 15 年预言 <code>VSCode</code> 会成为世界上最好的 IDE；同时我还是 <code>jaeger tracing</code> 项目的第一个 star 用户（是的，比作者还早），当时就很看好这个项目的后续发展。</li>
<li>现在呢，我在这里正式预言： <strong>未来 <code>Rust</code> 会成为主流编程语言之一，在几乎所有开发领域都将大放光彩</strong>。总之牛逼已吹下，希望不要被打脸。：(</li>
</ol>
<p>下面继续简单介绍下 VSCode，以下内容引用于官网：</p>
<blockquote>
<p>Visual Studio Code(VSCode) 是微软 2015 年推出的一个轻量但功能强大的源代码编辑器，基于 Electron 开发，支持 Windows、Linux 和 MacOS 操作系统。它内置了对 JavaScript，TypeScript 和 Node.js 的支持并且具有丰富的其它语言和扩展的支持，功能超级强大。Visual Studio Code 是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义快捷键、括号匹配和颜色区分、代码片段、代码对比 Diff、GIT 命令等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。</p>
</blockquote>
<h2 id="安装-vscode-的-rust-插件"><a class="header" href="#安装-vscode-的-rust-插件">安装 VSCode 的 Rust 插件</a></h2>
<p>在 VSCode 的左侧扩展目录里，搜索 <code>rust</code>, 你能看到两个 Rust 插件，如果没有意外，这两个应该分别排名第一和第二：</p>
<ol>
<li>官方的 <code>Rust</code>，作者是 <code>The Rust Programming Language</code>, 官方出品，牛逼就完了，但是……我们并不推荐，这个插件有几个问题：</li>
</ol>
<ul>
<li>首先是在代码跳转上支持的很烂，只能在自己的代码库中跳转，一旦跳到别的三方库，那就无法继续跳转，对于查看标准库和三方库的源码带来了极大的困扰</li>
<li>其次，不支持类型自动标注，对于 Rust 语言而言，类型说明是非常重要的，特别是在你不知道给变量一个什么类型时，这种 IDE 的自动提示就变得弥足珍贵</li>
<li>代码提示不太好用，有些方法既不会提示，也不能跳转</li>
</ul>
<ol start="2">
<li>社区驱动的 <code>rust-analyzer</code>，非常推荐，上面说的所有问题，在这个插件上都得到了解决，不得不说，Rust 社区 yyds!</li>
</ol>
<p>所以，综上所述，我们选择 <code>rust-analyer</code> 作为 Rust 语言的插件，具体的安装很简单，点击插件，选择安装即可，根据提示可能需要重新加载 IDE。</p>
<blockquote>
<p>在搜索 VSCode 插件时，报错：<code>提取扩展出错，XHR failed</code>，这个报错是因为网络原因导致，很可能是你的网络不行或者翻墙工具阻拦你的访问，试着关掉翻墙，再进行尝试。</p>
</blockquote>
<p>安装完成后，在第一次打开 Rust 项目时，需要安装一些依赖，具体的状态在左下角会进行提示，包括下载、代码构建、building 等。</p>
<p>当插件使用默认设置时，每一次保存代码，都会出进行一次重新编译。</p>
<blockquote>
<p>如果你的电脑慢，有一点一定要注意：</p>
<p>在编译器构建代码的同时，不要在终端再运行 <code>cargo run</code> 等命令进行编译，不然会获得一个报错提示，大意是当前文件目录已经被锁定，等待其它使用者释放。如果等了很久 IDE 还是没有释放（虽然我没遇到过，但是存在这个可能性），你可以关掉 IDE，并手动 <code>kill</code> 掉 <code>rust-anylyzer</code>，然后重新尝试。</p>
</blockquote>
<h2 id="安装其它好用的插件"><a class="header" href="#安装其它好用的插件">安装其它好用的插件</a></h2>
<p>在此，再推荐大家几个好用的插件：</p>
<ol>
<li><code>Better TOML</code>，用于更好的展示 .toml 文件</li>
<li><code>Error Lens</code>, 更好的获得错误展示</li>
<li><code>One Dark Pro</code>, 非常好看的 VSCode 主题</li>
<li><code>CodeLLDB</code>, Debugger 程序</li>
</ol>
<p>好了，至此，VSCode 的配置就已经全部结束，是不是很简单？下面让我们来用 <code>Cargo</code> 创建一个 Rust 项目，然后用 VSCode 打开。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="认识cargo"><a class="header" href="#认识cargo">认识Cargo</a></h2>
<p>但凡经历过 C/C++、Go 语言 1.10 版本之前的用户都知道，一个好的包管理工具有多么的重要！！我那个时候是如此的渴望类似 <code>nodejs</code> 的 <code>npm </code>包管理工具，但是却求而不得，包管理工具最重要的意义就是<strong>任何用户拿到你的代码，都能运行起来</strong>&quot;，而不会因为各种包版本依赖焦头烂额，Go 语言在 1.10 版本之前，所有的包都是在 <code>github.com</code> 下存放，导致了所有的项目都公用一套依赖代码，在本地项目复杂后，这简直是一种灾难。</p>
<p>说多了都是泪，笔者目前还有一个早期 Go 的项目(15年写的)，用到了 <code>iris</code> (一个坑爹HTTP服务)，结果现在运行不起来了，因为找不到 <code>iris</code> 当时的那个版本！！</p>
<p>作为一门现代化语言，<code>Rust</code> 吸收了多个语言的包管理优点，为大家提供超级大杀器： <code>cargo</code>，真的，再挑剔的开发者，都对它赞不绝口。</p>
<p>总而言之，<code>cargo</code> 提供了一系列的工具，从项目的建立、构建到测试、运行直至部署，为 Rust 项目的管理提供尽可能完整的手段，同时，与 Rust 语言及其编译器 <code>rustc</code> 紧密结合，可以说用了后就忘不掉，如同初恋般的感觉。</p>
<h2 id="创建一个你好世界项目"><a class="header" href="#创建一个你好世界项目">创建一个&quot;你好,世界&quot;项目</a></h2>
<p>又见&quot;你好,世界&quot;，肯定有读者在批评了：你就不能有点创意吗？&quot;世界,你好&quot;难道不配？你是读者，你说了算，那我们就来创建一个&quot;世界，你好&quot;。</p>
<p>上文提到，Rust 语言的包管理工具是 <code>cargo</code>，好在，我们无需手动安装，在之前安装Rust的时候，就一并安装，如果你在终端无法使用这个命令，考虑一下 <code>环境变量</code> 是否正确的设置：把 <code>cargo</code> 可执行文件所在的目录添加到环境变量中。</p>
<p>终于到了紧张刺激的 new new new 环节:</p>
<pre><code class="language-console">$ cargo new world_hello
</code></pre>
<p>上面的命令使用 <code>cargo new</code> 创建一个项目，项目名是 <code>world_hello</code> (向读者势力低头的项目名称，泪奔)，该项目的结构和配置文件都是由 <code>cargo</code> 生成，意味着<strong>我们的项目被 <code>cargo</code> 所管理</strong>。</p>
<p>早期的 <code>cargo</code> 在创建项目时，必须添加 <code>--bin</code> 的参数，如下所示：</p>
<pre><code class="language-console">$ cargo new world_hello --bin
</code></pre>
<p>现在的版本，已经无需此参数，<code>cargo</code> 默认就创建 <code>bin</code> 类型的项目，顺便说一句，Rust 项目主要分为两个类型：<code>bin</code> 和 <code>lib</code>，前者是一个可运行的项目，后者是一个依赖库项目。</p>
<p>下面来看看创建的项目结构：</p>
<pre><code class="language-console">.
├── .git
├── .gitignore
├── Cargo.toml
└── src
    └── main.rs

</code></pre>
<p>是的，连 <code>git</code> 都给你创建了，不仅令人感叹，不是女儿，胜似女儿，比小棉袄还体贴。</p>
<h2 id="运行项目"><a class="header" href="#运行项目">运行项目</a></h2>
<p>有两种方式可以运行项目，先来看看第一种.</p>
<h4 id="cargo-run"><a class="header" href="#cargo-run">cargo run</a></h4>
<p>一码胜似千言:</p>
<pre><code class="language-console">$ cargo run
   Compiling world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/world_hello`
Hello, world!
</code></pre>
<p>好了，你已经看到程序的输出: <code>&quot;Hello, world&quot;</code>, 可能有读者不愿意了，说好了&quot;世界，你好&quot;呢? 别急，在下一节，我们再对代码进行修改。认真想来，&quot;你好，世界&quot;强调的是我对世界说你好，而&quot;世界,你好&quot;是世界对我说你好，明显是后者更有包容性和国际范儿，读者真·好眼光。</p>
<p>上述代码，<code>cargo run</code> 首先对项目进行编译，然后再运行，因此它实际上等同于运行了两个指令，如同我们下面将做的：</p>
<h4 id="手动编译和运行项目"><a class="header" href="#手动编译和运行项目">手动编译和运行项目</a></h4>
<p>编译</p>
<pre><code class="language-console">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
</code></pre>
<p>运行</p>
<pre><code class="language-console">$ ./target/debug/world_hello 
Hello, world!
</code></pre>
<p>行云流水，但谈不上一气呵成。 细心的读者可能已经发现，在调用的时候，路径 <code>./target/debug/world_hello</code> 中有一个明晃晃的 <code>debug</code> 字段，没错我们运行的是 <code>debug</code> 模式，在这种模式下，<strong>代码的编译速度会非常快</strong>，可是福兮祸所依，<strong>运行速度就慢了</strong>. 原因是，在 <code>debug</code> 模式下，Rust 编译器不会做任何的优化，只为了尽快的编译完成，让你的开发流程更加顺畅。</p>
<p>作为尊贵的读者，咱自然可以要求更多，比如你想要高性能的代码怎么办？ 简单，添加 <code>--release</code> 来编译：</p>
<ul>
<li><code>cargo run --release</code></li>
<li><code>cargo build --release</code></li>
</ul>
<p>运行我们的高性能 <code>relese</code> 程序：</p>
<pre><code class="language-console">$ ./target/release/world_hello 
Hello, world!
</code></pre>
<h2 id="cargo-check"><a class="header" href="#cargo-check">cargo check</a></h2>
<p>当项目大了后，<code>cargo run</code> 和 <code>cargo build</code> 不可避免的会变慢，那么有没有更快的方式来验证代码的正确性呢？大杀器来了，接着！</p>
<p><code>cargo check</code> 是我们在代码开发过程中最常用的命令，它的作用很简单：快速的检查一下代码能否编译通过。因此该命令速度会非常快，能节省大量的编译时间。</p>
<pre><code class="language-console">$ cargo check
    Checking world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.06s
</code></pre>
<blockquote>
<p>Rust 虽然编译速度还行，但是还是不能 Go 语言相提并论，因为 Rust 需要做很多复杂的编译优化和语言特性解析, 甚至连如何优化编译速度都成了一门学问：<a href="first-try/../compiler/speed-up.html">优化编译速度</a></p>
</blockquote>
<h2 id="cargotoml-和-cargolock"><a class="header" href="#cargotoml-和-cargolock">Cargo.toml 和 Cargo.lock</a></h2>
<p><code>Cargo.toml</code> 和 <code>Cargo.lock</code> 是 <code>cargo</code> 的核心文件，它的所有活动均基于此二者。</p>
<p><code>Cargo.toml</code> 是 <code>cargo</code> 特有的项目数据描述文件，存储了项目的所有元配置信息，如果 Rust 开发者希望 Rust 项目能够按照期望的方式进行构建、测试和运行，那么，必须按照合理的方式构建 <code>Cargo.toml</code>。</p>
<p><code>Cargo.lock</code> 文件是 <code>cargo</code> 工具根据同一项目的 <code>toml</code> 文件生成的项目依赖详细清单，因此我们一般不用修改它，只需要对着 <code>Cargo.toml</code> 文件撸就行了。</p>
<blockquote>
<p>什么情况下该把 <code>Cargo.lock</code> 上传到 git仓库里？很简单，当你的项目是一个可运行的程序时，就上传 <code>Cargo.lock</code>，如果是一个依赖库项目，那么请把它添加到 <code>.gitignore</code> 中</p>
</blockquote>
<p>现在用 VSCode 打开上面创建的&quot;世界，你好&quot;项目，然后进入根目录的 <code>Cargo.toml</code> 文件，该文件包含不少信息。</p>
<h4 id="package配置段落"><a class="header" href="#package配置段落">package配置段落</a></h4>
<p><code>package</code> 中记录了项目的描述信息，典型的如下：</p>
<pre><code class="language-toml">[package]
name = &quot;world_hello&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
</code></pre>
<p><code>name</code> 字段定义了项目名称，<code>version</code> 字段定义当前版本，新项目默认是 <code>0.1.0</code>，<code>edition</code> 字段定义了我们使用的 Rust 大版本，因为本书很新(不仅仅是现在新，未来也将及时修订，跟得上 Rust 的小步伐)，所以使用的是 <code>Rust edition 2021</code> 大版本，详情见<a href="first-try/../appendix/rust-version.html">Rust版本详解</a>.</p>
<h4 id="定义项目依赖"><a class="header" href="#定义项目依赖">定义项目依赖</a></h4>
<p>使用 <code>cargo</code> 工具的最大优势就在于，能够对该项目的各种依赖项进行方便、统一和灵活的管理。在 <code>Cargo.toml</code> 中，主要通过各种依赖段落来描述该项目的各种依赖项:</p>
<ul>
<li>基于 Rust 官方仓库 <code>crates.io</code>，通过版本说明来描述</li>
<li>基于项目源代码的 git仓库地址，通过 URL 来描述</li>
<li>基于本地项目的绝对路径或者相对路径，通过类Unix模式的路径来描述 </li>
</ul>
<p>这三种形式具体写法如下：</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.3&quot;
hammer = { version = &quot;0.5.0&quot;}
color = { git = &quot;https://github.com/bjz/color-rs&quot; }
geometry = { path = &quot;crates/geometry&quot; }
</code></pre>
<p>相信聪明的读者已经能看懂该如何引入外部依赖库，这里就不再赘述。</p>
<p>详细的说明参见此章：<a href="first-try/../cargo/dependency.html">Cargo依赖管理</a>，但是不建议大家现在去看，只要按照目录浏览，拨云见雾只可待。</p>
<h2 id="基于cargo的项目组织结构"><a class="header" href="#基于cargo的项目组织结构">基于cargo的项目组织结构</a></h2>
<p>前文有提到 <code>cargo</code> 默认生成的项目结构，但是真实的项目还有所不同，但是在目前的学习阶段，还无需关注，感兴趣的同学可以移步：<a href="first-try/../cargo/layout.html">Cargo项目结构</a></p>
<p>至此，大家对 Rust 项目的创建和管理已经有了初步的了解，那么来完善刚才的 <code>&quot;世界,你好&quot;</code> 项目吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="不仅仅是hello-world"><a class="header" href="#不仅仅是hello-world">不仅仅是Hello world</a></h1>
<p>几乎所有教程中安装的最后一个环节都是 <code>hello world</code>，我们也不能免俗，但是在 <code>hello world</code> 之后，还有一个相亲，阿呸，Rust 初印象环节，希望大家喜欢。</p>
<h2 id="多国语言的世界你好"><a class="header" href="#多国语言的世界你好">多国语言的&quot;世界，你好&quot;</a></h2>
<p>还记得大明湖畔等你的 <a href="first-try/./editor.html">VSCode</a> IDE 和通过 <code>Cargo</code> 创建的<a href="first-try/./cargo.html">世界，你好</a>工程嘛? </p>
<p>现在使用 VSCode 打开<a href="first-try/./cargo.html">上一节</a>中创建的 <code>world_hello</code> 工程, 然后进入 <code>main.rs</code> 文件，此文件是当前 Rust 工程的入口文件，和其它语言几无区别。</p>
<p>接下来，对世界友人给予热切的问候：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn greet_world() {
     let southern_germany = &quot;Grüß Gott!&quot;;
     let chinese = &quot;世界，你好&quot;;
     let english = &quot;World, hello&quot;;
     let regions = [southern_germany, chinese, english];
     for region in regions.iter() {
             println!(&quot;{}&quot;, &amp;region);
     }
 }
 
 fn main() {
     greet_world();
 }
</code></pre></pre>
<p>打开终端，进入 <code>world_hello</code> 工程根目录，运行该程序(你也可以在 VSCode 中打开终端,方法是点击左下角的错误和警告图标)，你的热情，好像一把火，燃烧了整个世界：</p>
<pre><code class="language-console">$ cargo run
   Compiling world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.21s
     Running `target/debug/world_hello`
Grüß Gott!
世界，你好
World, hello
sunfei@sunfeideMa
</code></pre>
<p>花点时间来看看上面的代码，首先，Rust 原生支持 UTF-8 编码的字符串，这意味着你可以很容易的使用世界各国文字作为字符串内容。</p>
<p>其次，关注下 <code>println</code> 后面的 <code>!</code>，如果你有 Ruby 编程经验，那么你可能会认为这是解构操作符，但是在 Rust 中，这是 <code>宏</code> 操作符，你目前可以认为宏是一种特殊类型函数。</p>
<p>对于 <code>println</code> 来说，我们没有使用其它语言惯用的 <code>%s</code>,<code>%d</code> 来做输出占位符，而是使用 <code>{}</code>，因为 Rust 在底层帮我们做了大量工作，会自动识别输出数据的类型，例如当前例子，会识别为 <code>String</code> 类型。</p>
<p>最后，和其它语言不同，Rust 的集合类型不能直接进行循环，需要变成迭代器(这里是通过 <code>.iter()</code> 方法)，才能用于迭代循环，在目前来看，你会觉得这一点好像挺麻烦，不急，以后就知道这么做的好处所在。实际上这段代码可以简写，在 2021 edition 及以后, 支持直接写 <code>for region in regions</code>，原因会在迭代器章节的开头提到，是因为 for 隐式地将 regions 转换成迭代器。</p>
<p>至于函数声明、调用、数组的使用，和其它语言没什么区别，So Easy！</p>
<h2 id="rust语言初印象"><a class="header" href="#rust语言初印象">Rust语言初印象</a></h2>
<p>Rust 这门语言对于 Haskell 和 Java 开发来说，会觉得很熟悉，因为它们在高阶表达方面都很优秀，简而言之，可以很简洁的写出原本需要一大堆代码才能表达的含义，但是 Rust 又有所不同：它的性能是底层语言级别的性能，可以跟 C/C++ 相媲美。</p>
<p>上一句的 <code>So Easy</code> 的余音仍在绕梁，我希望它能继续下去，可是……人总是要面对现实，因此让我们来些狠的: </p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let penguin_data = &quot;\
   common name,length (cm)
   Little penguin,33
   Yellow-eyed penguin,65
   Fiordland penguin,60
   Invalid,data
   &quot;;
 
   let records = penguin_data.lines();
 
   for (i, record) in records.enumerate() {
     if i == 0 || record.trim().len() == 0 {
       continue;
     }
     
     // 声明一个fields变量，类型是Vec
     // Vec是vector的缩写，是一个可伸缩的集合类型，可以认为是一个动态数组
     // &lt;_&gt;表示Vec中的元素类型由编译器自行推断，在很多场景下，都会帮我们省却不少功夫
     let fields: Vec&lt;_&gt; = record
       .split(',')
       .map(|field| field.trim())
       .collect();
     if cfg!(debug_assertions) {
         // 输出到标准错误输出
       eprintln!(&quot;debug: {:?} -&gt; {:?}&quot;,
              record, fields);
     }
 
     let name = fields[0];
     // 1. 尝试把fields[1]的值转换为f32类型的浮点数，如果成功，则把f32值赋给length变量
     // 2. if let是一个匹配表达式，用来从=右边的结果中，匹配出length的值:
     // 当=右边的表达式执行成功，则会返回一个Ok(f32)的类型，若失败，则会返回一个Err(e)类型，if let的作用就是仅匹配Ok也就是成功的情
     // 况,如果是错误，就直接忽略，同时if let还会做一次解构匹配，通过Ok(length)去匹配右边的Ok(f32)，最终把相应的f32值赋给length
     // 3. 当然你也可以忽视成功的情况，用if let Err(e) = fields[1].parse::&lt;f32&gt;() {...}匹配出错误，然后打印出来，但是没啥卵用
     if let Ok(length) = fields[1].parse::&lt;f32&gt;() {
         // 输出到标准输出
         println!(&quot;{}, {}cm&quot;, name, length);
     }
   }
 }
</code></pre></pre>
<p>看完这段代码，不知道你的余音有没有嘎然而止，反正我已经在颤抖了，这就是传说中的下马威嘛？上面代码中值得注意的 Rust 特性有：</p>
<ul>
<li>控制流：<code>for</code> 和 <code>continue</code> 在一起，实现的循环</li>
<li>方法语法：由于 Rust 没有继承，因此 Rust 不是传统意义上的面向对象语言，但是它却从 <code>OO</code> 语言那里偷师了方法的使用 <code>record.trim()</code>，<code>record.split(',')</code> 等</li>
<li>高阶函数编程：函数可以作为参数也能作为返回值，例如 <code>.map(|field| field.trim())</code>，这里 <code>map</code> 使用闭包函数作为参数，也可以称呼为 <code>匿名函数</code>、<code>lambda函数</code></li>
<li>类型标注：<code>if let Ok(length) = fields[1].parse::&lt;f32&gt;()</code>, 通过 <code>::&lt;f32&gt;</code> 的使用，告诉编译器 <code>length</code> 是一个 <code>f32</code> 类型的浮点数，这种类型标注不是很常用，但是在编译器无法推断出你的数据类型时，就很有用了</li>
<li>条件编译：<code>if cfg!(debug_assertions)</code>，说明紧跟其后的输出打印只在 <code>debug</code> 模式下生效</li>
<li>隐式返回：Rust 提供了 <code>return</code> 关键字用于函数返回，但是在很多时候，我们可以省略它。因为 Rust 是<a href="first-try/../basic/base-type/statement-expression.html"><strong>基于表达式的语言</strong></a></li>
</ul>
<p>在终端运行上述代码时，会看到很多 <code>debug: ...</code> 的输出, 上面有讲，这些都是 <code>条件编译</code> 的输出, 那么该怎么消除掉这些输出呢？</p>
<p>读者大大普遍冰雪聪明，肯定已经想到：是的，在<a href="first-try/./cargo.html#%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE">认识Cargo</a>中，曾经介绍过 <code>--release</code> 参数，因为 <code>cargo run</code> 默认是运行 <code>debug</code> 模式. 因此想要消灭那些 <code>debug:</code> 输出，需要更改为其它模式，其中最常用的模式就是 <code>--release</code> 也就是生产发布的模式。</p>
<p>具体运行代码就不给了，留给大家作为一个小练习，建议亲自动手尝试下。</p>
<p>至此，Rust 安装入门就已经结束，相信看到这里，你已经发现了本书与其它书的区别，其中最大的区别就是：<strong>这本书就像优秀的国外课本一样，不太枯燥，也希望这本不太枯燥的书，能伴你长行，犹如一杯奶茶，细细品之，唇齿余香</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-基本概念"><a class="header" href="#rust-基本概念">Rust 基本概念</a></h1>
<p>从现在开始，我们正式踏入了 Rust 大陆，这篇广袤而神秘的世界，在这个世界中，将接触到很多之前都没有听过的概念：</p>
<ul>
<li>所有权、借用、生命周期</li>
<li>宏编程</li>
<li>模式匹配</li>
</ul>
<p>类似的还有很多，不过不用怕，引用武林外传一句话：咱上面有人。有本书在，一切虚妄终将烟消云散。</p>
<p>本章主要介绍 Rust 的基础语法、数据类型、项目结构等，学完本章，你将对 Rust 代码有一个清晰、完整的认识。</p>
<p>开始之前先通过一段代码来简单浏览下 Rust 的语法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">// Rust 程序入口函数，跟其它语言一样，都是 main，该函数目前无返回值
fn main() {
   // 使用let来声明变量，进行绑定，a是不可变的
   // 此处没有指定a的类型，编译器会默认根据a的值为a推断类型：i32，有符号32位整数
   // 语句的末尾必须以分号结尾
   let a = 10;
   // 主动指定b的类型为i32
   let b: i32 = 20;
   // 这里有两点值得注意：
   // 1. 可以在数值中带上类型:30i32表示数值是30，类型是i32
   // 2. c是可变的，mut是mutable的缩写
   let mut c = 30i32;
   // 还能在数值和类型中间添加一个下划线，让可读性更好
   let d = 30_i32;
   // 跟其它语言一样，可以使用一个函数的返回值来作为另一个函数的参数
   let e = add(add(a, b), add(c, d));
    
   // println!是宏调用，看起来像是函数但是它返回的是宏定义的代码块
   // 该函数将指定的格式化字符串输出到标准输出中(控制台)
   // {}是占位符，在具体执行过程中，会把e的值代入进来
   println!(&quot;( a + b ) + ( c + d ) = {}&quot;, e);
 }
 
 // 定义一个函数，输入两个i32类型的32位有符号整数，返回它们的和
 fn add(i: i32, j: i32) -&gt; i32 {
   // 返回相加值，这里可以省略return
   i + j
 }
</code></pre></pre>
<blockquote>
<p>注意
在上面的 <code>add</code> 函数中，不要为 <code>i+j</code> 添加 <code>;</code>，这会改变语法导致函数返回 <code>()</code> 而不是 <code>i32</code>，具体参见<a href="basic/./base-type/statement-expression.html">语句和表达式</a></p>
</blockquote>
<p>有几点可以留意下：</p>
<ul>
<li>字符串使用双引号 <code>&quot;&quot;</code> 而不是单引号 <code>''</code>，Rust 中单引号是留给单个字符类型（<code>char</code>）使用的</li>
<li>Rust 使用 <code>{}</code> 来作为格式化输出占位符，其它语言可能使用的是 <code>%s</code>，<code>%d</code>，<code>%p</code> 等，由于 <code>println!</code> 会自动推导出具体的类型, 因此无需手动指定</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量绑定与解构"><a class="header" href="#变量绑定与解构">变量绑定与解构</a></h1>
<p>鉴于本书的目标读者(别慌，来到这里就说明你就是目标读者)已经熟练掌握其它任意一门编程语言，因此这里就不再对何为变量进行赘述，让我们开门见山来谈谈，为何 Rust 选择了手动设定变量的可变性。</p>
<h2 id="为何要手动设置变量的可变性"><a class="header" href="#为何要手动设置变量的可变性">为何要手动设置变量的可变性？</a></h2>
<p>在其它大多数语言中，变量一旦创建，要么是可变的，要么是不可变的(ClosureScript)，前者为编程提供了灵活性，后者为编程提供了安全性，而 Rust 比较野，选择了两者我都要，既要灵活性又要安全性。</p>
<p>能想要学习 Rust，说明我们的读者都是相当有水平的程序员了，你们应该能理解<strong>一切选择皆是权衡</strong>，那么两者都要的权衡是什么呢？这就是 Rust 开发团队为我们做出的贡献，两者都要意味着 Rust 语言底层代码的实现复杂度大幅提升，因此 Respect to The Rust Team!</p>
<p>除了以上两个优点，还有一个很大的优点，那就是运行性能上的提升，因为将本身无需改变的变量声明为不可变在运行期会避免一些多余的 <code>runtime</code> 检查。</p>
<h2 id="变量命名"><a class="header" href="#变量命名">变量命名</a></h2>
<p>在命名方面，和其它语言没有区别，不过当给变量命名时，需要遵循<a href="basic/../practice/style-guide/naming.html">Rust命名规范</a>。</p>
<blockquote>
<p>Rust 语言有一些<strong>关键字</strong>（<em>keywords</em>），和其他语言一样，这些关键字都是被保留给 Rust 语言使用的，因此，它们不能被用作变量或函数的名称。在<a href="basic/../appendix/keywords">附录 A</a> 中可找到关键字列表。</p>
</blockquote>
<h2 id="变量绑定"><a class="header" href="#变量绑定">变量绑定</a></h2>
<p>在其它语言中，我们用 <code>var a = &quot;hello world&quot;</code> 的方式给 <code>a</code> 赋值，也就是把等式右边的 <code>&quot;hello world&quot;</code> 字符串赋值给变量 <code>a</code> ，而在 Rust 中，我们这样写： <code>let a = &quot;hello world&quot;</code> ，同时给这个过程起了另一个名字：<strong>变量绑定</strong>。</p>
<p>为何不用赋值而用绑定呢(其实你也可以称之为赋值，但是绑定的含义更清晰准确)？这里就涉及 Rust 最核心的原则——<strong>所有权</strong>，简单来讲，任何内存对象都是有主人的，而且一般情况下完全属于它的主人，绑定就是把这个对象绑定给一个变量，让这个变量成为它的主人(聪明的读者应该能猜到，在这种情况下，该对象之前的主人就会丧失对该对象的所有权)，像极了我们的现实世界，不是吗？</p>
<p>至于为何要采用所有权这种复杂的东东，先别急，等时机合适，我们会为你详细道来。</p>
<h2 id="变量可变性"><a class="header" href="#变量可变性">变量可变性</a></h2>
<p>Rust 的变量在默认情况下是<strong>不可变的</strong>。在上文提到过，这是 Rust 团队为我们精心设计的语言特性之一，这样可以让我们编写更安全、更高性能的代码。当然你可以通过 <code>mut</code> 关键字让变量变为<strong>可变的</strong>，以实现更加灵活的设计。</p>
<p>当变量不可变时，这意味着一旦一个值绑定到一个变量 <code>a</code> 后，就不能再更改 <code>a</code> 的值了。为了说明，在我们的工程目录下使用 <code>cargo new variables</code> 来创建一个名为 <em>variables</em> 的新项目。</p>
<p>然后在新建的 <em>variables</em> 目录下，打开 <em>src/main.rs</em> 并将代码替换为下面还未能通过编译的代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>保存文件，并使用 <code>cargo run</code> 运行程序，你将会收到一条错误消息，输出如下所示：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!(&quot;The value of x is: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error
</code></pre>
<p>具体的错误原因是 <code>cannot assign twice to immutable variable x</code>（对不可变的变量无法进行二次再赋值），因为我们尝试给不可变的 <code>x</code> 变量赋予第二个值。</p>
<p>这种错误是为了避免无法预期的错误发生在我们的变量上：一个变量往往被多处代码所使用，其中一部分代码假定该变量的值永远不会改变，而另外一部分代码却无情的改变了这个值，在实际开发过程中，这个错误是很难被发现的，特别是在多线程编程中。</p>
<p>这种规则让我们的代码变得非常清晰，只有你想让你的变量改变时，它才能改变，这样就不会造成心智上的负担，也给别人阅读代码带来便利。</p>
<p>但是可变性也非常重要，否则我们就要像 ClosureScript 那样，每次要改变，就要重新生成一个对象，在拥有大量对象的场景，性能会变得非常低下，内存拷贝的成本异常的高。</p>
<p>在 Rust 中，可变性很简单，只要在变量名前加一个 <code>mut</code> 即可, 而且这种显式的声明方式还会给后来人传达这样的信息：嗯，这个变量在后面代码部分会发生改变。</p>
<p>为了让变量声明为可变,将 <em>src/main.rs</em> 改为以下内容：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>运行程序将得到下面结果：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p>选择可变还是不可变，更多的还是取决于你的使用场景，例如不可变可以带来安全性，但是丧失了灵活性和性能(如果你要改变，就要重新创建一个新的变量，这里涉及到内存对象的再分配)。而可变变量最大的好处就是使用上的灵活性和性能上的提升。</p>
<p>例如，在使用大型数据结构或者热点代码路径(被大量频繁调用)的情形下，在同一内存位置更新实例可能比复制并返回新分配的实例要更快。使用较小的数据结构时，通常创建新的实例并以更具函数式的风格来编写程序，可能会更容易理解，所以值得以较低的性能开销来确保代码清晰。</p>
<h3 id="变量解构"><a class="header" href="#变量解构">变量解构</a></h3>
<p><code>let</code> 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,不可变; b = false，可变
    println!(&quot;a = {:?}, b = {:?}&quot;, a, b);

    b = true;
    assert_eq!(a, b);
}
</code></pre></pre>
<h3 id="变量和常量之间的差异"><a class="header" href="#变量和常量之间的差异">变量和常量之间的差异</a></h3>
<p>变量的值不能更改可能让你想起其他另一个很多语言都有的编程概念：<strong>常量</strong>（<em>constant</em>）。与不可变变量一样，常量也是绑定到一个常量名且不允许更改的值，但是常量和变量之间存在一些差异：</p>
<ul>
<li>常量不允许使用 <code>mut</code>。<strong>常量不仅仅默认不可变，而且自始至终不可变</strong>。</li>
<li>常量使用 <code>const</code> 关键字而不是 <code>let</code> 关键字来声明，并且值的类型<strong>必须</strong>标注。</li>
</ul>
<p>我们将在下一节<a href="basic/./base-type/index.html">数据类型</a>中介绍，因此现在暂时无需关心细节。</p>
<p>下面是一个常量声明的例子，其常量名为 <code>MAX_POINTS</code>，值设置为 <code>100,000</code>。（Rust 常量的命名约定是全部字母都使用大写，并使用下划线分隔单词，另外对数字字面量可插入下划线以提高可读性）：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_POINTS: u32 = 100_000;
<span class="boring">}
</span></code></pre></pre>
<p>常量可以在任意作用域内声明，包括全局作用域，在声明的作用域内，常量在程序运行的整个过程中都有效。对于需要在多处代码共享一个不可变的值时非常有用，例如游戏中允许玩家赚取的最大点数或光速。</p>
<blockquote>
<p>在实际使用中，最好将程序中用到的硬编码值都声明为常量，对于代码后续的维护有莫大的帮助。如果将来需要更改硬编码的值，你也只需要在代码中更改一处即可。</p>
</blockquote>
<h3 id="变量遮蔽shadowing"><a class="header" href="#变量遮蔽shadowing">变量遮蔽(shadowing)</a></h3>
<p>Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的，如下所示：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;
    // 在main函数的作用域内对之前的x进行遮蔽
    let x = x + 1;

    {
        // 在当前的花括号作用域内，对之前的x进行遮蔽
        let x = x * 2;
        println!(&quot;The value of x in the inner scope is: {}&quot;, x);
    }

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>这个程序首先将数值 <code>5</code> 绑定到 <code>x</code>，然后通过重复使用 <code>let x =</code> 来遮蔽之前的 <code>x</code>，并取原来的值加上 <code>1</code>，所以 <code>x</code> 的值变成了 <code>6</code>。第三个 <code>let</code> 语句同样遮蔽前面的 <code>x</code>，取之前的值并乘上 <code>2</code>，得到的 <code>x</code> 最终值为 <code>12</code>。当运行此程序，将输出以下内容：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
   ...
The value of x in the inner scope is: 12
The value of x is: 6
</code></pre>
<p>这和 <code>mut</code> 变量的使用是不同的，第二个 <code>let</code> 生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配
，而 <code>mut</code> 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。</p>
<p>变量遮蔽的用处在于，如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。</p>
<p>例如，假设有一个程序要统计一个空格字符串的空格数量：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 字符串类型
let spaces = &quot;   &quot;;
// usize数值类型
let spaces = spaces.len();
<span class="boring">}
</span></code></pre></pre>
<p>这种结构是允许的，因为第一个 <code>spaces</code> 变量是一个字符串类型，第二个 <code>spaces</code> 变量是一个全新的变量且和第一个具有相同的变量名，且是一个数值类型。所以变量遮蔽可以帮我们节省些脑细胞，不用去想如 <code>spaces_str</code> 和 <code>spaces_num</code> 此类的变量名；相反我们可以重复使用更简单的 <code>spaces</code> 变量名。如果你不用 <code>let</code> :</p>
<pre><pre class="playground"><code class="language-rust  edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut spaces = &quot;   &quot;;
spaces = spaces.len();
<span class="boring">}
</span></code></pre></pre>
<p>运行一下，你就会发现编译器报错：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

error: aborting due to previous error
</code></pre>
<p>显然，Rust 对类型的要求很严格，不允许将整数类型 <code>usize</code> 赋值给字符串类型。<code>usize</code> 是一种 CPU 相关的整数类型，在<a href="basic/./base-type/numbers#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B">数值类型</a>中有详细介绍。</p>
<p>万事开头难，到目前为止，都进展很顺利，那下面开始，咱们正式进入 Rust 的类型世界，看看有哪些挑战在前面等着大家。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本类型"><a class="header" href="#基本类型">基本类型</a></h1>
<p>当一门语言不谈类型时，你得小心，这大概率是动态语言(别拍我，我承认是废话)。但是把类型大张旗鼓的用多个章节去讲的，Rust 是其中之一。</p>
<p>Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，由以下组成：</p>
<ul>
<li>数值类型: 有符号整数 (<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>)、 无符号整数 (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>) 、浮点数 (<code>f32</code>, <code>f64</code>)、以及有理数、复数</li>
<li>字符串：字符串字面量和字符串切片 <code>&amp;str</code></li>
<li>布尔类型： <code>true</code>和<code>false</code></li>
<li>字符类型: 表示单个Unicode字符，存储为4个字节</li>
<li>元类型: 即 <code>()</code> ，其唯一的值也是 <code>()</code></li>
</ul>
<h2 id="类型推导与标注"><a class="header" href="#类型推导与标注">类型推导与标注</a></h2>
<p>与 <code>Python</code>、 <code>Javascript</code> 等动态语言不同，Rust 是一门静态类型语言，也就是编译器必须在编译期知道我们所有变量的类型，但这不意味着你需要为每个变量指定类型，因为<strong>Rust 编译器很聪明，它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型</strong>，同时编译器也不够聪明，在某些情况下，它无法推导出变量类型，需要手动去给予一个类型标注，关于这一点在<a href="basic/base-type/../../first-try/hello-world.html#Rust%E8%AF%AD%E8%A8%80%E5%88%9D%E5%8D%B0%E8%B1%A1">Rust语言初印象</a>中有过展示。</p>
<p>来看段代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>先忽略 <code>.parse().expect..</code> 部分，这段代码的目的是将字符串 <code>&quot;42&quot;</code> 进行解析，而编译器在这里无法推导出我们想要的类型：整数？浮点数？字符串？因此编译器会报错：</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^ consider giving `guess` a type
</code></pre>
<p>因此我们需要提供给编译器更多的信息，例如给 <code>guess</code> 变量一个<strong>显式的类型标注</strong>： <code>let guess: i32 = ...</code> 或者 <code>&quot;42&quot;.parse::&lt;i32&gt;()</code> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数值类型"><a class="header" href="#数值类型">数值类型</a></h1>
<p>我朋友有一个领导（读者：你朋友？黑人问号）说过一句话：所有代码就是 0 和 1 ，简单的很。咱不评价这句话的正确性，但是计算机底层由 01 组成倒是真的。</p>
<p>计算机和数值关联在一起的时间，远比我们想象的要长，因此数值类型可以说是有计算机以来就有的类型，下面内容将深入讨论 Rust 的数值类型以及相关的运算符。</p>
<h2 id="整数和浮点数"><a class="header" href="#整数和浮点数">整数和浮点数</a></h2>
<p>Rust 使用一个相对传统的语法来创建整数(<code>1</code>, <code>2</code>,...)和浮点数(<code>1.0</code>,<code>1.1</code>,...)。整数、浮点数的运算和你在其它语言上见过的一致，都是通过常见的运算符来完成。</p>
<blockquote>
<p>不仅仅是数值类型，Rust 也允许在复杂类型上定义运算符，例如在自定义类型上定义 <code>+</code> 运算符，这种行为被称为运算符重载，Rust 具体支持的可重载运算符见<a href="basic/base-type/../../appendix/operators.html#%E8%BF%90%E7%AE%97%E7%AC%A6">这里</a></p>
</blockquote>
<h4 id="整数类型"><a class="header" href="#整数类型">整数类型</a></h4>
<p><strong>整数</strong>是没有小数部分的数字。之前使用过的 <code>i32</code> 类型，表示有符号的 32位 整数（ <code>i</code> 是英文单词 <em>integer</em> 的首字母，与之相反的是 <code>u</code>，代表无符号 <code>unsigned</code> 类型）。下表显示了 Rust 中的内置的整数类型：</p>
<table><thead><tr><th>长度</th><th>有符号类型</th><th>无符号类型</th></tr></thead><tbody>
<tr><td>8 位</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16 位</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32 位</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64 位</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-位</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>视架构而定</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<p>类型定义的形式统一为：<code>有无符号 + 类型大小(位数)</code>。<strong>无符号数</strong>表示数字只能取正数，而<strong>有符号</strong>则表示数字即可以取正数又可以取负数。就像在纸上写数字一样：当要强调符号时，数字前面可以带上正号或负号；然而，当很明显确定数字为正数时，就不需要加上正号了。有符号数字以<a href="https://en.wikipedia.org/wiki/Two%27s_complement">补码</a>形式存储。</p>
<p>每个有符号类型规定的数字范围是  -(2<sup>n - 1</sup>) ~ 2<sup>n -
1</sup> - 1，其中 <code>n</code> 是该定义形式的位长度。因此 <code>i8</code> 可存储数字范围是 -(2<sup>7</sup>) ~ 2<sup>7</sup> - 1，即 -128 ~ 127。无符号类型可以存储的数字范围是 0 ~ 2<sup>n</sup> - 1，所以 <code>u8</code> 能够存储的数字为 0 ~ 2<sup>8</sup> - 1，即 0 ~ 255。</p>
<p>此外，<code>isize</code> 和 <code>usize</code> 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。</p>
<p>整形字面量可以用下表的形式书写：</p>
<table><thead><tr><th>数字字面量</th><th>示例</th></tr></thead><tbody>
<tr><td>十进制</td><td><code>98_222</code></td></tr>
<tr><td>十六进制</td><td><code>0xff</code></td></tr>
<tr><td>八进制</td><td><code>0o77</code></td></tr>
<tr><td>二进制</td><td><code>0b1111_0000</code></td></tr>
<tr><td>字节 (仅限于 <code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<p>这么多类型，有没有一个简单的使用准则？答案是肯定的， Rust 整形默认使用 <code>i32</code>，例如 <code>let i = 1</code>，那 <code>i</code> 就是 <code>i32</code> 类型，因此你可以首选它，同时该类型也往往是性能最好的。<code>isize</code> 和 <code>usize</code> 的主要应用场景是用作集合的索引。</p>
<blockquote>
<h5 id="整型溢出"><a class="header" href="#整型溢出">整型溢出</a></h5>
<p>比方说有一个 <code>u8</code> ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生<strong>整型溢出</strong>。关于这一行为 Rust 有一些有趣的规则：当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 <em>panic</em>(崩溃,Rust 使用这个术语来表明程序因错误而退出)。</p>
<p>在当使用 <code>--release</code> 参数进行 release 模式构建时，Rust <strong>不</strong>检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（<em>two’s complement wrapping</em>）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 <code>u8</code> 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 <em>panic</em>，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。</p>
<p>要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：</p>
<ul>
<li>使用 <code>wrapping_*</code> 方法在所有模式下都按照补码循环溢出规则处理，例如 <code>wrapping_add</code></li>
<li>如果使用 <code>checked_*</code> 方法时发生溢出，则返回 <code>None</code> 值</li>
<li>使用 <code>overflowing_*</code> 方法返回该值和一个指示是否存在溢出的布尔值</li>
<li>使用 <code>saturating_*</code> 方法使值达到最小值或最大值</li>
</ul>
</blockquote>
<h4 id="浮点类型"><a class="header" href="#浮点类型">浮点类型</a></h4>
<p><strong>浮点类型数字</strong> 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： <code>f32</code> 和 <code>f64</code>，分别为 32 位和 64 位大小。默认浮点类型是 <code>f64</code>，在现代的 CPU 中它的速度与 <code>f32</code> 几乎相同，但精度更高。</p>
<p>下面是一个演示浮点数的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>浮点数根据 <code>IEEE-754</code> 标准实现。<code>f32</code> 类型是单精度浮点型，<code>f64</code> 为双精度。</p>
<h4 id="数字运算"><a class="header" href="#数字运算">数字运算</a></h4>
<p>Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和取模运算。下面代码各使用一条 <code>let</code> 语句来说明相应运算的用法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // 加法
    let sum = 5 + 10;

    // 减法
    let difference = 95.5 - 4.3;

    // 乘法
    let product = 4 * 30;

    // 除法
    let quotient = 56.7 / 32.2;

    // 求余
    let remainder = 43 % 5;
}
</code></pre></pre>
<p>这些语句中的每个表达式都使用了数学运算符，并且计算结果为一个值，然后绑定到一个变量上。<a href="basic/base-type/../../appendix/operators.html">附录</a>中给出了 Rust 提供的所有运算符的列表。</p>
<p>再来看一个综合性的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  // 编译器会进行自动推导，给予twenty i32的类型
  let twenty = 20;
  // 类型标注
  let twenty_one: i32 = 21;
  // 通过类型后缀的方式进行类型标注：22是i32类型
  let twenty_two = 22i32;
  
  // 只有同样类型，才能运算
  let addition = twenty + twenty_one + twenty_two;
  println!(&quot;{} + {} + {} = {}&quot;, twenty, twenty_one, twenty_two, addition);
  
  // 对于较长的数字，可以用_进行分割，提升可读性
  let one_million: i64 = 1_000_000;
  println!(&quot;{}&quot;, one_million.pow(2));
  
  // 定义一个f32数组，其中42.0会自动被推导为f32类型
  let forty_twos = [
    42.0,
    42f32,
    42.0_f32,
  ];

// 打印数组中第一个值，其中控制小数位为2位
println!(&quot;{:02}&quot;, forty_twos[0]);
}
</code></pre></pre>
<h4 id="浮点数陷阱"><a class="header" href="#浮点数陷阱">浮点数陷阱</a></h4>
<p>浮点数由于底层格式的特殊性，导致了如果在使用浮点数时不够谨慎，就可能造成危险，有两个原因：</p>
<ol>
<li>
<p><strong>浮点数往往是你想要数字的近似表达</strong>
浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 <code>0.1</code> 在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行</p>
</li>
<li>
<p><strong>浮点数在某些特性上是反直觉的</strong>
例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用 <code>&gt;</code> ， <code>&gt;=</code> 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为 <code>f32</code> ， <code>f64</code> 上的比较运算实现的是 <code>std::cmp::PartialEq</code> 特征(类似其他语言的接口)，但是并没有实现 <code>std::cmp::Eq</code> 特征，但是后者在其它数值类型上都有定义，说了这么多，可能大家还是云里雾里，用一个例子来举例：</p>
</li>
</ol>
<p>Rust 的 <code>HashMap</code> 数据结构，是一个 KV 类型的 Hash Map 实现，它对于 <code>K</code> 没有特定类型的限制，但是要求能用作 <code>K</code> 的类型必须实现了 <code>std::cmp::Eq</code> 特征，因此这意味着你无法使用浮点数作为 <code>HashMap</code> 的 <code>Key</code>，来存储键值对，但是作为对比，Rust的整数类型、字符串类型、布尔类型都实现了该特征，因此可以作为 <code>HashMap</code> 的 <code>Key</code>。</p>
<p>为了避免上面说的两个陷阱，你需要遵守以下准则：</p>
<ul>
<li>避免在浮点数上测试相等性</li>
<li>当结果在数学上可能存在未定义时，需要格外的小心</li>
</ul>
<p>来看个小例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  // 断言0.1 + 0.2与0.3相等
  assert!(0.1 + 0.2 == 0.3);
}
</code></pre></pre>
<p>你可能以为，这段代码没啥问题吧，实际上它会 <em>panic</em>(程序崩溃，抛出异常)，因为二进制精度问题，导致了 0.1 + 0.2 并不严格等于 0.3，它们可能在小数点 N 位后存在误差。</p>
<p>那如果非要进行比较呢？可以考虑用这种方式 <code>(0.1 + 0.2 - 0.3).abs() &lt; 0.00001</code> ，具体小于多少，取决于你对精度的需求。</p>
<p>讲到这里，相信大家基本已经明白了，为什么操作浮点数时要格外的小心，但是还不够，下面再来一段代码，直接震撼你的灵魂：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);

    println!(&quot;abc (f32)&quot;);
    println!(&quot;   0.1 + 0.2: {:x}&quot;, (abc.0 + abc.1).to_bits());
    println!(&quot;         0.3: {:x}&quot;, (abc.2).to_bits());
    println!();

    println!(&quot;xyz (f64)&quot;);
    println!(&quot;   0.1 + 0.2: {:x}&quot;, (xyz.0 + xyz.1).to_bits());
    println!(&quot;         0.3: {:x}&quot;, (xyz.2).to_bits());
    println!();

    assert!(abc.0 + abc.1 == abc.2);
    assert!(xyz.0 + xyz.1 == xyz.2);
}
</code></pre></pre>
<p>运行该程序，输出如下:</p>
<pre><code class="language-console">abc (f32)
   0.1 + 0.2: 3e99999a
         0.3: 3e99999a
 
xyz (f64)
   0.1 + 0.2: 3fd3333333333334
         0.3: 3fd3333333333333
 
thread 'main' panicked at 'assertion failed: xyz.0 + xyz.1 == xyz.2',
➥ch2-add-floats.rs.rs:14:5
note: run with `RUST_BACKTRACE=1` environment variable to display
➥a backtrace
</code></pre>
<p>仔细看，对 <code>f32</code> 类型做加法时，<code>0.1 + 0.2</code> 的结果是 <code>3e99999a</code>，<code>0.3</code> 也是 <code>3e99999a</code>，因此 <code>f32</code> 下的 <code>0.1 + 0.2 == 0.3</code> 通过测试，但是到了 <code>f64</code> 类型时，结果就不一样了，因为 <code>f64</code> 精度高很多，因此在小数点非常后面发生了一点微小的变化，<code>0.1 + 0.2</code> 以 <code>4</code> 结尾，但是 <code>0.3</code> 以<code>3</code>结尾，这个细微区别导致 <code>f64</code> 下的测试失败了，并且抛出了异常。</p>
<p>是不是<strong>blow your mind away</strong>? 没关系，在本书的后续章节中类似的直击灵魂的地方还很多，这就是敢号称 <code>Rust语言圣经（Rust Course）</code> 的底气！</p>
<h4 id="nan"><a class="header" href="#nan">NaN</a></h4>
<p>对于数学上未定义的结果，例如对负数取平方根 <code>-42.1.sqrt()</code> ，会产生一个特殊的结果：Rust 的浮点数类型使用 <code>NaN</code> (not a number)来处理这些情况。</p>
<p><strong>所有跟 <code>NaN</code> 交互的操作，都会返回一个 <code>NaN</code></strong>，而且 <code>NaN</code> 不能用来比较，下面的代码会崩溃：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  let x = (-42.0_f32).sqrt();
  assert_eq!(x, x);
}
</code></pre></pre>
<p>出于防御性编程的考虑，可以使用 <code>is_nan()</code> 等方法，可以用来判断一个数值是否是 <code>NaN</code> ：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = (-42.0_f32).sqrt();
    if x.is_nan() {
        println!(&quot;未定义的数学行为&quot;)
    }
}
</code></pre></pre>
<h2 id="序列range"><a class="header" href="#序列range">序列(Range)</a></h2>
<p>Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 <code>1..5</code> ，生成从 1 到 4 的连续数字，不包含 5 ； <code>1..=5</code> ，生成从 1 到 5 的连续数字，包含 5 ，它的用途很简单，常常用于循环中：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 1..=5 {
    println!(&quot;{}&quot;,i);
}
<span class="boring">}
</span></code></pre></pre>
<p>最终程序输出:</p>
<pre><code class="language-console">1
2
3
4
5
</code></pre>
<p>序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 'a'..='z' {
    println!(&quot;{}&quot;,i);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="有理数和复数"><a class="header" href="#有理数和复数">有理数和复数</a></h2>
<p>Rust 的标准库相比其它语言，对于准入的门槛较高，因此有理数和复数并未包含在标准库中：</p>
<ul>
<li>有理数和复数</li>
<li>任意大小的整数和任意精度的浮点数</li>
<li>固定精度的十进制小数，常用于货币相关的场景</li>
</ul>
<p>好在社区已经开发出高质量的 Rust 数值库：<a href="https://crates.io/crates/num">num</a>.</p>
<p>按照以下步骤来引入 <code>num</code> 库：</p>
<ol>
<li>创建新工程 <code>cargo new complex-num &amp;&amp; cd complex-num</code></li>
<li>在 <code>Cargo.toml</code> 中的 <code>[dependencies]</code> 下添加一行 <code>num = &quot;0.4.0&quot;</code></li>
<li>将 <code>src/main.rs</code> 文件中的 <code>main</code> 函数替换为下面的代码</li>
<li>运行 <code>cargo run</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">use num::complex::Complex;
 
 fn main() {
   let a = Complex { re: 2.1, im: -1.2 };
   let b = Complex::new(11.1, 22.2);
   let result = a + b;
 
   println!(&quot;{} + {}i&quot;, result.re, result.im)
 }
</code></pre></pre>
<h2 id="总结-2"><a class="header" href="#总结-2">总结</a></h2>
<p>之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：</p>
<ul>
<li><strong>Rust 拥有相当多的数值类型</strong>. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数</li>
<li><strong>类型转换必须是显式的</strong>. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数</li>
<li><strong>Rust 的数值上可以使用方法</strong>. 例如你可以用以下方法来将 <code>13.14</code> 取整： <code>13.14_f32.round()</code>，在这里我们使用了类型后缀，因为编译器需要知道 <code>13.14 </code>的具体类型</li>
</ul>
<p>数值类型的讲解已经基本结束，接下来，来看看字符和布尔类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符布尔元类型"><a class="header" href="#字符布尔元类型">字符、布尔、元类型</a></h1>
<p>这三个类型所处的地位比较尴尬，你说它们重要吧，有时候也是不可或缺，说它们不重要吧，确实出现的身影不是很多，而且这三个类型都有一个共同点：简单，因此我们统一放在一起讲。</p>
<h2 id="字符类型char"><a class="header" href="#字符类型char">字符类型(char)</a></h2>
<p>字符，对于没有其它编程经验的新手来说可能不太好理解(没有编程经验敢来学 Rust 的绝对是好汉)，但是你可以把它理解为英文中的字母，中文中的汉字。</p>
<p>下面的代码展示了几个颇具异域风情的字符：</p>
<pre><code>fn main() {
    let c = 'z';
    let z = 'ℤ';
    let g = '国';
    let heart_eyed_cat = '😻';
}
</code></pre>
<p>如果大家是从有年代感的编程语言过来，可能会大喊一声：这XX叫字符？是的，在 Rust 语言中这些都是字符，Rust 的字符不仅仅是 <code>ASCII</code>，所有的 <code>Unicode</code> 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji表情符号等等，都是合法的字符类型。<code>Unicode</code> 值的范围从 <code>U+0000~U+D7FF</code> 和 <code>U+E000~U+10FFFF</code>。不过“字符”并不是 <code>Unicode</code> 中的一个概念，所以人在直觉上对“字符”的理解和 Rust 的字符概念并不一致。</p>
<p>由于 <code>Unicode</code> 都是 4 个字节编码，因此字符类型也是占用 4 个字节：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = '中';
    println!(&quot;字符'中'占用了{}字节的内存大小&quot;,std::mem::size_of_val(&amp;x));
}
</code></pre></pre>
<p>输出如下:</p>
<pre><code class="language-console">$ cargo run
   Compiling ...
    
字符'中'占用了4字节的内存大小
</code></pre>
<blockquote>
<p>注意，我们还没开始讲字符串，但是这里提前说一下，和一些语言不同，Rust 的字符只能用 <code>''</code> 来表示， <code>&quot;&quot;</code> 是留给字符串的</p>
</blockquote>
<h2 id="布尔bool"><a class="header" href="#布尔bool">布尔(bool)</a></h2>
<p>Rust 中的布尔类型有两个可能的值：<code>true</code> 和 <code>false</code>, 布尔值占用内存的大小为 <code>1</code> 个字节：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let t = true;

    let f: bool = false; // 使用类型标注,显式指定f的类型

    if f {
        println!(&quot;这是段毫无意义的代码&quot;);
    }
}
</code></pre></pre>
<p>使用布尔类型的场景主要在于流程控制，例如上述代码的中的 <code>if</code> 就是其中之一。</p>
<h2 id="元类型"><a class="header" href="#元类型">元类型</a></h2>
<p>元类型就是 <code>()</code> ，对，你没看错，就是 <code>()</code> ，唯一的值也是 <code>()</code> ，一些读者读到这里可能就不愿意了，你也太敷衍了吧，管这叫类型？</p>
<p>只能说，再不起眼的东西，都有其用途，在目前为止的学习过程中，大家已经看到过很多次 <code>fn main()</code> 函数的使用吧？那么这个函数返回什么呢？</p>
<p>没错， <code>main</code> 函数就返回这个元类型 <code>()</code>，你不能说 <code>main</code> 函数无返回值，因为没有返回值的函数在 Rust 中是有单独的定义的：<code>发散函数</code>，顾名思义，无法收敛的函数。</p>
<p>例如常见的 <code>println!()</code> 的返回值也是元类型 <code>()</code>。</p>
<p>再比如，你可以用 <code>()</code> 作为 <code>map</code> 的值，表示我们不关注具体的值，只关注 <code>key</code>。 这种用法和 Go 语言的 <em><strong>struct{}</strong></em> 类似，可以作为一个值用来占位，但是完全<strong>不占用</strong>任何内存。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语句和表达式"><a class="header" href="#语句和表达式">语句和表达式</a></h1>
<p>Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值，例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_with_extra(x: i32, y: i32) -&gt; i32 {
    let x = x + 1; // 语句
    let y = y + 5; // 语句
    x + y // 表达式
}
<span class="boring">}
</span></code></pre></pre>
<p>语句会执行一些操作但是不会返回一个值，而表达式会在求值后返回一个值，因此在上述函数体的三行代码中，前两行是语句，最后一行是表达式。</p>
<p>对于 Rust 语言而言，<strong>这种基于语句和表达式的方式是非常重要的，你需要能明确的区分这两个概念</strong>, 但是对于很多其它语言而言，这两个往往无需区分。基于表达式是函数式语言的重要特征，<strong>表达式总要返回值</strong>。</p>
<p>其实，在此之前，我们已经多次使用过语句和表达式。</p>
<h2 id="语句"><a class="header" href="#语句">语句</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 8;
let b: Vec&lt;f64&gt; = Vec::new();
let (a, c) = (&quot;hi&quot;, false);
<span class="boring">}
</span></code></pre></pre>
<p>以上都是语句，它们完成了一个具体的操作，但是并没有返回值，因此是语句。</p>
<p>由于 <code>let</code> 是语句，因此不能将 <code>let</code> 语句赋值给其它值，如下形式是错误的：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b = (let a = 8);
<span class="boring">}
</span></code></pre></pre>
<p>错误如下: </p>
<pre><code class="language-console">error: expected expression, found statement (`let`) // 期望表达式，却发现`let`语句
 --&gt; src/main.rs:2:13
  |
2 |     let b = let a = 8;
  |             ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement `let`是一条语句

error[E0658]: `let` expressions in this position are experimental
          // 下面的 `let` 用法目前是试验性的，在稳定版中尚不能使用
 --&gt; src/main.rs:2:13
  |
2 |     let b = let a = 8;
  |             ^^^^^^^^^
  |
  = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information
  = help: you can write `matches!(&lt;expr&gt;, &lt;pattern&gt;)` instead of `let &lt;pattern&gt; = &lt;expr&gt;`

</code></pre>
<p>以上的错误告诉我们 <code>let</code> 是语句，不是表达式，因此它不返回值，也就不能给其它变量赋值。但是该错误还透漏了一个重要的信息， <code>let</code> 作为表达式已经是试验功能了，也许不久的将来，我们在<a href="basic/base-type/../../appendix/rust-version.html"><code>stable rust</code></a>下可以这样使用。</p>
<h2 id="表达式"><a class="header" href="#表达式">表达式</a></h2>
<p>表达式会进行求值，然后返回一个值。例如 <code>5 + 6</code>，在求值后，返回值 <code>11</code>，因此它就是一条表达式。</p>
<p>表达式可以成为语句的一部分，例如 <code>let y = 6</code> 中， <code>6</code> 就是一个表达式，它在求值后返回一个值 <code>6</code> (有些反直觉，但是确实是表达式).</p>
<p>调用一个函数是表达式，因为会返回一个值，调用宏也是表达式，用花括号包裹最终返回一个值的语句块也是表达式，总之，能返回值，它就是表达式:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>上面使用一个语句块表达式将值赋给 <code>y</code> 变量，语句块长这样：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let x = 3;
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<p>该语句块是表达式的原因是：它的最后一行是表达式，返回了 <code>x + 1</code> 的值，注意 <code>x + 1</code> 不能以分号结尾，否则就会从表达式变成语句， <strong>表达式不能包含分号</strong>。这一点非常重要，一旦你在表达式后加上分号，它就会变成一条语句，再也<strong>不会</strong>返回一个值，请牢记！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数"><a class="header" href="#函数">函数</a></h1>
<p>Rust 的函数我们在之前已经见过不少，跟其他语言几乎没有什么区别。因此本章的学习之路将轻松和愉快，骚年们，请珍惜这种愉快，下一章你将体验到不一样的 Rust。</p>
<p>在函数界，有一个函数只闻其名不闻其声，可以止小孩啼！在程序界只有 <code>hello,world!</code> 可以与之媲美，它就是 <code>add</code> 函数：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(i: i32, j: i32) -&gt; i32 {
   i + j
 }
<span class="boring">}
</span></code></pre></pre>
<p>该函数如此简单，但是又是如此的五脏俱全，声明函数的关键字 <code>fn</code> ,函数名 <code>add()</code>，参数 <code>i</code> 和 <code>j</code>，参数类型和返回值类型都是 <code>i32</code>，总之一切那么的普通，但是又那么的自信，直到你看到了下面这张图：</p>
<img alt="" src="basic/base-type//img/function-01.png" class="center"  />
<p>当你看懂了这张图，其实就等于差不多完成了函数章节的学习，但是这么短的章节显然对不起读者老爷们的厚爱，所以我们来展开下。</p>
<h2 id="函数要点"><a class="header" href="#函数要点">函数要点</a></h2>
<ul>
<li>函数名和变量名使用<a href="basic/base-type/../../practice/style-guide/naming.html">蛇形命名法(snake case)</a>，例如 <code>fn add_two() -&gt; {}</code></li>
<li>函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可</li>
<li>每个函数参数都需要标注类型</li>
</ul>
<h2 id="函数参数"><a class="header" href="#函数参数">函数参数</a></h2>
<p>Rust 是强类型语言，因此需要你为每一个函数参数都标识出它的具体类型，例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    another_function(5, 6.1);
}

fn another_function(x: i32, y: f32) {
    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p><code>another_function</code> 函数有两个参数，其中 <code>x</code> 是 <code>i32</code> 类型，<code>y</code> 是 <code>f32</code> 类型，然后在该函数内部，打印出这两个值。这里去掉 <code>x</code> 或者 <code>y</code> 的任何一个的类型，都会报错：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    another_function(5, 6.1);
}

fn another_function(x: i32, y) {
    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>错误如下:</p>
<pre><code class="language-console">error: expected one of `:`, `@`, or `|`, found `)`
 --&gt; src/main.rs:5:30
  |
5 | fn another_function(x: i32, y) {
  |                              ^ expected one of `:`, `@`, or `|` // 期待以下符号之一 `:`, `@`, or `|` 
  |
  = note: anonymous parameters are removed in the 2018 edition (see RFC 1685)
    // 匿名参数在 Rust 2018 edition 中就已经移除
help: if this is a parameter name, give it a type // 如果y是一个参数名，请给予它一个类型
  |
5 | fn another_function(x: i32, y: TypeName) {
  |                             ~~~~~~~~~~~
help: if this is a type, explicitly ignore the parameter name // 如果y是一个类型，请使用_忽略参数名
  |
5 | fn another_function(x: i32, _: y) {
  |                             ~~~~
</code></pre>
<h2 id="函数返回"><a class="header" href="#函数返回">函数返回</a></h2>
<p>在上一章节语句和表达式中，我们有提到，在 Rust 中函数就是表达式，因此我们可以把函数的返回值直接赋给调用者。</p>
<p>函数的返回值就是函数体最后一条表达式的返回值，当然我们也可以使用 <code>return</code> 提前返回，下面的函数使用最后一条表达式来返回一个值：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn plus_five(x:i32) -&gt; i32 {
    x + 5
}

fn main() {
    let x = plus_five(5);

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p><code>x + 5</code> 是一条表达式，求值后，返回一个值，因为它是函数的最后一行，因此该表达式的值也是函数的返回值。</p>
<p>再来看两个重点：</p>
<ol>
<li><code>let x = plus_five(5)</code>，说明我们用一个函数的返回值来初始化 <code>x</code> 变量，因此侧面说明了在 Rust 中函数也是表达式，这种写法等同于 <code>let x = 5 + 5;</code></li>
<li><code>x + 5</code> 没有分号，因为它是一条表达式，这个在上一节中我们也有详细介绍</li>
</ol>
<p>再来看一段代码，同时使用 <code>return</code> 和表达式作为返回值：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn plus_or_substract(x:i32) -&gt; i32 {
    if x &gt; 5 {
        return x - 5
    }

    x + 5
}

fn main() {
    let x = plus_or_substract(5);

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p><code>plus_or_substract</code> 函数根据传入 <code>x</code> 的大小来决定是做加法还是减法，若 <code>x &gt; 5</code> 则通过 <code>return</code> 提前返回 <code>x - 5</code> 的值,否则返回 <code>x + 5</code> 的值。</p>
<h4 id="rust中的特殊返回类型"><a class="header" href="#rust中的特殊返回类型">Rust中的特殊返回类型</a></h4>
<h5 id="无返回值"><a class="header" href="#无返回值">无返回值<code>()</code></a></h5>
<p>对于 Rust 新手来说，有些返回类型很难理解，而且如果你想通过百度或者谷歌去搜索，都不好查询，因为这些符号太常见了，根本难以精确搜索到。</p>
<p>例如元类型 <code>()</code>，是一个零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值：</p>
<ul>
<li>函数没有返回值，那么返回一个 <code>()</code></li>
<li>通过 <code>;</code> 结尾的表达式返回一个 <code>()</code></li>
</ul>
<p>例如下面的 <code>report</code> 函数会隐式返回一个 <code>()</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;
 
fn report&lt;T: Debug&gt;(item: T) {
  println!(&quot;{:?}&quot;, item);
 
}
<span class="boring">}
</span></code></pre></pre>
<p>与上面的函数返回值相同，但是下面的函数显式的返回了 <code>()</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn clear(text: &amp;mut String) -&gt; () {
  *text = String::from(&quot;&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>在实际编程中，你会经常在错误提示中看到该 <code>()</code> 的身影出没，假如你的函数需要返回一个 <code>u32</code> 值，但是如果你不幸的以 <code>表达式;</code> 的方式作为函数的最后一行代码，就会报错：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x:u32,y:u32) -&gt; u32 {
    x + y;
}
<span class="boring">}
</span></code></pre></pre>
<p>错误如下：</p>
<pre><code class="language-console">error[E0308]: mismatched types // 类型不匹配
 --&gt; src/main.rs:6:24
  |
6 | fn add(x:u32,y:u32) -&gt; u32 {
  |    ---                 ^^^ expected `u32`, found `()` // 期望返回u32,却返回()
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression 
7 |     x + y;
  |          - help: consider removing this semicolon
</code></pre>
<p>还记得我们在<a href="basic/base-type/./statement-expression.html">语句与表达式</a>中讲过的吗？只有表达式能返回值，而 <code>;</code> 结尾的是语句，在 Rust 中，一定要严格区分<strong>表达式</strong>和<strong>语句</strong>的区别，这个在其它语言中往往是被忽视的点。</p>
<h5 id="永不返回的函数"><a class="header" href="#永不返回的函数">永不返回的函数<code>!</code></a></h5>
<p>感叹号，当用作函数返回值的时候，表示该函数永不返回，特别的，这种语法往往用做会导致程序崩溃的函数：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dead_end() -&gt; ! {
  panic!(&quot;你已经到了穷途末路，崩溃吧！&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>下面的函数创建了一个无限循环，该循环永不跳出，因此函数也永不返回：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn forever() -&gt; ! {
  loop {
    //...
  };
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="所有权和借用"><a class="header" href="#所有权和借用">所有权和借用</a></h1>
<p>Rust之所以能成为万众瞩目的语言，就是因为其内存安全性。在以往，内存安全几乎都是通过GC的方式实现，但是GC会引来性能、内存占用以及Stop the world等问题，在高性能场景和系统编程上是不可接受的，因此Rust采用了与(错)众(误)不(之)同(源)的方式：<strong>所有权系统</strong>。</p>
<p>理解所有权和借用，对于Rust学习是至关重要的，因此我们把本章提到了非常靠前的位置，So，骚年们，准备好迎接狂风暴雨了嘛？</p>
<p>从现在开始，鉴于大家已经掌握了非常基本的语法，有些时候，在示例代码中，将省略<code>fn main() {}</code>的模版代码，只要将相应的示例放在<code>fn main() {}</code>中，即可运行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="所有权"><a class="header" href="#所有权">所有权</a></h1>
<p>所有的程序都必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，也是所有编程语言设计的难点之一。在计算机语言不断演变过程中，出现了三种流派：</p>
<ul>
<li><strong>垃圾回收机制(GC)</strong>，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go</li>
<li><strong>手动管理内存的分配和释放</strong>, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++</li>
<li><strong>通过所有权来管理内存</strong>，编译器在编译时会根据一系列规则进行检查</li>
</ul>
<p>其中Rust选择了第三种，最妙的是，这种检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失。</p>
<p>由于所有权是一个新概念，因此读者需要花费一些时间来掌握它，一旦掌握，海阔天空任你飞跃，在本章，我们将通过<code>字符串</code>来引导讲解所有权的相关知识。</p>
<h2 id="一段不安全的代码"><a class="header" href="#一段不安全的代码">一段不安全的代码</a></h2>
<p>先来看看一段来自C语言的糟糕代码：</p>
<pre><code class="language-c">int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = &quot;xyz&quot;;   // 变量c的作用域开始
    return &amp;a;
}                   // 变量a和c的作用域结束
</code></pre>
<p>这段代码虽然可以编译通过，但是其实非常糟糕，变量<code>a</code>和<code>c</code>都是局部变量，函数结束后将局部变量<code>a</code>的地址返回，但局部变量<code>a</code>存在栈中，在离开作用域后，<code>a</code>所申请的栈上内存都会被系统回收，从而造成了<code>悬空指针(Dangling Pointer)</code>的问题。这是一个非常典型的内存安全问题,虽然编译可以通过，但是运行的时候会出现错误, 很多编程语言都存在。</p>
<p>再来看变量<code>c</code>，<code>c</code>的值是常量字符串，存储于常量区，可能这个函数我们只调用了一次，也可能我们不再会使用这个字符串，但<code>xyz</code>只有当整个程序结束后系统才能回收这片内存。</p>
<p>所以内存安全问题，一直都是程序员非常头疼的问题，好在, 在Rust中这些问题即将成为历史，因为Rust在编译的时候就可以帮助我们发现内存不安全的问题，那Rust如何做到这一点呢？</p>
<p>在正式进入主题前，先来一个预热知识。</p>
<h2 id="栈stack与堆heap"><a class="header" href="#栈stack与堆heap">栈（Stack）与堆（Heap）</a></h2>
<p>栈和堆是编程语言最核心的数据结构，但是在很多语言中，你并不需要深入了解栈与堆。 但对于Rust这样的系统编程语言，值是位于栈上还是堆上非常重要, 因为这会影响程序的行为和性能。</p>
<p>栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间。</p>
<h4 id="栈"><a class="header" href="#栈">栈</a></h4>
<p>栈按照顺序存储值并以相反顺序取出值，这也被称作 <strong>后进先出</strong>。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，再从顶部拿走。不能从中间也不能从底部增加或拿走盘子！</p>
<p>增加数据叫做 <strong>进栈</strong>，移出数据则叫做 <strong>出栈</strong>。</p>
<p>因为上述的实现方式，栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。</p>
<h4 id="堆"><a class="header" href="#堆">堆</a></h4>
<p>与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。</p>
<p>当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <strong>指针</strong>, 该过程被称为 <strong>在堆上分配内存</strong>，有时简称为 “分配”（allocating）。 </p>
<p>接着，该指针会被推入<code>栈</code>中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。</p>
<p>由上可知，堆是一种缺乏组织的数据结构。想象一下去餐馆就座吃饭: 进入餐馆，告知服务员有几个人，然后服务员找到一个够大的空桌子(堆上分配的内存空间)并领你们过去。如果有人来迟了，他们也可以通过桌号(栈上的指针)来找到你们坐在哪。</p>
<h4 id="性能区别"><a class="header" href="#性能区别">性能区别</a></h4>
<p>写入方面：入栈比在堆上分配内存要快，因为入栈时操作系统无需分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备。</p>
<p>读取方面：得益于CPU高速缓存，使得处理器可以减少对内存的访问，高速缓存和内存的访问速度差异在10倍以上！栈数据往往可以直接存储在CPU高速缓存中，而堆数据只能存储在内存中。访问堆上的数据比访问栈上的数据慢，因为必须先访问栈再通过栈上的指针来访问内存。</p>
<p>因此，处理器处理和分配在栈上数据会比在堆上的数据更加高效。</p>
<h4 id="所有权与堆栈"><a class="header" href="#所有权与堆栈">所有权与堆栈</a></h4>
<p>当你的代码调用一个函数时，传递给函数的参数(包括可能指向堆上数据的指针和函数的局部变量)依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。</p>
<p>因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 - 这些数据将永远无法被回收。这就是Rust所有权系统为我们提供的强大保障。 </p>
<p>对于其他很多编程语言，你确实无需理解堆栈的原理，<strong>但是在Rust中，明白堆栈的原理，对于我们理解所有权的工作原理会有很大的帮助</strong>.</p>
<h2 id="所有权原则"><a class="header" href="#所有权原则">所有权原则</a></h2>
<p>理解了堆栈，接下来看一下<em>关于所有权的规则</em>，首先请谨记以下规则：</p>
<blockquote>
<ol>
<li>Rust中每一个值都<code>有且只有</code>一个所有者(变量)</li>
<li>当所有者(变量)离开作用域范围时，这个值将被丢弃(free)</li>
</ol>
</blockquote>
<h4 id="变量作用域"><a class="header" href="#变量作用域">变量作用域</a></h4>
<p>作用域是一个变量在程序中有效的范围, 假如有这样一个变量：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;
<span class="boring">}
</span></code></pre></pre>
<p>变量<code>s</code>绑定到了一个字符串字面值，该字符串字面值是硬编码到程序代码中的。<code>s</code>变量从声明的点开始直到当前作用域的结束都是有效的：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{                      // s 在这里无效，它尚未声明
    let s = &quot;hello&quot;;   // 从此处起，s 是有效的

    // 使用 s
}                      // 此作用域已结束，s不再有效
<span class="boring">}
</span></code></pre></pre>
<p>简而言之，<code>s</code>从创建伊始就开始有效，然后有效期持续到它离开作用域为止，可以看出，就作用域来说，Rust语言跟其他编程语言没有区别。</p>
<h4 id="简单介绍string类型"><a class="header" href="#简单介绍string类型">简单介绍String类型</a></h4>
<p>之前提到过，本章会用String作为例子，因此这里会进行一下简单的介绍，具体的String学习请参见<a href="basic/ownership/../compound-type/string-slice.html">String类型</a>。</p>
<p>我们已经见过字符串字面值<code>let s =&quot;hello&quot;</code>，s是被硬编码进程序里的字符串值（类型为&amp;str）。字符串字面值是很方便的，但是它并不适用于所有场景。原因有二：</p>
<ul>
<li><strong>字符串字面值是不可变的</strong>，因为被硬编码到程序代码中</li>
<li>并非所有字符串的值都能在编写代码时得知</li>
</ul>
<p>例如，字符串是需要程序运行时，通过用户动态输入然后存储在内存中的，这种情况，字符串字面值就完全无用武之地。 为此，Rust为我们提供动态字符串类型: <code>String</code>, 该类型被分配到堆上，因此可以动态伸缩，也就能存储在编译时大小未知的文本。</p>
<p>可以使用下面的方法基于字符串字面量来创建<code>String</code>类型:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><code>::</code>是一种调用操作符，这里表示调用<code>String</code>中的<code>from</code>方法，因为<code>String</code>存储在堆上是动态的，你可以这样修改它：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

s.push_str(&quot;, world!&quot;); // push_str() 在字符串后追加字面值

println!(&quot;{}&quot;, s); // 将打印 `hello, world!`
<span class="boring">}
</span></code></pre></pre>
<p>言归正传，了解<code>String</code>内容后，一起来看看关于所有权的交互。</p>
<h2 id="变量绑定背后的数据交互"><a class="header" href="#变量绑定背后的数据交互">变量绑定背后的数据交互</a></h2>
<h4 id="转移所有权"><a class="header" href="#转移所有权">转移所有权</a></h4>
<p>先来看一段代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
<span class="boring">}
</span></code></pre></pre>
<p>代码背后的逻辑很简单, 将 <code>5 </code>绑定到变量<code>x</code>；接着拷贝<code>x</code>的值赋给<code>y</code>,最终<code>x</code>和<code>y</code>都等于<code>5</code>,因为整数是Rust基本数据类型，是固定大小的简单值，因此这两个值都是通过自动拷贝的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。</p>
<p>可能有同学会有疑问：这种拷贝不消耗性能吗？实际上，这种栈上的数据足够简单，而且拷贝非常非常快，只需要复制一个整数大小(i32，4个字节)的内存即可，因此在这种情况下，拷贝的速度远比在堆上创建内存来得快的多。实际上，上一章我们讲到的Rust基本类型都是通过自动拷贝的方式来赋值的，就像上面代码一样。</p>
<p>然后再来看一段代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>此时，可能某个大聪明(善意昵称)已经想到了：嗯，把<code>s1</code>的内容拷贝一份赋值给<code>s2</code>，实际上，并不是这样。之前也提到了，对于基本类型(存储在栈上)，Rust会自动拷贝，但是<code>String</code>不是基本类型，而是存储在堆上的，因此不能自动拷贝。</p>
<p>实际上，<code>String</code>类型是一个复杂类型，由存储在栈中的堆指针、字符串长度、字符串容量共同组成，其中堆指针是最重要的，它指向了真实存储字符串内容的堆内存，至于长度和容量，如果你有Go语言的经验，这里就很好理解：容量是堆内存分配空间的大小，长度是目前已经使用的大小.</p>
<p>总之<code>String</code>类型指向了一个堆上的空间，这里存储着它的真实数据, 下面对上面代码中的<code>let s2 = s1</code>分成两种情况讨论：</p>
<ol>
<li>
<p>拷贝<code>String</code>和存储在堆上的字节数组
如果该语句是拷贝所有数据(深拷贝)，那么无论是<code>String</code>本身还是底层的堆上数据，都会被全部拷贝，这对于性能而言会造成非常大的影响</p>
</li>
<li>
<p>只拷贝<code>String</code>本身
这样的拷贝非常快，因为在64位机器上就拷贝了<code>8字节的指针</code>、<code>8字节的长度</code>、<code>8字节的容量</code>，总计24字节，但是带来了新的问题，还记得我们之前提到的所有权规则吧？其中有一条就是，一个值只允许有一个所有者，而现在这个值(堆上的真实字符串数据)有了两个所有者：<code>s1</code>和<code>s2</code>。</p>
</li>
</ol>
<p>好吧，就假定一个值可以拥有两个所有者，会发生什么呢？</p>
<p>当变量离开作用域后，Rust会自动调用 <code>drop</code> 函数并清理变量的堆内存。不过由于两个<code>String</code>变量指向了同一位置。这就有了一个问题：当 <code>s1</code> 和 <code>s2</code> 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 二次释放（double free）的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p>
<p>因此，Rust这样解决问题：<strong>当<code>s1</code>赋予<code>s2</code>后，Rust认为<code>s1</code>不再有效，因此也无需在<code>s1</code>离开作用域后<code>drop</code>任何东西，这就是把所有权从<code>s1</code>转移给了<code>s2</code>，<code>s1</code>在被赋予<code>s2</code>后就马上失效了</strong>.</p>
<p>再来看看，在所有权转移后再来使用旧的所有者，会发生什么：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

println!(&quot;{}, world!&quot;, s1);
<span class="boring">}
</span></code></pre></pre>
<p>由于Rust禁止你使用无效的引用，你会看到以下的错误</p>
<pre><code class="language-console">error[E0382]: use of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
</code></pre>
<p>现在再回头看看之前的规则，相信大家已经有了更深刻的理解：</p>
<blockquote>
<ol>
<li>Rust中每一个值都<code>有且只有</code>一个所有者(变量)</li>
<li>当所有者(变量)离开作用域范围时，这个值将被丢弃</li>
</ol>
</blockquote>
<p>如果你在其他语言中听说过术语 浅拷贝（shallow copy）和 深拷贝（deep copy），那么拷贝指针、长度和容量而不拷贝数据听起来就像浅拷贝，但是又因为 Rust 同时使第一个变量<code>s1</code>无效了，因此这个操作被称为 移动（move），而不是浅拷贝。上面的例子可以解读为 <code>s1</code> 被 移动 到了 <code>s2</code> 中。那么具体发生了什么，用一张图简单说明：</p>
<img alt="s1 moved to s2" src="basic/ownership//img/ownership01.svg" class="center" style="width: 50%;" />
<p>这样就解决了我们之前的问题，<code>s1</code>不再指向任何数据，只有<code>s2</code>是有效的，当<code>s2</code>离开作用域，它就会释放内存。 相信此刻，你应该明白了，为什么Rust称呼<code>let a = b</code>为<strong>变量绑定</strong>了吧？</p>
<h4 id="克隆深拷贝"><a class="header" href="#克隆深拷贝">克隆(深拷贝)</a></h4>
<p>首先，<strong>Rust 永远也不会自动创建数据的 “深拷贝”</strong>。因此，任何<strong>自动</strong>的复制都不是深拷贝，可以被认为对运行时性能影响较小。</p>
<p>如果我们<strong>确实</strong>需要深度复制<code>String</code>中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做<code>clone</code>的方法。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>这段代码能够正常运行，因此说明<code>s2</code>确实完整的复制了<code>s1</code>的数据。</p>
<p>如果代码性能无关紧要，例如初始化程序时，或者在某段时间只会执行一次时，你可以使用<code>clone</code>来简化编程。但是对于执行较为频繁的代码(热点路径)，使用<code>clone</code>会极大的降低程序性能，需要小心使用！</p>
<h4 id="拷贝浅拷贝"><a class="header" href="#拷贝浅拷贝">拷贝(浅拷贝)</a></h4>
<p>浅拷贝只发生在栈上，因此性能很高，在日常编程中，浅拷贝无处不在。</p>
<p>再回到之前看过的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 <code>clone</code>，不过依然实现了类似深拷贝的效果 - 没有报所有权的错误。</p>
<p>原因是像整型这样的基本类型在编译时是已知大小的，会被存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 <code>y</code> 后使 <code>x</code> 无效（<code>x</code>、 <code>y</code>都仍然有效）。换句话说，这里没有深浅拷贝的区别，因此这里调用 <code>clone</code> 并不会与通常的浅拷贝有什么不同，我们可以不用管它（可以理解成在栈上做了深拷贝）。</p>
<p>Rust 有一个叫做 <code>Copy</code>的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 <code>Copy</code>特征，一个旧的变量在被赋值给其他变量后仍然可用。</p>
<p>那么什么类型是可<code>Copy</code> 的呢？可以查看给定类型的文档来确认，不过作为一个通用的规则:<strong>任何基本类型的组合可以是 <code>Copy</code> 的，不需要分配内存或某种形式资源的类型是 <code>Copy</code> 的</strong>。如下是一些 <code>Copy</code> 的类型：</p>
<ul>
<li>所有整数类型，比如 <code>u32</code>。</li>
<li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li>
<li>所有浮点数类型，比如 <code>f64</code>。</li>
<li>字符类型，<code>char</code>。</li>
<li>元组，当且仅当其包含的类型也都是 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 是 <code>Copy</code> 的，但 <code>(i32, String)</code> 就不是。</li>
</ul>
<h2 id="函数传值与返回"><a class="header" href="#函数传值与返回">函数传值与返回</a></h2>
<p>将值传递给函数，一样会发生<code>移动</code>或者<code>复制</code>，就跟<code>let</code>语句一样，下面的代码展示了所有权、作用域的规则：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = String::from(&quot;hello&quot;);  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!(&quot;{}&quot;, some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!(&quot;{}&quot;, some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
</code></pre></pre>
<p>你可以尝试在<code>takes_ownership</code>之后，再使用<code>s</code>，看看如何报错？例如添加一行<code>println!(&quot;在move进函数后继续使用s: {}&quot;,s);</code>。</p>
<p>同样的，函数返回值也有所有权，例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 移给 s1

    let s2 = String::from(&quot;hello&quot;);     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                        // takes_and_gives_back 中,
                                        // 它也将返回值移给 s3
} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 移出作用域并被丢弃

fn gives_ownership() -&gt; String {             // gives_ownership 将返回值移动给
                                             // 调用它的函数

    let some_string = String::from(&quot;hello&quot;); // some_string 进入作用域.

    some_string                              // 返回 some_string 并移出给调用的函数
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string 进入作用域

    a_string  // 返回 a_string 并移出给调用的函数
}
</code></pre></pre>
<p>所有权很强大，避免了内存的不安全性，但是也带来了一个新麻烦: <strong>总是把一个值传来传去来使用它</strong>。 传入一个函数，很可能还要从该函数传出去，结果就是语言表达变得非常啰嗦，幸运的是，Rust提供了新功能解决这个问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="引用与借用"><a class="header" href="#引用与借用">引用与借用</a></h1>
<p>上节中提到，如果仅仅支持通过转移所有权的方式获取一个值，那会让程序变得复杂。 Rust能否像其它编程语言一样，使用某个变量的指针或者引用呢？答案是可以。</p>
<p>Rust通过<code>借用(Borrowing)</code>这个概念来达成上述的目的: <strong>获取变量的引用，称之为借用(borrowing)</strong>。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来，当使用完毕后，也必须要物归原主.</p>
<h3 id="引用与解引用"><a class="header" href="#引用与解引用">引用与解引用</a></h3>
<p>常规引用是一个指针类型，指向了对象存储的内存地址。在下面代码中，我们创建一个<code>i32</code>值的引用<code>y</code>，然后使用解引用运算符来解出<code>y</code>所使用的值:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p>变量 <code>x</code> 存放了一个 <code>i32</code> 值 <code>5</code>。<code>y</code>是 <code>x</code> 的一个引用。可以断言 <code>x</code> 等于 <code>5</code>。然而，如果希望对 <code>y</code> 的值做出断言，必须使用 <code>*y</code> 来解出引用所指向的值（也就是 <strong>解引用</strong>）。一旦解引用了 <code>y</code>，就可以访问 <code>y</code> 所指向的整型值并可以与 <code>5</code> 做比较。</p>
<p>相反如果尝试编写 <code>assert_eq!(5, y);</code>，则会得到如下编译错误：</p>
<pre><code class="language-text">error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}` // 无法比较整数类型和引用类型
  |
  = help: the trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` is not implemented for
  `{integer}`
</code></pre>
<p>不允许比较整数与引用，因为它们是不同的类型。必须使用解引用运算符解出引用所指向的值。</p>
<h3 id="不可变引用"><a class="header" href="#不可变引用">不可变引用</a></h3>
<p>下面的代码，我们用s1的引用作为参数传递给<code>calculate_length</code>函数，而不是把s1的所有权转移给该函数：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>能注意到两点：</p>
<ol>
<li>无需像上章一样：先通过函数参数传入所有权，然后再通过函数返回来传出所有权，代码更加简洁</li>
<li><code>calculate_length</code>的参数<code>s</code>类型从<code>String</code>变为<code>&amp;String</code></li>
</ol>
<p>这里，<code>&amp;</code>符号即是引用，它们允许你使用值，但是不获取所有权，如图所示：
<img alt="&String s pointing at String s1" src="basic/ownership//img/borrowing-01.svg" class="center" /></p>
<p>通过<code>&amp;s1</code>语法，我们创建了一个<strong>指向s1的引用</strong>，但是并不拥有它。因为并不拥有这个值，当引用离开作用域后，其指向的值也不会被丢弃。</p>
<p>同理，函数<code>calculate_length</code>使用<code>&amp;</code>来表明参数<code>s</code>的类型是一个引用：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s 是对 String 的引用
    s.len()
} // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，
  // 所以什么也不会发生
<span class="boring">}
</span></code></pre></pre>
<p>人总是贪心的，可以拉女孩小手了，就想着抱抱柔软的身子(读者中的某老司机表示，这个流程完全不对)，因此光借用已经满足不了我们了，如果尝试修改借用的变量呢？</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = String::from(&quot;hello&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<p>很不幸，妹子你没抱到, 哦口误，你修改错了：</p>
<pre><code class="language-console">error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut String`
                           ------- 帮助：考虑将该参数类型修改为可变的引用: `&amp;mut String`
8 |     some_string.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
                     `some_string`是一个`&amp;`类型的引用，因此它指向的数据无法进行修改
</code></pre>
<p>正如变量默认不可变一样，引用指向的值默认也是不可变的，没事，来一起看看如果解决这个问题。</p>
<h3 id="可变引用"><a class="header" href="#可变引用">可变引用</a></h3>
<p>只需要一个小调整，即可修复上面代码的错误：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<p>首先，声明<code>s</code>是可变类型，其次创建一个可变的引用<code>&amp;mut s</code>和接受可变引用的函数<code>some_string: &amp;mut String</code>。</p>
<h5 id="可变引用同时只能存在一个"><a class="header" href="#可变引用同时只能存在一个">可变引用同时只能存在一个</a></h5>
<p>不过可变引用并不是随心所欲、想用就用的，它有一个很大的限制：同一作用域，特定数据只能有一个可变引用:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;

println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}
</span></code></pre></pre>
<p>以上代码会报错：</p>
<pre><code class="language-console">error[E0499]: cannot borrow `s` as mutable more than once at a time 同一时间无法对`s`进行两次可变借用
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here 首个可变引用在这里借用
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here 第二个可变引用在这里借用
6 |     
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here 第一个借用在这里使用
</code></pre>
<p>这段代码出错的原因在于，第一个可变借用<code>r1</code>必须要持续到最后一次使用的位置<code>println!</code>，在<code>r1</code>创建和最后一次使用之间，我们又尝试创建第二个可变引用<code>r2</code>。</p>
<p>对于新手来说，这个特性绝对是一大拦路虎，也是新人们谈之色变的编译器<code>borrow checker</code>特性之一，不过各行各业都一样，限制往往是出于安全的考虑，Rust也一样。</p>
<p>这种限制的好处就是使Rust在编译期就避免数据竞争，数据竞争可由以下行为造成：</p>
<ul>
<li>两个或更多的指针同时访问同一数据</li>
<li>至少有一个指针被用来写入数据</li>
<li>没有同步数据访问的机制</li>
</ul>
<p>数据竞争会导致未定义行为，这种行为很可能超出我们的预期，难以在运行时追踪，并且难以诊断和修复。而Rust避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！</p>
<p>很多时候，大括号可以帮我们解决一些编译不通过的问题，通过手动限制变量的作用域：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

{
    let r1 = &amp;mut s;

} // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用

let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<h5 id="可变引用与不可变引用不能同时存在"><a class="header" href="#可变引用与不可变引用不能同时存在">可变引用与不可变引用不能同时存在</a></h5>
<p>下面的代码会导致一个错误：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;s; // 没问题
let r2 = &amp;s; // 没问题
let r3 = &amp;mut s; // 大问题

println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
<span class="boring">}
</span></code></pre></pre>
<p>错误如下：</p>
<pre><code class="language-console">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable 无法借用可变`s`因为它已经被借用了不可变
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // 没问题
  |              -- immutable borrow occurs here 不可变借用发生在这里
5 |     let r2 = &amp;s; // 没问题
6 |     let r3 = &amp;mut s; // 大问题
  |              ^^^^^^ mutable borrow occurs here 可变借用发生在这里
7 |     
8 |     println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here 不可变借用在这里使用
</code></pre>
<p>其实这个也很好理解，正在借用不可变引用的用户，肯定不希望他借用的东西，被另外一个人莫名其妙改变了。多个不可变借用被允许是因为没有人会去试图修改数据，每个人都只读这一份数据而不做修改，因此不用担心数据被污染。</p>
<blockquote>
<p>注意，引用的作用域s从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号<code>}</code></p>
</blockquote>
<p>Rust的编译器一直在优化，早期的时候，引用的作用域跟变量作用域是一致的，这对日常使用带来了很大的困扰，你必须非常小心的去安排可变、不可变变量的借用，免得无法通过编译，例如以下代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; 
    let r2 = &amp;s; 
    println!(&quot;{} and {}&quot;, r1, r2);
    // 新编译器中，r1,r2作用域在这里结束

    let r3 = &amp;mut s; 
    println!(&quot;{}&quot;, r3);
} // 老编译器中，r1、r2、r3作用域在这里结束
  // 新编译器中，r3作用域在这里结束
</code></pre></pre>
<p>在老版本的编译器中（Rust 1.31前），将会报错，因为<code>r1</code>和<code>r2</code>的作用域在花括号<code>}</code>处结束，那么<code>r3</code>的借用就会触发<strong>无法同时借用可变和不可变</strong>的规则。</p>
<p>但是在新的编译器中，该代码将顺利通过，因为<strong>引用作用域的结束位置从花括号变成最后一次使用的位置</strong>,因此<code>r1</code>借用和<code>r2</code>借用在<code>println!</code>后，就结束了，此时<code>r3</code>可以顺利借用到可变引用。</p>
<h4 id="nll"><a class="header" href="#nll">NLL</a></h4>
<p>对于这种编译器优化行为，Rust专门起了一个名字 - Non-Lexical Lifetimes(NLL)，专门用于找到某个引用在作用域(<code>}</code>)结束前就不再被使用的代码位置。</p>
<p>虽然这种借用错误有的时候会让我们很郁闷，但是你只要想想这是Rust提前帮你发现了潜在的bug，其实就开心了，虽然减慢了开发速度，但是从长期来看，大幅减少了后续开发和运维成本.</p>
<h3 id="悬垂引用dangling-references"><a class="header" href="#悬垂引用dangling-references">悬垂引用（Dangling References）</a></h3>
<p>悬垂引用也叫做悬垂指针，指的是指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。在 Rust 中编译器可以确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器可以确保数据不会在其引用之前被释放，要想释放数据，必须先停止其引用的使用。</p>
<p>让我们尝试创建一个悬垂引用，Rust会抛出一个编译时错误：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre></pre>
<p>这里是错误：</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                ~~~~~~~~

</code></pre>
<p>错误信息引用了一个我们还未介绍的功能：生命周期（lifetimes）。<a href="basic/ownership/../../advance/lifetime.html">该章</a>会详细介绍生命周期。不过，即使你不理解生命周期，也可以通过错误信息知道这段代码错误的关键信息：</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value for it to be borrowed from.
该函数返回了一个借用的值，但是已经找不到它所借用值的来源
</code></pre>
<p>仔细看看 <code>dangle</code> 代码的每一步到底发生了什么：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dangle() -&gt; &amp;String { // dangle 返回一个字符串的引用

    let s = String::from(&quot;hello&quot;); // s 是一个新字符串

    &amp;s // 返回字符串 s 的引用
} // 这里 s 离开作用域并被丢弃。其内存被释放。
  // 危险！
<span class="boring">}
</span></code></pre></pre>
<p>因为 <code>s</code> 是在 <code>dangle</code> 函数内创建的，当 <code>dangle</code> 的代码执行完毕后，<code>s</code> 将被释放, 但是此时我们又尝试去返回它的引用。这意味着这个引用会指向一个无效的 <code>String</code>，这可不对！</p>
<p>其中一个很好的解决方法是直接返回 <code>String</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
<span class="boring">}
</span></code></pre></pre>
<p>这样就没有任何错误了，最终<code>String</code>的<strong>所有权被转移给外面的调用者</strong>。</p>
<h2 id="借用规则总结"><a class="header" href="#借用规则总结">借用规则总结</a></h2>
<p>总的来说，借用规则如下：</p>
<ul>
<li>同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用</li>
<li>引用必须总是有效的</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="复合类型"><a class="header" href="#复合类型">复合类型</a></h1>
<p>行百里者半五十，欢迎大家来到这里，虽然还不到中点，但是已经不远了。如果说之前学的基础数据类型是原子，那么本章将讲的数据类型可以认为是分子。</p>
<p>本章的重点在复合类型上，顾名思义，复合类型是由其它类型组合而成的，最典型的就是结构体<code>struct</code>和枚举<code>enum</code>。例如平面上的一个点<code>point(x,y)</code>，它由两个数值类型的值<code>x</code>和<code>y</code>组合而来。我们不想单独去维护这两个数值，因为单独一个<code>x</code>或者<code>y</code>是含义不完整的，无法标识平面上的一个点，应该把它们看作一个整体去理解和处理。</p>
<p>来看一段代码，它使用我们之前学过的内容来构建文件操作：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![allow(unused_variables)]
type File = String;

fn open(f: &amp;mut File) -&gt; bool {
    true
}
fn close(f: &amp;mut File) -&gt; bool {
    true
}

#[allow(dead_code)]
fn read(f: &amp;mut File, save_to: &amp;mut Vec&lt;u8&gt;) -&gt; ! {
    unimplemented!()
}

fn main() {
    let mut f1 = File::from(&quot;f1.txt&quot;);
    open(&amp;mut f1);
    //read(&amp;mut f1, &amp;mut vec![]);
    close(&amp;mut f1);
}
</code></pre></pre>
<p>接下来我们的学习非常类似原型设计：有的方法只提供API接口，但是不提供具体实现。此外，有的变量在声明之后并未使用，因此在这个阶段我们需要排除一些编译器噪音（Rust在编译的时候会扫描代码，变量声明后未使用会以<code>warning</code>警告的形式进行提示），引入<code>#![allow(unused_variables)]</code>属性标记，该标记会告诉编译器忽略未使用的变量，不要抛出<code>warning</code>警告,具体的常见编译器属性你可以在这里查阅：<a href="basic/compound-type/../../compiler/attributes.html">编译器属性标记</a>.</p>
<p><code>read</code>函数也非常有趣，它返回一个<code>!</code>，这个表明该函数是一个发散函数，不会返回任何值，包括<code>()</code>。<code>unimplemented!()</code>告诉编译器该函数尚未实现，<code>unimplemented!()</code>标记通常意味着我们期望快速完成主要代码，回头再通过搜索这些标记来完成次要代码，类似的标记还有<code>todo!()</code>，当代码执行到这种未实现的地方时，程序会直接报错: 你可以反注释<code>read(&amp;mut f1, &amp;mut vec![]);</code>这行，然后再观察下结果。</p>
<p>同时，从代码设计角度来看，关于文件操作的类型和函数应该组织在一起，散落得到处都是，是难以管理和使用的。而且通过<code>open(&amp;mut f1)</code>进行调用，也远没有使用<code>f1.open()</code>来调用好，这就体现出了只使用基本类型得局限性：<strong>无法从更高的抽象层次去简化代码</strong>。</p>
<p>接下来，我们将引入一个高级数据结构 - 结构体<code>struct</code>，来看看复合类型是怎样更好的解决这类问题。 开始之前，先来看看Rust的重点也是难点：字符串<code>String</code>和<code>&amp;str</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串"><a class="header" href="#字符串">字符串</a></h1>
<p>在其他语言，字符串往往是送分题，因为实在是太简单了，例如<code>&quot;hello, world&quot;</code>就是字符串章节的几乎全部内容了，对吧？如果你带着这样的想法来学Rust，我保证，绝对会栽跟头，<strong>因此这一章大家一定要重视，仔细阅读，这里有很多其它Rust书籍中没有的内容</strong>。</p>
<p>首先来看段很简单的代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  let my_name = &quot;Pascal&quot;;
  greet(my_name);
}

fn greet(name: String) {
  println!(&quot;Hello, {}!&quot;, name);
}
</code></pre></pre>
<p><code>greet</code>函数接受一个字符串类型的<code>name</code>参数，然后打印到终端控制台中，非常好理解，你们猜猜，这段代码能否通过编译？</p>
<pre><code class="language-conole">error[E0308]: mismatched types
 --&gt; src/main.rs:3:11
  |
3 |     greet(my_name);
  |           ^^^^^^^
  |           |
  |           expected struct `std::string::String`, found `&amp;str`
  |           help: try using a conversion method: `my_name.to_string()`

error: aborting due to previous error
</code></pre>
<p>Bingo，果然报错了，编译器提示<code>greet</code>函数需要一个<code>String</code>类型的字符串，却传入了一个<code>&amp;str</code>类型的字符串，相信读者心中现在一定有几头草泥马呼啸而过，怎么字符串也能整出这么多花活？</p>
<p>在讲解字符串之前，先来看看什么是切片?</p>
<h2 id="切片slice"><a class="header" href="#切片slice">切片(slice)</a></h2>
<p>切片并不是Rust独有的概念，在Go语言中就非常流行，它允许你引用集合中部分连续的元素序列，而不是引用整个集合。</p>
<p>对于字符串而言，切片就是对<code>String</code>类型中某一部分的引用，它看起来像这样：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello world&quot;);

let hello = &amp;s[0..5];
let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<p><code>hello</code>没有引用整个<code>String s</code>，而是引用了<code>s</code>的一部分内容，通过<code>[0..5]</code>的方式来指定。</p>
<p>这就是创建切片的语法，使用方括号包括的一个序列: <strong>[开始索引..终止索引]</strong>，其中开始索引是切片中第一个元素的索引位置，而终止索引是最后一个元素后面的索引位置，也就是这是一个<code>右半开区间</code>。在切片数据结构内部会保存开始的位置和切片的长度，其中长度是通过<code>终止索引</code> - <code>开始索引</code>的方式计算得来的。</p>
<p>对于<code>let world = &amp;s[6..11];</code>来说，<code>world</code>是一个切片，该切片的指针指向<code>s</code>的第7个字节(索引从0开始,6是第7个字节)，且该切片的长度是<code>5</code>个字节。</p>
<img alt="" src="basic/compound-type//img/string-01.svg" class="center" style="width: 50%;" />
<p>在使用Rust的<code>..</code><a href="basic/compound-type/../base-type/numbers.html#%E5%BA%8F%E5%88%97(Range)">range序列</a>语法时，如果你想从索引0开始，可以使用如下的方式，这两个是等效的：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<p>同样的，如果你的切片想要包含<code>String</code>的最后一个字节，则可以这样使用:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[4..len];
let slice = &amp;s[4..];
<span class="boring">}
</span></code></pre></pre>
<p>你也可以截取完整的<code>String</code>切片：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>在对字符串使用切片语法时需要格外小心，切片的索引必须落在字符之间的边界位置，也就是UTF8字符的边界，例如中文在UTF8中占用三个字节,下面的代码就会崩溃:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let s = &quot;中国人&quot;;
 let a = &amp;s[0..2];
 println!(&quot;{}&quot;,a);
<span class="boring">}
</span></code></pre></pre>
<p>因为我们只取<code>s</code>字符串的前两个字节，但是一个中文占用三个字节，因此没有落在边界处，也就是连<code>中</code>字都取不完整，此时程序会直接崩溃退出，如果改成<code>&amp;a[0..3]</code>，则可以正常通过编译.
因此，当你需要对字符串做切片索引操作时，需要格外小心这一点, 关于该如何操作UTF8字符串，参见<a href="basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9CUTF8%E5%AD%97%E7%AC%A6%E4%B8%B2">这里</a></p>
</blockquote>
<p>字符串切片的类型标识是<code>&amp;str</code>，因此我们可以这样声明一个函数，输入<code>String</code>类型，返回它的切片: <code>fn first_word(s: &amp;String) -&gt; &amp;str </code>.</p>
<p>有了切片就可以写出这样的安全代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // error!

    println!(&quot;the first word is: {}&quot;, word);
}
</code></pre></pre>
<p>编译器报错如下：</p>
<pre><code class="language-console">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!(&quot;the first word is: {}&quot;, word);
   |                                       ---- immutable borrow later used here
</code></pre>
<p>回忆一下借用的规则：当我们已经有了可变借用时，就无法再拥有不可变的借用。因为<code>clear</code>需要清空改变<code>String</code>，因此它需要一个可变借用，而之后的<code>println!</code>又使用了不可变借用，因此编译无法通过。</p>
<p>从上述代码可以看出，Rust不仅让我们的<code>API</code>更加容易使用，而且也在编译期就消除了大量错误！</p>
<h4 id="其它切片"><a class="header" href="#其它切片">其它切片</a></h4>
<p>因为切片是对集合的部分引用，因此不仅仅字符串有切片，其它集合类型也有，例如数组:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}
</span></code></pre></pre>
<p>该数组切片的类型是<code>&amp;[i32]</code>，数组切片和字符串切片的工作方式是一样的，例如持有一个引用指向原始数组的某个元素和长度。</p>
<h2 id="字符串字面量是切片"><a class="header" href="#字符串字面量是切片">字符串字面量是切片</a></h2>
<p>之前提到过字符串字面量,但是没有提到它的类型：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>实际上，<code>s</code>的类型是<code>&amp;str</code>，因此你也可以这样声明：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;str = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>该切片指向了程序可执行文件中的某个点，这也是为什么字符串字面量是不可变的，因为<code>&amp;str</code>是一个不可变引用。</p>
<p>了解完切片，可以进入本节的正题了。</p>
<h2 id="什么是字符串"><a class="header" href="#什么是字符串">什么是字符串?</a></h2>
<p>顾名思义，字符串是由字符组成的连续集合，但是在上一节中我们提到过，<strong>Rust中的字符是Unicode类型，因此每个字符占据4个字节内存空间，但是在字符串中不一样，字符串是UTF8编码，也就是字符所占的字节数是变长的(1-4)</strong>，这样有助于大幅降低字符串所占用的内存空间.</p>
<p>Rust在语言级别，只有一种字符串类型：<code>str</code>，它通常是以引用类型出现<code>&amp;str</code>，也就是上文提到的字符串切片。虽然语言级别只有上述的<code>str</code>类型，但是在标准库里，还有多种不同用途的字符串类型，其中使用最广的即是<code>String</code>类型。</p>
<p><code>str</code>类型是硬编码进可执行文件，也无法被修改，但是<code>String</code>则是一个可增长、可改变且具有所有权的UTF8编码字符串，<strong>当Rust用户提到字符串时，往往指的就是<code>String</code>类型和<code>&amp;str</code>字符串切片类型，这两个类型都是UTF8编码</strong>.</p>
<p>除了<code>String</code>类型的字符串，Rust的标准库还提供了其他类型的字符串，例如<code>OsString</code>,<code>OsStr</code>,<code>CsString</code>和<code>CsStr</code>等，注意到这些名字都以<code>String</code>或者<code>Str</code>结尾了吗？它们分别对应的是具有所有权和被借用的变量。</p>
<h4 id="操作字符串"><a class="header" href="#操作字符串">操作字符串</a></h4>
<p>由于String是可变字符串，因此我们可以对它进行创建、增删操作，下面的代码汇总了相关的操作方式：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // 创建一个空String
    let mut s = String::new();
    // 将&amp;str类型的&quot;hello,world&quot;添加到s中
    s.push_str(&quot;hello,world&quot;);
    // 将字符'!'推入s中
    s.push('!');
    // 最后s的内容是&quot;hello,world!&quot;
    assert_eq!(s,&quot;hello,world!&quot;);

    // 从现有的&amp;str切片创建String类型
    let mut s = &quot;hello,world&quot;.to_string();
    // 将字符'!'推入s中
    s.push('!');
    // 最后s的内容是&quot;hello,world!&quot;
    assert_eq!(s,&quot;hello,world!&quot;);

    // 从现有的&amp;str切片创建String类型
    // String与&amp;str都是UTF8编码，因此支持中文
    let mut s = String::from(&quot;你好,世界&quot;);
    // 将字符'!'推入s中
    s.push('!');
    // 最后s的内容是&quot;hello,world!&quot;
    assert_eq!(s,&quot;你好,世界!&quot;);

    let s1 = String::from(&quot;hello,&quot;);
    let s2 = String::from(&quot;world!&quot;);
    // 在下句中，s1的所有权被转移走了，因此后面不能再使用s1
    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
    assert_eq!(s3,&quot;hello,world!&quot;);
    // 下面的语句如果去掉注释，就会报错
    // println!(&quot;{}&quot;,s1);
}
</code></pre></pre>
<p>在上面代码中，有一处需要解释的地方，就是使用<code>+</code>来对字符串进行相加操作， 这里之所以使用<code>s1 + &amp;s2</code>的形式，是因为<code>+</code>使用了<code>add</code>方法，该方法的定义类似:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(self, s: &amp;str) -&gt; String {
<span class="boring">}
</span></code></pre></pre>
<p>因为该方法涉及到更复杂的特征功能，因此我们这里简单说明下，<code>self</code>是<code>String</code>类型的字符串<code>s1</code>,该函数说明，只能将<code>&amp;str</code>类型的字符串切片添加到<code>String</code>类型的<code>s1</code>上，然后返回一个新的<code>String</code>类型，所以<code>let s3 = s1 + &amp;s2;</code>就很好解释了，将<code>String</code>类型的<code>s1</code>与<code>&amp;str</code>类型的<code>s2</code>进行相加，最终得到<code>String</code>类型的s3.</p>
<p>由此可推，以下代码也是合法的：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

// String = String + &amp;str + &amp;str + &amp;str + &amp;str
let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}
</span></code></pre></pre>
<p><code>String</code> + <code>&amp;str</code>返回一个<code>String</code>，然后再继续跟一个<code>&amp;str</code>进行<code>+</code>操作，返回一个<code>String</code>类型，不断循环，最终生成一个<code>s</code>，也是<code>String</code>类型。</p>
<p>在上面代码中，我们做了一个有些难以理解的<code>&amp;String</code>操作，下面来展开讲讲。</p>
<h2 id="string与str的转换"><a class="header" href="#string与str的转换">String与&amp;str的转换</a></h2>
<p>在之前的代码中，已经见到好几种从<code>&amp;str</code>类型生成<code>String</code>类型的操作：</p>
<ul>
<li><code>String::from(&quot;hello,world&quot;)</code></li>
<li><code>&quot;hello,world&quot;.to_string()</code></li>
</ul>
<p>那么如何将<code>String</code>类型转为<code>&amp;str</code>类型呢？答案很简单，取引用即可：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = String::from(&quot;hello,world!&quot;);
    say_hello(&amp;s);
    say_hello(&amp;s[..]);
    say_hello(s.as_str());
}

fn say_hello(s: &amp;str) {
    println!(&quot;{}&quot;,s);
}
</code></pre></pre>
<p>实际上这种灵活用法是因为<code>deref</code>隐式强制转换，具体我们会在<a href="basic/compound-type/../../traits/deref.html">Deref特征</a>进行详细讲解。</p>
<h2 id="字符串索引"><a class="header" href="#字符串索引">字符串索引</a></h2>
<p>在其它语言中，使用索引的方式访问字符串的某个字符或者子串是很正常的行为，但是在Rust中就会报错:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   let s1 = String::from(&quot;hello&quot;);
   let h = s1[0];
<span class="boring">}
</span></code></pre></pre>
<p>该代码会产生如下错误：</p>
<pre><code class="language-console">3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index&lt;{integer}&gt;` is not implemented for `String`
</code></pre>
<h4 id="深入字符串内部"><a class="header" href="#深入字符串内部">深入字符串内部</a></h4>
<p>字符串的底层的数据存储格式实际上是[u8]，一个字节数组。对于<code>let hello = String::from(&quot;Hola&quot;);</code>这行代码来说，<code>hello</code>的长度是<code>4</code>个字节，因为<code>&quot;hola&quot;</code>中的每个字母在UTF8编码中仅占用1个字节，但是对于下面的代码呢?</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = String::from(&quot;中国人&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>如果问你该字符串多长，你可能会说<code>3</code>，但是实际上是<code>9</code>个字节的长度，因为每个汉字在UTF8中的长度是<code>3</code>个字节，因此这种情况下对<code>hello</code>进行索引
访问<code>&amp;hello[0]</code>没有任何意义，因为你取不到<code>中</code>这个字符，而是取到了这个字符三个字节中的第一个字节，这是一个非常奇怪而且难以理解的返回值。</p>
<h4 id="字符串的不同表现形式"><a class="header" href="#字符串的不同表现形式">字符串的不同表现形式</a></h4>
<p>现在看一下用梵文写的字符串<code>“नमस्ते”</code>, 它底层的字节数组如下形式：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
<span class="boring">}
</span></code></pre></pre>
<p>长度是18个字节，这也是计算机最终存储该字符串的形式。如果从字符的形式去看，则是：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>['न', 'म', 'स', '्', 'त', 'े']
<span class="boring">}
</span></code></pre></pre>
<p>但是这种形式下，第四和六两个字母根本就不存在，没有任何意义，接着再从字母串的形式去看：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
<span class="boring">}
</span></code></pre></pre>
<p>所以，可以看出来Rust提供了不同的字符串展现方式，这样程序可以挑选自己想要的方式去使用，而无需去管字符串从人类语言角度看长什么样。</p>
<p>还有一个原因导致了Rust不允许去索引字符：因为索引操作，我们总是期望它的性能表现是O(1)，然而对于<code>String</code>类型来说，无法保证这一点，因为Rust可能需要从0开始去遍历字符串来定位合法的字符。</p>
<h2 id="字符串切片"><a class="header" href="#字符串切片">字符串切片</a></h2>
<p>前文提到过，字符串切片是非常危险的操作，因为切片的索引是通过字节来进行，但是字符串又是UTF8编码，因此你无法保证索引的字节刚好落在字符的边界上，例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;中国人&quot;;

let s = &amp;hello[0..2];
<span class="boring">}
</span></code></pre></pre>
<p>运行上面的程序，会直接造成崩溃：</p>
<pre><code class="language-console">thread 'main' panicked at 'byte index 2 is not a char boundary; it is inside '中' (bytes 0..3) of `中国人`', src/main.rs:4:14
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>这里提示的很清楚，我们索引的字节落在了<code>中</code>字符的内部，这种返回没有任何意义。</p>
<p>因此在通过索引区间来访问字符串时，需要格外的小心，一不注意，就会导致你程序的崩溃！</p>
<h2 id="操作utf8字符串"><a class="header" href="#操作utf8字符串">操作UTF8字符串</a></h2>
<p>前文提到了几种使用UTF8字符串的方式，下面来一一说明。</p>
<h4 id="字符"><a class="header" href="#字符">字符</a></h4>
<p>如果你想要以Unicode字符的方式遍历字符串，最好的办法是使用<code>chars</code>方法，例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;中国人&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
<span class="boring">}
</span></code></pre></pre>
<p>输出如下</p>
<pre><code class="language-console">中
国
人
</code></pre>
<h4 id="字节"><a class="header" href="#字节">字节</a></h4>
<p>这种方式是返回字符串的底层字节数组表现形式：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;中国人&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
<span class="boring">}
</span></code></pre></pre>
<p>输出如下：</p>
<pre><code class="language-console">228
184
173
229
155
189
228
186
186
</code></pre>
<h4 id="获取子串"><a class="header" href="#获取子串">获取子串</a></h4>
<p>想要准确的从UTF8字符串中获取子串是较为复杂的事情，例如想要从<code>holla中国人नमस्ते</code>这种变长的字符串中取出某一个子串，使用标准库你是做不到的，
你需要在<code>crates.io</code>上搜索<code>utf8</code>来寻找想要的功能。</p>
<p>可以考虑尝试下这个库:<a href="https://crates.io/crates/utf8_slice">utf8_slice</a>.</p>
<h2 id="字符串深度剖析"><a class="header" href="#字符串深度剖析">字符串深度剖析</a></h2>
<p>那么问题来了，为啥<code>String</code>可变，而字符串字面值<code>str</code>却不可以？</p>
<p>就字符串字面值来说，我们在编译时就知道其内容，最终字面值文本被直接硬编码进可执行文件中，这使得字符串字面值快速且高效，这主要得益于字符串的不可变性。不幸的是，我们不能为了获得这种性能，而把每一个在编译时大小未知的文本都放进内存中(你也做不到！)，因为有的字符串是在程序运行得过程中动态生成的。</p>
<p>对于 <code>String</code> 类型，为了支持一个可变、可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容，这些都是在程序运行时完成的：</p>
<ul>
<li>首先向操作系统请求内存来存放<code>String</code>对象</li>
<li>在使用完成后，将内存释放，归还给操作系统</li>
</ul>
<p>其中第一个由<code>String::from</code>完成，它创建了一个全新的String.</p>
<p>重点来了，到了第二部分，就是百家齐放的环节，在有<strong>垃圾回收GC</strong>的语言中，GC来负责标记并清除这些不再使用的内存对象，这个过程都是自动完成，无需开发者关心，非常简单好用；但是在无GC的语言，需要开发者手动去释放这些内存对象，就像创建对象需要通过编写代码来完成一样，未能正确释放对象造成的结局简直不可估量.</p>
<p>对于Rust而言，安全和性能是写到骨子里的核心特性，如果使用GC，那么会牺牲性能；如果使用手动管理内存，那么会牺牲安全，这该怎么办？为此，Rust的开发者想出了一个无比惊艳的办法：变量在离开作用域后，就自动释放其占用的内存:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from(&quot;hello&quot;); // 从此处起，s 是有效的

    // 使用 s
}                                  // 此作用域已结束，
                                   // s 不再有效，内存被释放
<span class="boring">}
</span></code></pre></pre>
<p>与其它系统编程语言的<code>free</code>函数相同，Rust也提供了一个释放内存的函数:<code>drop</code>，但是不同的是，其它语言要手动调用<code>free</code>来释放每一个变量占用的内存，而Rust则在变量离开作用域时，自动调用<code>drop</code>函数: 上面代码中，Rust 在结尾的 <code>}</code> 处自动调用 <code>drop</code>。</p>
<blockquote>
<p>其实，在 C++ 中，也有这种概念: <em>Resource Acquisition Is Initialization (RAII)</em>。如果你使用过 RAII 模式的话应该对 Rust 的 <code>drop</code> 函数并不陌生</p>
</blockquote>
<p>这个模式对编写 Rust 代码的方式有着深远的影响，在后面章节我们会进行更深入的介绍。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元组"><a class="header" href="#元组">元组</a></h1>
<p>元组是由多种类型组合到一起形成的，因此它是复合类型，元组的长度是固定的，元组中元素的顺序也是固定的。</p>
<p>可以通过以下语法创建一个元组：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>变量<code>tup</code>被绑定了一个元组值<code>(500, 6.4, 1)</code>，该元组的类型是<code>(i32, f64, u8)</code>，看到没？元组是用括号将多个类型组合到一起，简单吧？</p>
<p>可以使用模式匹配或者<code>.</code>操作符来获取元组中的值。</p>
<h3 id="用模式匹配解构元组"><a class="header" href="#用模式匹配解构元组">用模式匹配解构元组</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>上述代码首先创建一个元组，然后将其绑定到<code>tup</code>上，接着使用<code>let (x, y, z) = tup;</code>来完成一次模式匹配，因为元组是<code>(n1,n2,n3)</code>形式的，因此我们用一模一样的<code>(x,y,z)</code>形式来进行匹配，元组中对应的值会绑定到变量<code>x</code>，<code>y</code>，<code>z</code>上。这就是解构：用同样的形式把一个复杂对象中的值匹配出来。</p>
<h3 id="用来访问元组"><a class="header" href="#用来访问元组">用<code>.</code>来访问元组</a></h3>
<p>模式匹配可以让我们一次性把元组中的值全部或者部分获取出来，如果只想要访问某个特定元素，那模式匹配就略显繁琐，对此，Rust提供了<code>.</code>的访问方式：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<p>和其它语言的数组、字符串一样，元组的索引从0开始。</p>
<h3 id="元组的使用示例"><a class="header" href="#元组的使用示例">元组的使用示例</a></h3>
<p>元组在函数返回值场景很常用，例如下面的代码，可以使用元组返回多个值:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() 返回字符串的长度

    (s, length)
}
</code></pre></pre>
<p><code>calculate_length</code>函数接收<code>s1</code>字符串的所有权，然后计算字符串的长度，接着把字符串所有权和字符串长度再返回给<code>s2</code>和<code>len</code>变量。</p>
<p>在其他语言中，可以用结构体来声明一个三维空间中的点，例如<code>Point(10,20,30)</code>，虽然使用Rust元组也可以做到：<code>(10,20,30)</code>，但是这样写有个非常重大的缺陷：</p>
<p><strong>不具备任何清晰的含义</strong>，在下一章节中，会提到一种与元组类似的结构体，<code>元组结构体</code>，可以解决这个问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体"><a class="header" href="#结构体">结构体</a></h1>
<p>上一节中提到需要一个更高级的数据结构来帮助我们更好的抽象问题，结构体<code>struct</code>恰恰就是这样的复合数据结构，它是由其它数据类型组合而来。 其它语言也有类似的数据结构，不过可能有不同的名称，例如<code>object</code>、<code>record</code>等。</p>
<p>结构体跟之前讲过的<a href="basic/compound-type/./tuple.html">元组</a>有些相像：都是由多种类型组合而成。但是与元组不同的是，结构体可以为内部的每个字段起一个富有含义的名称。因此结构体更加灵活更加强大，你无需依赖这些字段的顺序来访问和解析它们。</p>
<h2 id="结构体语法"><a class="header" href="#结构体语法">结构体语法</a></h2>
<p>天下无敌的剑士往往也因为他有一柄无双之剑，既然结构体这么强大，那么我们就需要给它配套一套强大的语法，让用户能更好的驾驭。</p>
<h4 id="定义结构体"><a class="header" href="#定义结构体">定义结构体</a></h4>
<p>一个结构体有几部分组成：</p>
<ul>
<li>通过关键字<code>struct</code>定义</li>
<li>一个清晰明确的结构体<code>名称</code></li>
<li>几个有名字的结构体<code>字段</code></li>
</ul>
<p>例如以下结构体定义了某网站的用户：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">}
</span></code></pre></pre>
<p>该结构体名称是<code>User</code>，拥有4个字段，且每个字段都有对应的字段名及类型声明，例如<code>username</code>代表了用户名，是一个可变的<code>String</code>类型。</p>
<h4 id="创建结构体实例"><a class="header" href="#创建结构体实例">创建结构体实例</a></h4>
<p>为了使用上述结构体，我们需要创建<code>User</code>结构体的<strong>实例</strong>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };
<span class="boring">}
</span></code></pre></pre>
<p>有几点值得注意:</p>
<ol>
<li>初始化实例时，<strong>每个字段</strong>都需要进行初始化</li>
<li>初始化时的字段顺序不需要和结构体定义时的顺序一致</li>
</ol>
<h4 id="访问结构体字段"><a class="header" href="#访问结构体字段">访问结构体字段</a></h4>
<p>通过<code>.</code>操作符即可访问结构体实例内部的字段值，也可以修改它们：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from(&quot;anotheremail@example.com&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>需要注意的是，必须要将结构体实例声明为可变的，才能修改其中的字段，Rust不支持将某个结构体某个字段标记为可变.</p>
<h4 id="简化结构体创建"><a class="header" href="#简化结构体创建">简化结构体创建</a></h4>
<p>下面的函数类似一个构建函数，返回了<code>User</code>结构体的实例：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>它接收两个字符串参数：<code>email</code>和<code>username</code>，然后使用它们来创建一个<code>User</code>结构体，并且返回。可以注意到这两行：<code>email: email</code>和<code>username: username</code>，非常的扎眼，因为实在有些啰嗦，如果你从typescript过来，肯定会鄙视Rust一番，不过好在，它也不是无可救药:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如上所示，当函数参数和结构体字段同名时，可以直接使用缩略的方式进行初始化，跟<code>typescript</code>中一模一样.</p>
<h4 id="结构体更新语法"><a class="header" href="#结构体更新语法">结构体更新语法</a></h4>
<p>在实际场景中，有一种情况很常见：根据已有的结构体实例，创建新的结构体实例，例如根据已有的<code>user1</code>实例来构建<code>user2</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from(&quot;another@example.com&quot;),
        sign_in_count: user1.sign_in_count,
    };
<span class="boring">}
</span></code></pre></pre>
<p>老话重提，如果你从typescript过来，肯定觉得啰嗦爆了：竟然手动把<code>user1</code>的三个字段逐个赋值给<code>user2</code>，好在Rust为我们提供了<code>结构体更新语法</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        ..user1
    };
<span class="boring">}
</span></code></pre></pre>
<p>因为<code>user2</code>仅仅在<code>email</code>上与<code>user1</code>不同，因此我们只需要对<code>email</code>进行赋值，剩下的通过结构体更新语法<code>..user1</code>即可完成。</p>
<p><code>..</code>语法表明凡是我们没有显示声明的字段，全部从<code>user1</code>中自动获取。需要注意的是<code>..user1</code>必须在结构体的尾部使用。</p>
<blockquote>
<p>结构体更新语法跟赋值语句<code>=</code>非常相像，因此在上面代码中，<code>user1</code>的部分字段所有权被转移到<code>user2</code>中：<code>username</code>字段发生了所有权转移,作为结果，<code>user1</code>无法再被使用。</p>
<p>聪明的读者肯定要发问了：明明有三个字段进行了自动赋值，为何只有<code>username</code>发生了所有权转移？</p>
<p>仔细回想一下<a href="basic/compound-type/../ownership/ownership.html#%E6%8B%B7%E8%B4%9D(%E6%B5%85%E6%8B%B7%E8%B4%9D)">所有权</a>那一节的内容，我们提到了Copy特征：实现了Copy特征的类型无需所有权转移，可以直接在赋值时进行
数据拷贝，其中<code>bool</code>和<code>u64</code>类型就实现了<code>Copy</code>特征，因此<code>active</code>和<code>sign_in_count</code>字段在赋值给user2时，仅仅发生了拷贝，而不是所有权转移.</p>
<p>值得注意的是：<code>username</code>所有权被转移给了<code>user2</code>,导致了<code>user1</code>无法再被使用，但是并不代表<code>user1</code>内部的其它字段不能被继续使用，例如:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">fn main() {
</span>let user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};
let user2 = User {
    active: user1.active,
    username: user1.username,
    email: String::from(&quot;another@example.com&quot;),
    sign_in_count: user1.sign_in_count,
};
println!(&quot;{}&quot;, user1.active);
// 下面这行会报错
println!(&quot;{:?}&quot;, user1);
<span class="boring">}
</span></code></pre></pre>
<h2 id="结构体的内存排列"><a class="header" href="#结构体的内存排列">结构体的内存排列</a></h2>
<p>先来看以下代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
 struct File {
   name: String,
   data: Vec&lt;u8&gt;,
 }
 
 fn main() {
   let f1 = File {
     name: String::from(&quot;f1.txt&quot;),
     data: Vec::new(),
   };
 
   let f1_name = &amp;f1.name;
   let f1_length = &amp;f1.data.len();
 
   println!(&quot;{:?}&quot;, f1);
   println!(&quot;{} is {} bytes long&quot;, f1_name, f1_length);
 }
</code></pre></pre>
<p>上面定义的<code>File</code>结构体在内存中的排列如下图所示：
<img alt="" src="basic/compound-type//img/struct-01.png" class="center"  /></p>
<p>从图中可以清晰的看出<code>File</code>结构体两个字段<code>name</code>和<code>data</code>分别拥有底层两个<code>[u8]</code>数组的所有权(<code>String</code>类型的底层也是<code>[u8]</code>数组)，通过<code>ptr</code>指针指向底层数组的内存地址,这里你可以把<code>ptr</code>指针理解为Rust中的引用类型。</p>
<p>该图片也侧面印证了：<strong>把结构体中具有所有权的字段转移出去后，将无法再访问该字段，但是可以正常访问其它的字段</strong>.</p>
<h2 id="元组结构体tuple-struct"><a class="header" href="#元组结构体tuple-struct">元组结构体(Tuple Struct)</a></h2>
<p>结构体必须要有名称，但是结构体的字段可以没有名称，这种结构体长得很像元组，因此被称为元组结构体，例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);

    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
<span class="boring">}
</span></code></pre></pre>
<p>元组结构体在你希望有一个整体名称，但是又不关心里面字段的名称时将非常有用。例如上面的<code>Point</code>元组结构体，众所周知3D点是<code>(x,y,z)</code>形式的坐标点，因此我们无需再为内部的字段逐一命名为：<code>x</code>,<code>y</code>,<code>z</code>。</p>
<h2 id="元结构体unit-like-struct"><a class="header" href="#元结构体unit-like-struct">元结构体(Unit-like Struct)</a></h2>
<p>还记得之前讲过的基本没啥用的<a href="basic/compound-type/../base-type/char-bool.html#%E5%85%83%E7%B1%BB%E5%9E%8B">元类型</a>吧? 元结构体就跟它很像，没有任何字段和属性，但是好在，它还挺有用。</p>
<p>如果你定义一个类型，但是不关心该类型的内容, 只关心它的行为时，就可以使用<code>元结构体</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AlwaysEqual;

let subject = AlwaysEqual;

// 我们不关心为AlwaysEqual的字段数据，只关心它的行为，因此将它声明为元结构体，然后再为它实现某个特征
impl SomeTrait for AlwaysEqual {
    
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="结构体数据的所有权"><a class="header" href="#结构体数据的所有权">结构体数据的所有权</a></h2>
<p>在之前的<code>User</code> 结构体的定义中，有一处细节：我们使用了自身拥有所有权的 <code>String</code> 类型而不是基于引用的<code>&amp;str</code> 字符串切片类型。这是一个有意而为之的选择，因为我们想要这个结构体拥有它所有的数据，而不是从其它地方借用数据。</p>
<p>你也可以让<code>User</code>结构体从其它对象借用数据，不过这么做，就需要引入<strong>生命周期</strong>这个新概念(也是一个复杂的概念)，简而言之，生命周期能确保结构体的作用范围要比它所借用的数据的作用范围要小。</p>
<p>总之，如果你想在结构体中使用一个引用，就必须加上生命周期，否则就会报错：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre></pre>
<p>编译器会抱怨它需要生命周期标识符：</p>
<pre><code class="language-console">error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:2:15
  |
2 |     username: &amp;str,
  |               ^ expected named lifetime parameter // 需要一个生命周期
  |
help: consider introducing a named lifetime parameter // 考虑像下面的代码这样引入一个生命周期
  |
1 ~ struct User&lt;'a&gt; {
2 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:12
  |
3 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     username: &amp;str,
3 ~     email: &amp;'a str,
  |
</code></pre>
<p>未来在<a href="basic/compound-type/../../advance/lifetime/basic.html">生命周期</a>中会讲到如何修复这个问题以便在结构体中存储引用，不过在那之前，我们会避免在结构体中使用引用类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<p>枚举(enum或enumeration)允许你通过列举可能的成员来定义一个<strong>枚举类型</strong>，例如扑克牌花色：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum PokerSuit {
  Clubs,
  Spades,
  Diamonds,
  Hearts,
}
<span class="boring">}
</span></code></pre></pre>
<p>如果在此之前你没有在其它语言中使用过枚举，那么可能需要花费一些时间来理解这些概念，一旦上手，就会发现枚举的强大，甚至对它爱不释手，枚举虽好，可不要滥用哦。</p>
<p>再回到之前创建的<code>PokerSuit</code>，扑克总共有四种花色，而这里我们枚举出所有的可能值，这也正是<code>枚举</code>名称的由来。</p>
<p>任何一张扑克，它的花色肯定会落在四种花色中，而且也只会落在其中一个花色上，这种特性非常适合枚举的使用，因为<strong>枚举值</strong>只可能是其中某一个成员。抽象来看，四种花色尽管是不同的花色，但是它们都是扑克花色这个概念，因此当某个函数处理扑克花色时，可以把它们当作相同的类型进行传参。</p>
<p>细心的读者应该注意到，我们对之前的<code>枚举类型</code>和<code>枚举值</code>进行了重点标注，这是因为对于新人来说容易混淆相应的概念，总而言之：
<strong>枚举类型是一个类型，它会包含所有可能的枚举成员, 而枚举值是该类型中的具体某个成员的实例。</strong></p>
<h2 id="枚举值"><a class="header" href="#枚举值">枚举值</a></h2>
<p>现在来创建<code>PokerSuit</code>枚举类型的两个成员实例:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let heart = PokerSuit::Hearts;
let diamond = PokerSuit::Diamonds;
<span class="boring">}
</span></code></pre></pre>
<p>我们通过<code>::</code>操作符来访问<code>PokerSuit</code>下的具体成员，从代码可以清晰看出，<code>heart</code>和<code>diamond</code>都是<code>PokerSuit</code>枚举类型的，接着可以定义一个函数来使用它们：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let heart = PokerSuit::Hearts;
    let diamond = PokerSuit::Diamonds;

    print_suit(heart);
    print_suit(diamond);
}

fn print_suit(card: PokerSuit) {
    println!(&quot;{:?}&quot;,card);
}
</code></pre></pre>
<p><code>print_suit</code>函数的参数类型是<code>PokerSuit</code>，因此我们可以把<code>heart</code>和<code>diamond</code>传给它，虽然<code>heart</code>是基于<code>PokerSuit</code>下的<code>Hearts</code>成员实例化的，但是它是货真价实的<code>PokerSuit</code>枚举类型。</p>
<p>接下来，我们想让扑克牌变得更加实用，那么需要给每张牌赋予一个值：<code>A</code>(1)-<code>K</code>(13)，这样再加上花色，就是一张真实的扑克牌了，例如红心A。</p>
<p>目前来说，枚举值还不能带有值，因此先用结构体来实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum PokerSuit {
    Clubs,
    Spades,
    Diamonds,
    Hearts,
}

struct PokerCard {
    suit: PokerSuit,
    value: u8
}

fn main() {
   let c1 = PokerCard {
       suit: PokerSuit::Clubs,
       value: 1,
   };
   let c2 = PokerCard {
       suit: PokerSuit::Diamonds,
       value: 12,
   };
}
</code></pre></pre>
<p>这段代码很好的完成了它的使命，通过结构体<code>PokerCard</code>来代表一张牌，结构体的<code>suit</code>字段表示牌的花色，类型是<code>PokerSuit</code>枚举类型，<code>value</code>字段代表扑克牌的数值。</p>
<p>可以吗？可以！好吗？说实话，不咋地，因为还有简洁得多的方式来实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum PokerCard {
    Clubs(u8),
    Spades(u8),
    Diamonds(u8),
    Hearts(u8),
}

fn main() {
   let c1 = PokerCard::Spades(5);
   let c2 = PokerCard::Diamonds(13);
}
</code></pre></pre>
<p>直接将数据信息关联到枚举成员上，省去近一半的代码，这种实现是不是更优雅？</p>
<p>不仅如此，同一个枚举类型下的不同成员还能持有不同的数据类型，例如让某些花色打印<code>1-13</code>的字样，另外的花色打印上<code>A-K</code>的字样:</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum PokerCard {
    Clubs(u8),
    Spades(u8),
    Diamonds(char),
    Hearts(char),
}

fn main() {
   let c1 = PokerCard::Spades(5);
   let c2 = PokerCard::Diamonds('A');
}
</code></pre></pre>
<p>回想一下，遇到这种不同类型的情况，再用我们之前的结构体实现方式，可行吗？也许可行，但是会复杂很多。</p>
<p>再来看一个来自标准库中的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<p>这个例子跟我们之前的扑克牌很像，只不过枚举成员包含的类型更复杂了，变成了结构体：分别通过<code>Ipv4Addr</code>和<code>Ipv6Addr</code>来定义两种不同的IP数据。</p>
<p>从这些例子可以看出，<strong>任何类型的数据都可以放入枚举成员中</strong>: 例如字符串、数值、结构体甚至另一个枚举。</p>
<p>增加一些挑战？先看以下代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let m1 = Message::Quit;
    let m2 = Message::Move{x:1,y:1};
    let m3 = Message::ChangeColor(255,255,0);
}
</code></pre></pre>
<p>该枚举类型代表一条消息，它包含四个不同的成员:</p>
<ul>
<li><code>Quit</code> 没有任何关联数据</li>
<li><code>Move</code> 包含一个匿名结构体</li>
<li><code>Write</code> 包含一个<code>String</code>字符串</li>
<li><code>ChangeColor</code>包含三个<code>i32</code></li>
</ul>
<p>当然，我们也可以用结构体的方式来定义这些消息：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct QuitMessage; // 元结构体
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // 元组结构体
struct ChangeColorMessage(i32, i32, i32); // 元组结构体
<span class="boring">}
</span></code></pre></pre>
<p>由于每个结构体都有自己的类型，因此我们无法在需要同一类型的地方进行使用，例如某个函数它的功能是接受消息并进行发送，那么用枚举的方式，就可以接收不同的消息，但是用结构体，该函数无法接受4个不同的结构体作为参数。</p>
<p>而且从代码规范角度来看，枚举的实现更简洁，代码内聚性更强，不像结构体的实现，分散在各个地方。</p>
<h2 id="同一化类型"><a class="header" href="#同一化类型">同一化类型</a></h2>
<p>最后，再用一个实际项目中的简化片段，来结束枚举类型的语法学习。</p>
<p>例如我们有一个web服务，需要接受用户的长连接，假设连接有两种：<code>TcpStream</code>和<code>TlsStream</code>，但是我们希望对这两个连接的处理流程相同，也就是用同一个函数来处理这两个连接，代码如下:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>func new (stream: TcpStream) {
  let mut s = stream;
  if tls {
    s = negotiate_tls(stream)
  }
  
  // websocket是一个WebSocket&lt;TcpStream&gt;或者
  //   WebSocket&lt;native_tls::TlsStream&lt;TcpStream&gt;&gt;类型
  websocket = WebSocket::from_raw_socket(
    stream, ......)
}
<span class="boring">}
</span></code></pre></pre>
<p>此时，枚举类型就能帮上大忙：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Websocket {
  Tcp(Websocket&lt;TcpStream&gt;),
  Tls(Websocket&lt;native_tls::TlsStream&lt;TcpStream&gt;&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="option枚举用于处理空值"><a class="header" href="#option枚举用于处理空值">Option枚举用于处理空值</a></h2>
<p>在其它编程语言中，往往都有一个<code>null</code>关键字，该关键字用于表明一个变量当前的值为空(不是零值，例如整形的零值是0)，也就是不存在值。当你对这些<code>null</code>进行操作时，例如调用一个方法，就会直接抛出null异常，导致程序的崩溃，因此我们在编程时需要格外的小心去处理这些<code>null</code>空值。</p>
<blockquote>
<p>Tony Hoare，null的发明者，曾经说过一段非常有名的话</p>
<p>我称之为我十亿美元的错误。当时，我在使用一个面向对象语言设计第一个综合性的面向引用的类型系统。我的目标是通过编译器的自动检查来保证所有引用的使用都应该是绝对安全的。不过在设计过程中，我未能抵抗住诱惑，引入了空引用的概念，因为它非常容易实现。就是因为这个决策，引发了无数错误、漏洞和系统崩溃，在之后的四十多年中造成了数十亿美元的苦痛和伤害。</p>
</blockquote>
<p>尽管如此，空值的表达依然非常有意义，因为空值表示当前时刻变量的值是缺失的。有鉴于此，Rust吸取了众多教训，决定抛弃<code>null</code>,而改为使用<code>Option</code>枚举变量来表述这种结果。</p>
<p><code>Option</code>枚举包含两个成员，一个成员表示含有值:<code>Some(T)</code>, 另一个表示没有值: <code>None</code>，定义如下:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>其中<code>T</code>是泛型参数，<code>Some(T)</code>表示该枚举成员的数据类型是<code>T</code>, 换句话说，<code>Some</code>可以包含任何类型的数据。</p>
<p><code>Option&lt;T&gt;</code> 枚举是如此有用以至于它甚至被包含在了<code>prelude</code>(prelude属于Rust标准库，Rust会将最常用的类型、函数等提前引入其中，避免我们再手动引入)之中，你不需要将其显式引入作用域。另外，它的成员<code>Some</code> 和 <code>None</code>也是如此，无需使用<code>Option::</code>前缀就可直接使用<code>Some</code> 和 <code>None</code>。总之，不能因为<code>Some(T)</code>和<code>None</code>中没有<code>Option::</code>的身影，就否认它们是<code>Option</code>下的卧龙凤雏。</p>
<p>再来看以下代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let some_number = Some(5);
let some_string = Some(&quot;a string&quot;);

let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<p>如果使用 <code>None</code> 而不是 <code>Some</code>，需要告诉 Rust <code>Option&lt;T&gt;</code> 是什么类型的，因为编译器只通过 <code>None</code> 值无法推断出 <code>Some</code> 成员保存的值的类型。</p>
<p>当有一个 <code>Some</code> 值时，我们就知道存在一个值，而这个值保存在 <code>Some</code> 中。当有个 <code>None</code> 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。那么，<code>Option&lt;T&gt;</code> 为什么就比空值要好呢？</p>
<p>简而言之，因为 <code>Option&lt;T&gt;</code> 和 <code>T</code>（这里 <code>T</code> 可以是任何类型）是不同的类型，例如，这段代码不能编译，因为它尝试将 <code>Option&lt;i8&gt;</code>(<code>Option&lt;T&gt;</code>) 与 <code>i8</code>(<code>T</code>) 相加：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
<span class="boring">}
</span></code></pre></pre>
<p>如果运行这些代码，将得到类似这样的错误信息：</p>
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
 --&gt;
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
</code></pre>
<p>很好！事实上，错误信息意味着 Rust 不知道该如何将 <code>Option&lt;i8&gt;</code> 与 <code>i8</code> 相加，因为它们的类型不同。当在 Rust 中拥有一个像 <code>i8</code> 这样类型的值时，编译器确保它总是有一个有效的值，我们可以放心使用而无需做空值检查。只有当使用 <code>Option&lt;i8&gt;</code>（或者任何用到的类型）的时候才需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。</p>
<p>换句话说，在对 <code>Option&lt;T&gt;</code> 进行 <code>T</code> 的运算之前必须将其转换为 <code>T</code>。通常这能帮助我们捕获到空值最常见的问题之一：期望某值不为空但实际上为空的情况。</p>
<p>不再担心会错误的使用一个空值，会让你对代码更加有信心。为了拥有一个可能为空的值，你必须要显式的将其放入对应类型的 <code>Option&lt;T&gt;</code> 中。接着，当使用这个值时，必须明确的处理值为空的情况。只要一个值不是 <code>Option&lt;T&gt;</code> 类型，你就 <strong>可以</strong> 安全的认定它的值不为空。这是 Rust 的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加 Rust 代码的安全性。</p>
<p>那么当有一个 <code>Option&lt;T&gt;</code> 的值时，如何从 <code>Some</code> 成员中取出 <code>T</code> 的值来使用它呢？<code>Option&lt;T&gt;</code> 枚举拥有大量用于各种情况的方法：你可以查看<a href="https://doc.rust-lang.org/std/option/enum.Option.html">它的文档</a>。熟悉 <code>Option&lt;T&gt;</code> 的方法将对你的 Rust 之旅非常有用。</p>
<p>总的来说，为了使用 <code>Option&lt;T&gt;</code> 值，需要编写处理每个成员的代码。你想要一些代码只当拥有 <code>Some(T)</code> 值时运行，允许这些代码使用其中的 <code>T</code>。也希望一些代码在值为 <code>None</code> 时运行，这些代码并没有一个可用的 <code>T</code> 值。<code>match</code> 表达式就是这么一个处理枚举的控制流结构：它会根据枚举的成员运行不同的代码，这些代码可以使用匹配到的值中的数据。</p>
<p>这里先简单看一下<code>match</code>的大致模样，在<a href="basic/compound-type/../match-pattern/intro.html">模式匹配</a>中，我们会详细讲解:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<p><code>plus_one</code>通过<code>match</code>来处理不同<code>Option</code>的情况。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<p>在日常开发中，使用最广的数据结构之一就是数组，在Rust中，最常用的数组有两种，第一种是速度很快但是长度固定的<code>array</code>，第二种是可动态增长的但是有性能损耗的<code>Vector</code>，在本书中，我们称<code>array</code>为数组，<code>Vector</code>为动态数组。</p>
<p>不知道你们发现没，这两个数组的关系跟<code>&amp;str</code>与<code>String</code>的关系很像，前者是长度固定的字符串切片，后者是可动态增长的字符串。其实，在Rust中无论是<code>String</code>还是<code>Vector</code>，它们都是Rust的高级类型：集合类型，在后面章节会有详细介绍。</p>
<p>对于本章节，我们的重点还是放在数组<code>array</code>上。数组的具体定义很简单：将多个类型相同的元素依次组合在一起，就是一个数组。结合上面的内容，可以得出数组的三要素：</p>
<ul>
<li>长度固定</li>
<li>元素必须有相同的类型</li>
<li>依次线性排列</li>
</ul>
<p>这里再啰嗦一句，<strong>我们这里说的数组是Rust的基本类型，是固定长度的，这点与其他编程语言不同，其它编程语言的数组往往是可变长度的，与Rust中的动态数组<code>Vector</code>类似</strong>，希望读者大大牢记此点。</p>
<h3 id="创建数组"><a class="header" href="#创建数组">创建数组</a></h3>
<p>在Rust中，数组是这样定义的：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>数组语法跟<code>javascript</code>很像，也跟大多数编程语言很像。由于它的元素类型大小固定，且长度也是固定，因此<strong>数组是存储在栈上</strong>，性能也会非常优秀。与此对应，动态数组<code>Vector</code>是存储在堆上，因此长度可以动态改变。当你不确定是使用数组还是动态数组时，那就应该使用后者，具体见<a href="basic/compound-type/../collections/vector.html">动态数组Vector</a>一章.</p>
<p>举个例子，在需要知道一年中各个月份名称的程序中，你很可能希望使用的是数组而不是动态数组。因为月份是固定的，它总是只包含 12 个元素：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
<span class="boring">}
</span></code></pre></pre>
<p>在一些时候，还需要为<strong>数组声明类型</strong>，如下所示：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>这里，数组类型是通过方括号语法声明，<code>i32</code>是元素类型，分号后面的数字<code>5</code>是数组长度，数组类型也从侧面说明了<strong>数组的元素类型要统一，长度要固定</strong>.</p>
<p>还可以使用下面的语法初始化一个<strong>某个值重复出现N次的数组</strong>： </p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<p><code>a</code>数组包含<code>5</code>个元素，这些元素的初始化值为<code>3</code>，聪明的读者已经发现，这种语法跟数组类型的声明语法其实是保持一致的：<code>[3;5]</code> 和<code>[类型;长度]</code>.</p>
<p>在元素重复的场景，这种写法要简单的多，否则你就得疯狂敲击键盘：<code>let a = [3, 3, 3, 3, 3];</code>，不过老板可能很喜欢你的这种疯狂编程的状态。</p>
<h3 id="访问数组元素"><a class="header" href="#访问数组元素">访问数组元素</a></h3>
<p>因为数组是连续存放元素的，因此可以通过索引的方式来访问存放其中的元素：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [9, 8, 7, 6, 5];

    let first = a[0]; // 获取a数组第一个元素
    let second = a[1]; // 获取第二个元素
}
</code></pre></pre>
<p>与许多语言类似，数组的索引下标是从0开始的。此处，<code>first</code>获取到的值是<code>9</code>，<code>second</code>是<code>8</code>。</p>
<h4 id="越界访问"><a class="header" href="#越界访问">越界访问</a></h4>
<p>如果使用超出数组范围的索引访问数组元素，会怎么样？下面是一个接收用户的控制台输入，然后将其作为索引访问数组元素的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;Please enter an array index.&quot;);

    let mut index = String::new();
    // 读取控制台的输出
    io::stdin()
        .read_line(&amp;mut index)
        .expect(&quot;Failed to read line&quot;);

    let index: usize = index
        .trim()
        .parse()
        .expect(&quot;Index entered was not a number&quot;);

    let element = a[index];

    println!(
        &quot;The value of the element at index {} is: {}&quot;,
        index, element
    );
}
</code></pre></pre>
<p>使用<code>cargo run</code>来运行代码，因为数组只有5个元素，如果我们试图输入<code>5</code>去访问第<code>6</code>个元素，则会访问到不存在的数组元素，最终程序会崩溃退出：</p>
<pre><code class="language-console">Please enter an array index.
5
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 5', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>这就是数组访问越界，访问了数组中不存在的元素，导致Rust运行时错误。程序因此退出并显示错误消息，未执行最后的<code>println!</code>语句。</p>
<p>当你尝试使用索引访问元素时，Rust 将检查你指定的索引是否小于数组长度。如果索引大于或等于数组长度，Rust会出现 panic。这种检查只能在运行时进行，比如在上面这种情况下，编译器无法在编译期知道用户运行代码时将输入什么值。</p>
<p>这种就是Rust的安全特性之一。在很多系统编程语言中，并不会检查数组越界问题，你会访问到无效的内存地址获取到一个风马牛不相及的值，最终导致在程序逻辑上出现大问题，而且这种问题会非常难以检查。</p>
<h2 id="数组切片"><a class="header" href="#数组切片">数组切片</a></h2>
<p>在之前的<a href="basic/compound-type/./string-slice.html#%E5%88%87%E7%89%87(slice)">章节</a>，我们有讲到<code>切片</code>这个概念，它允许你引用集合中的部分连续片段，而不是整个集合，对于数组也是，数组切片允许我们引用数组的一部分：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];

let slice: &amp;[i32] = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}
</span></code></pre></pre>
<p>上面的数组切片<code>slice</code>的类型是<code>&amp;[i32]</code>，与之对比，数组的类型是<code>[i32;5]</code>，简单总结下切片的特点：</p>
<ul>
<li>切片的长度可以与数组不同，并不是固定的，而是取决于你使用时指定的起始和结束位置</li>
<li>创建切片的代价非常小，因为切片只是针对底层数组的一个引用</li>
<li>切片类型[T]拥有不固定的大小，而切片引用类型&amp;[T]则具有固定的大小，因为Rust很多时候都需要固定大小数据类型，因此&amp;[T]更有用,<code>&amp;str</code>字符串切片也同理</li>
</ul>
<h2 id="总结-3"><a class="header" href="#总结-3">总结</a></h2>
<p>最后，让我们以一个综合性使用数组的例子，来结束本章节的学习：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  // 编译器自动推导出one的类型
  let one             = [1, 2, 3];
  // 显式类型标注
  let two: [u8; 3]    = [1, 2, 3];
  let blank1          = [0; 3];
  let blank2: [u8; 3] = [0; 3];
    
  // arrays是一个二维数组，其中每一个元素都是一个数组，元素类型是[u8; 3]
  let arrays: [[u8; 3]; 4]  = [one, two, blank1, blank2];
  
  // 借用arrays的元素用作循环中
  for a in &amp;arrays {
    print!(&quot;{:?}: &quot;, a);
    // 将a变成一个迭代器，用于循环
    // 你也可以直接用for n in a {}来进行循环
    for n in a.iter() {
      print!(&quot;\t{} + 10 = {}&quot;, n, n+10);
    }
 
    let mut sum = 0;
    // 0..a.len,是一个Rust的语法糖，其实就等于一个数组，元素是从0,1,2一直增加到到a.len-1
    for i in 0..a.len() {
      sum += a[i];
    }
    println!(&quot;\t({:?} = {})&quot;, a, sum);
  }
}
</code></pre></pre>
<p>做个总结，数组虽然很简单，但是其实还是存在几个要注意的点：</p>
<ul>
<li><strong>数组类型容易跟数组切片混淆</strong>，[T;n]描述了一个数组的类型，而[T]描述了切片的类型， 因为切片是运行期的数据结构，它的长度无法在编译器得知，因此不能用[T;n]的形式去描述</li>
<li><code>[u8; 3]</code>和<code>[u8; 4]</code>是不同的类型，数组的长度也是类型的一部分</li>
<li><strong>在实际开发中，使用最多的是数组切片[T]</strong>，我们往往通过引用的方式去使用<code>&amp;[T]</code>，因为后者有固定的类型大小</li>
</ul>
<p>至此，关于数据类型部分，我们已经全部学完了，对于Rust学习而言，我们也迈出了坚定的第一步，后面将开始更高级特性的学习。未来如果大家有疑惑需要检索知识，一样可以继续回顾过往的章节，因为本书不仅仅是一门Rust的教程，还是一本厚重的Rust工具书。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="流程控制"><a class="header" href="#流程控制">流程控制</a></h1>
<p>80后应该都对学校的小混混记忆犹新，在那个时代，小混混们往往都认为自己是地下王者，管控着地下事务的流程，在我看来，他们就像代码中的流程控制一样，无处不在，很显眼，但是又让人懒得重视。</p>
<p>言归正传，Rust程序是从上而下顺序执行的，在此过程中，我们可以通过循环、分支等流程控制方式，更好的实现相应的功能。</p>
<h2 id="使用if来做分支控制"><a class="header" href="#使用if来做分支控制">使用if来做分支控制</a></h2>
<blockquote>
<p>if else无处不在 - <code>鲁迅说</code></p>
</blockquote>
<p>但凡你能找到一门编程语言没有<code>if else</code>，那么一定更要反馈给鲁迅，反正不是我说的:) 总之，只要你拥有其它语言的编程经验，就一定会有以下认知：<code>if else</code><strong>表达式</strong>根据条件执行不同的代码分支：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if condition == true {
    // A...
} else {
    // B...
}
<span class="boring">}
</span></code></pre></pre>
<p>该代码读作：若<code>condition</code>条件为<code>true</code>，则执行<code>A</code>代码，否则执行<code>B</code>代码。</p>
<p>先看下面代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre></pre>
<p>以上代码有以下几点要注意：</p>
<ul>
<li><strong><code>if</code>语句块是表达式</strong>，这里我们使用<code>if</code>表达式的返回值来给<code>number</code>进行赋值：<code>number</code>的值是<code>5</code>。</li>
<li>用<code>if</code>来赋值时，要保证每个分支返回的类型一样(事实上，这种说法不完全准确，见<a href="basic/../appendix/expressions.html#if%E8%A1%A8%E8%BE%BE%E5%BC%8F">这里</a>)，此处返回的<code>5</code>和<code>6</code>就是同一个类型，如果返回类型不一致就会报错</li>
</ul>
<pre><code class="language-console">error[E0308]: if and else have incompatible types
 --&gt; src/main.rs:4:18
  |
4 |       let number = if condition {
  |  __________________^
5 | |         5
6 | |     } else {
7 | |         &quot;six&quot;
8 | |     };
  | |_____^ expected integer, found &amp;str // 期望整数类型，但却发现&amp;str字符串切片
  |
  = note: expected type `{integer}`
             found type `&amp;str`
</code></pre>
<h4 id="使用else-if来处理多重条件"><a class="header" href="#使用else-if来处理多重条件">使用else if来处理多重条件</a></h4>
<p>可以将<code>else if</code>与<code>if</code>、<code>else</code>组合在一起实现更复杂的条件分支判断：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let n = 6;

    if n % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if n % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if n % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></pre>
<p>程序执行时，会按照自上至下的顺序执行每一个分支判断，一旦成功，则跳出<code>if</code>语句块，最终本程序会匹配执行<code>else if n % 3 == 0</code>的分支，输出<code>&quot;number is divisible by 3&quot;</code>。</p>
<p>有一点要注意，就算有多个分支能匹配，也只有第一个匹配的分支会被执行！</p>
<p>如果代码中有大量的<code>else if </code>会让代码变得极其丑陋，不过不用担心，下一章的<code>match</code>专门用以解决多分支模式匹配的问题。</p>
<h2 id="循环控制"><a class="header" href="#循环控制">循环控制</a></h2>
<p>循环无处不在，上到数钱，下到数年，你能想象的很多场景都存在循环，因此它也是流程控制中最重要的组成部分之一。</p>
<p>在Rust语言中有三种循环方式：<code>for</code>、<code>while</code>和<code>loop</code>，其中<code>for</code>循环是Rust循环王冠上的明珠。</p>
<h4 id="for循环"><a class="header" href="#for循环">for循环</a></h4>
<p><code>for</code>循环是Rust的大杀器：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    for i in 1..=5 {
        println!(&quot;{}&quot;,i);
    }
}
</code></pre></pre>
<p>以上代码循环输出一个从1到5的序列，简单粗暴，核心就在于<code>for</code>和<code>in</code>的联动，语义表达如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for 元素 in 集合 {
  // 使用元素干一些你懂我不懂的事情
}
<span class="boring">}
</span></code></pre></pre>
<p>这个语法跟<code>javascript</code>还蛮像，应该挺好理解。</p>
<p>注意，使用<code>for</code>时我们往往使用集合的引用形式，除非你不想在后面的代码中继续使用该集合（比如我们这里使用了container的引用）。如果不使用引用的话，所有权会被转移到<code>for</code>语句块中，后面就无法再使用这个集合了)：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for item in &amp;container {
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>如果想在循环中，<strong>修改该元素</strong>，可以使用<code>mut</code>关键字：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for item in &amp;mut collection {
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>总结如下：</p>
<table><thead><tr><th>使用方法</th><th>等价使用方式</th><th>所有权</th></tr></thead><tbody>
<tr><td><code>for item in collection</code></td><td><code>for item in IntoIterator::into_iter(collection)</code></td><td>转移所有权</td></tr>
<tr><td><code>for item in &amp;collection</code></td><td><code>for item in collection.iter()</code></td><td>不可变借用</td></tr>
<tr><td><code>for item in &amp;mut collection</code></td><td><code>for item in collection.iter_mut()</code></td><td>可变借用</td></tr>
</tbody></table>
<p>如果想在循环中<strong>获取元素的索引</strong>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [4,3,2,1];
    // `.iter()`方法把`a`数组变成一个迭代器
    for (i,v) in a.iter().enumerate() {
        println!(&quot;第{}个元素是{}&quot;,i+1,v);
    }
}
</code></pre></pre>
<p>有同学可能会想到，如果我们想用<code>for</code>循环控制某个过程执行10次，但是又不想单独声明一个变量来控制这个流程，该怎么写？</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for _ in 0..10 {
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>可以用<code>_</code>来替代<code>i</code>用于<code>for</code>循环中，在Rust中<code>_</code>的含义是忽略该值或者类型的意思，如果不使用<code>_</code>，那么编译器会给你一个<code>变量未使用的</code>的警告。</p>
<p><strong>两种循环方式优劣对比</strong></p>
<p>以下代码，使用了两种循环方式：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 第一种
let collection = [1, 2, 3, 4, 5];
for i in 0..collection.len() {
  let item = collection[i];
  // ...
}

// 第二种
for item in collection {

}
<span class="boring">}
</span></code></pre></pre>
<p>第一种方式是循环索引，然后通过索引下标去访问集合，第二种方式是直接循环集合中的元素，优劣如下：</p>
<ul>
<li><strong>性能</strong>：第一种使用方式中<code>collection[index]</code>的索引访问，会因为边界检查(bounds checking)导致运行时的性能损耗 - Rust会检查并确认<code>index</code>是否落在集合内，但是第二种直接迭代的方式就不会触发这种检查，因为编译器会在编译时就完成分析并证明这种访问是合法的</li>
<li><strong>安全</strong>：第一种方式里对<code>collection</code>的索引访问是非连续的，存在一定可能性在两次访问之间，<code>collection</code>发生了变化，导致脏数据产生。而第二种直接迭代的方式是连续访问，因此不存在这种风险（这里是因为所有权吗？是的话可能要强调一下）</li>
</ul>
<p>由于for循环无需任何条件限制，也不需要通过索引来访问，因此是最安全也是最常用的，通过与下面的<code>while</code>的对比，我们能看到为什么<code>for</code>会更加安全。</p>
<h4 id="continue"><a class="header" href="#continue"><code>continue</code></a></h4>
<p>使用<code>continue</code>可以跳过当前当次的循环，开始下次的循环：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> for i in 1..4 {
     if i == 2 {
         continue;
     }
     println!(&quot;{}&quot;,i);
 }
<span class="boring">}
</span></code></pre></pre>
<p>上面代码对1到3的序列进行迭代，且跳过值为2时的循环，输出如下：</p>
<pre><code class="language-console">1
3
</code></pre>
<h4 id="while循环"><a class="header" href="#while循环">while循环</a></h4>
<p>如果你需要一个条件来循环，当该条件为<code>true</code>时，继续循环，条件为<code>false</code>，跳出循环，那么<code>while</code>就非常适用: </p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut n = 0;

    while n &lt;= 5  {
        println!(&quot;{}!&quot;, n);

        n = n + 1;
    }

    println!(&quot;我出来了！&quot;);
}
</code></pre></pre>
<p>该<code>while</code>循环，只有当<code>n</code>小于等于<code>5</code>时，才执行，否则就立刻跳出循环，因此在上述代码中，它会先从<code>0</code>开始，满足条件，进行循环，然后是<code>1</code>，满足条件，进行循环，最终到<code>6</code>的时候，大于5，不满足条件，跳出<code>while</code>循环，执行<code>我出来了</code>的打印，然后程序结束：</p>
<pre><code class="language-console">0!
1!
2!
3!
4!
5!
我出来了！
</code></pre>
<p>当然，你也可以用其它方式组合实现，例如<code>loop</code>(无条件循环，将在下面介绍) + <code>if</code> + <code>break</code>： </p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut n = 0;

    loop {
        if n &gt; 5 {
            break
        }
        println!(&quot;{}&quot;,n);
        n+=1;
    }

    println!(&quot;我出来了！&quot;);
}
</code></pre></pre>
<p>可以看出，在这种循环场景下，<code>while</code>要简洁的多。</p>
<p><strong>while vs for</strong></p>
<p>我们也能用<code>while</code>来实现<code>for</code>的功能：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;the value is: {}&quot;, a[index]);

        index = index + 1;
    }
}
</code></pre></pre>
<p>这里，代码对数组中的元素进行计数。它从索引 <code>0</code> 开始，并接着循环直到遇到数组的最后一个索引（这时，<code>index &lt; 5</code> 不再为真）。运行这段代码会打印出数组中的每一个元素：</p>
<pre><code class="language-console">the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>数组中的所有五个元素都如期被打印出来。尽管 index 在某一时刻会到达值 5，不过循环在其尝试从数组获取第六个值（会越界）之前就停止了。</p>
<p>但这个过程很容易出错；如果索引长度不正确会导致程序 panic。这也使程序更慢，因为编译器增加了运行时代码来对每次循环的每个元素进行条件检查。</p>
<p><code>for</code>循环代码如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&quot;the value is: {}&quot;, element);
    }
}
</code></pre></pre>
<p>可以看出，<code>for</code>并不会使用索引去访问数组，因此更安全也更简洁，同时避免<code>运行时的边界检查</code>，性能更高。</p>
<h4 id="loop循环"><a class="header" href="#loop循环">loop循环</a></h4>
<p>对于循环而言，<code>loop</code>循环毋庸置疑，是适用面最高的，它可以适用于所有循环场景(虽然能用，但是在很多场景下，<code>for</code>和<code>while</code>才是最优选择)，因为loop就是一个简单的无限循环，你可以在内部实现逻辑通过<code>break</code>关键字来控制循环何时结束。</p>
<p>使用<code>loop</code>循环一定要打起精神，否则你会写出下面的跑满你一个cpu核心的疯子代码：</p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}
</code></pre>
<p>该循环会不停的在终端打印输出，直到你使用<code>Ctrl-C</code>结束程序：</p>
<pre><code class="language-console">again!
again!
again!
again!
^Cagain!
</code></pre>
<p><strong>注意</strong>，不要轻易尝试上述代码，如果你电脑配置不行，可能会死机！！！</p>
<p>因此，当使用<code>loop</code>时，必不可少的伙伴是<code>break</code>关键字，它能让循环在满足某个条件时跳出：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;The result is {}&quot;, result);
}
</code></pre></pre>
<p>以上代码当<code>counter</code>递增到<code>10</code>时，就会通过<code>break</code>返回一个<code>counter*2</code>的值，最后赋给<code>result</code>并打印出来。</p>
<p>这里有几点值得注意：</p>
<ul>
<li><strong>break可以单独使用，也可以带一个返回值</strong>，有些类似<code>return</code></li>
<li><strong>loop是一个表达式</strong>，因此可以返回一个值</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式匹配"><a class="header" href="#模式匹配">模式匹配</a></h1>
<p>模式匹配，这个词，对于非函数语言编程来说，真的还蛮少听到，因为它经常出现在函数式编程里，用于为复杂的类型系统提供一个轻松的解构能力。</p>
<p>曾记否？在枚举和流程控制那章，我们遗留了两个问题，都是关于<code>match</code>的，第一个是如何对<code>Option</code>枚举进行进一步处理，另外一个就是如何用<code>match</code>来替代<code>else if</code>这种丑陋的多重分支使用方式，那么让我们先一起来揭开<code>match</code>的神秘面纱。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match和if-let"><a class="header" href="#match和if-let">match和if let</a></h1>
<p>在Rust中，模式匹配最常用的就是<code>match</code>和<code>if let</code>，本章节将对两者及相关的概念进行详尽介绍。</p>
<p>先来看一个关于<code>match</code>的简单例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East =&gt; println!(&quot;East&quot;),
        Direction::North | Direction::South =&gt; {
            println!(&quot;South or North&quot;);
        },
        _ =&gt; println!(&quot;West&quot;),
    };
}
</code></pre></pre>
<p>这里我们想去匹配<code>dire</code>对应的枚举类型，因此在match中用三个匹配分支来完全覆盖枚举变量<code>Direction</code>的所有成员类型，有以下几点值得注意：</p>
<ul>
<li><code>match</code>的匹配必须要穷举出所有可能，因此这里用<code>_</code>来代表未列出的所有可能性</li>
<li><code>match</code>的每一个分支都必须是一个表达式，且所有分支的表达式最终返回值的类型必须相同</li>
<li><strong>X | Y</strong>，是逻辑运算符<code>或</code>，代表该分支可以匹配<code>X</code>也可以匹配<code>Y</code>，只要满足一个即可</li>
</ul>
<p>其实<code>match</code>跟其他语言中的<code>switch</code>非常像，<code>_</code>类似于<code>switch</code>中的<code>default</code>。</p>
<h2 id="match匹配"><a class="header" href="#match匹配"><code>match</code>匹配</a></h2>
<p>首先来看看<code>match</code>的通用形式：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match target {
    模式1 =&gt; 表达式1,
    模式2 =&gt; {
        语句1;
        语句2;
        表达式2;
    },
    _ =&gt; 表达式3
}
<span class="boring">}
</span></code></pre></pre>
<p>该形式清晰的说明了何为模式，何为模式匹配：将模式与<code>target</code>进行匹配，即为模式匹配，而模式匹配不仅仅局限于<code>match</code>，后面我们会详细阐述。</p>
<p><code>match</code>允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行对应的代码，下面让我们来一一详解，先看一个例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt;  {
            println!(&quot;Lucky penny!&quot;);
            1
        },
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>value_in_cents</code>函数根据匹配到的硬币，返回对应的美分数值，<code>match</code>后紧跟着的是一个表达式，跟<code>if</code>很像，但是<code>if</code>后的表达式必须是一个布尔值，而<code>match</code>后的表达式返回值可以是任意类型，只要能跟后面的分支中的模式匹配起来即可，这里的<code>coin</code>是枚举<code>Coin</code>类型。</p>
<p>接下来是<code>match</code>的分支。一个分支有两个部分：<strong>一个模式和针对该模式的处理代码</strong>。第一个分支的模式是<code>Coin::Penny</code>，其后的<code>=&gt;</code>运算符将模式和将要运行的代码分开。这里的代码就仅仅是表达式<code>1</code>，不同分支之间使用逗号分隔。</p>
<p>当<code>match</code>表达式执行时，它将目标值<code>coin</code>按顺序依次与每一个分支的模式相比较，如果模式匹配了这个值，那么模式之后的代码将被执行。如果模式并不匹配这个值，将继续执行下一个分支。</p>
<p>每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个 match 表达式的返回值。如果分支有多行代码，那么需要用<code>{}</code>包裹，同时最后一行代码需要是一个表达式。</p>
<h4 id="使用match表达式赋值"><a class="header" href="#使用match表达式赋值">使用<code>match</code>表达式赋值</a></h4>
<p>还有一点很重要，<code>match</code>本身也是一个表达式，因此可以用它来赋值：</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum IpAddr {
   Ipv4,
   Ipv6
}

fn main() {
    // let d_panic = Direction::South;
    let ip1 = IpAddr::Ipv6;
    let ip_str = match ip1 {
        IpAddr::Ipv4 =&gt; &quot;127.0.0.1&quot;,
        _ =&gt; &quot;::1&quot;,
    };

    println!(&quot;{}&quot;, ip_str);
}
</code></pre></pre>
<p>因为这里匹配到<code>_</code>分支，所以将<code>&quot;::1&quot;</code>赋值给了<code>ip_str</code>.</p>
<h4 id="模式绑定"><a class="header" href="#模式绑定">模式绑定</a></h4>
<p>模式匹配的另外一个重要功能是从模式中取出绑定的值，例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState), // 25美分硬币
}
<span class="boring">}
</span></code></pre></pre>
<p>其中<code>Coin::Quarter</code>成员还存放了一个值：美国的某个州（因为在1999年到2008年间，美国在25美分(Quarter)硬币的背后为50个州印刷了不同的标记，其它硬币都没有这样的设计）。</p>
<p>接下来，我们希望在模式匹配中，获取到25美分硬币上刻印的州的名称：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; { 
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面代码中，在匹配<code>Coin::Quarter(state)</code>模式时，我们把它内部存储的值绑定到了<code>state</code>变量上，因此<code>state</code>变量就是对应的<code>UsState</code>枚举类型。</p>
<p>例如有一个印了阿拉斯加州标记的25分硬币：<code>Coin::Quarter(UsState::Alaska))</code>, 它在匹配时，<code>state</code>变量将被绑定<code>UsState::Alaska</code>的枚举值。</p>
<p>再来看一个更复杂的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Action {
    Say(String),
    MoveTo(i32, i32),
    ChangeColorRGB(u16, u16, u16),
}

fn main() {
    let actions = [ 
        Action::Say(&quot;Hello Rust&quot;.to_string()),
        Action::MoveTo(1,2),
        Action::ChangeColorRGB(255,255,0),
    ];
    for action in actions {
        match action {
            Action::Say(s) =&gt; {
                println!(&quot;{}&quot;, s);
            },
            Action::MoveTo(x, y) =&gt; {
                println!(&quot;point from (0, 0) move to ({}, {})&quot;, x, y);
            },
            Action::ChangeColorRGB(r, g, _) =&gt; {
                println!(&quot;change color into '(r:{}, g:{}, b:0)', 'b' has been ignored&quot;,
                    r, g,
                );
            }
        }
    }
}
</code></pre></pre>
<p>运行后输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.16s
     Running `target/debug/world_hello`
Hello Rust
point from (0, 0) move to (1, 2)
change color into '(r:255, g:255, b:0)', 'b' has been ignored
</code></pre>
<h4 id="穷尽匹配"><a class="header" href="#穷尽匹配">穷尽匹配</a></h4>
<p>在文章的开头，我们简单总结过<code>match</code>的匹配必须穷尽所有情况，下面来举例说明，例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East =&gt; println!(&quot;East&quot;),
        Direction::North | Direction::South =&gt; {
            println!(&quot;South or North&quot;);
        },
    };
}
</code></pre></pre>
<p>我们没有处理<code>Direction::West</code>的情况，因此会报错：</p>
<pre><code class="language-console">error[E0004]: non-exhaustive patterns: `West` not covered // 非穷尽匹配，`West`没有被覆盖
  --&gt; src/main.rs:10:11
   |
1  | / enum Direction {
2  | |     East,
3  | |     West,
   | |     ---- not covered
4  | |     North,
5  | |     South,
6  | | }
   | |_- `Direction` defined here
...
10 |       match dire {
   |             ^^^^ pattern `West` not covered // 模式`West`没有被覆盖
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `Direction`
</code></pre>
<p>不禁想感叹，<code>Rust</code>的编译器真**强大，忍不住爆粗口了，sorry，如果你以后进一步深入使用Rust也会像我这样感叹的。Rust编译器清晰地知道<code>match</code>中有哪些分支没有被覆盖, 这种行为能强制我们处理所有的可能性，有效避免传说中价值十亿美金的<code>null</code>陷阱。</p>
<h4 id="_-通配符"><a class="header" href="#_-通配符"><code>_</code> 通配符</a></h4>
<p>当我们不想在匹配的时候列出所有值的时候，可以使用Rust提供的一个特殊<strong>模式</strong>，例如，<code>u8</code> 可以拥有 0 到 255 的有效的值，但是我们只关心 <code>1、3、5 和 7</code> 这几个值，不想列出其它的 <code>0、2、4、6、8、9 一直到 255</code> 的值。那么, 我们不必一个一个列出所有值, 因为可以使用使用特殊的模式 <code>_</code> 替代：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;one&quot;),
    3 =&gt; println!(&quot;three&quot;),
    5 =&gt; println!(&quot;five&quot;),
    7 =&gt; println!(&quot;seven&quot;),
    _ =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p>通过将<code>_</code>其放置于其他分支后，<code>_</code>将会匹配所有遗漏的值。<code>()</code>表示啥都不做的意思，所以当匹配到<code>_</code>后，什么也不会发生。</p>
<p>然后，在某些场景下，我们其实只关心<strong>某一个值是否存在</strong>，此时<code>match</code>就显得过于啰嗦。</p>
<h2 id="if-let匹配"><a class="header" href="#if-let匹配"><code>if let</code>匹配</a></h2>
<p>有时会遇到只有一个模式的值需要被处理，其它值直接忽略的场景，如果用<code>match</code>来处理就要写成下面这样：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v = Some(3u8);
    match v{
        Some(3) =&gt; println!(&quot;three&quot;),
        _ =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<p>我们只想要对 <code>Some(3)</code> 模式进行匹配, 不想处理任何其他 <code>Some&lt;u8&gt;</code> 值或 <code>None</code> 值。但是为了满足<code>match</code>表达式（穷尽性）的要求，写代码时必须在处理完这唯一的成员后加上 <code>_ =&gt; ()</code>，这样会增加不少无用的代码。</p>
<p>杀鸡焉用牛刀，可以用<code>if let</code>的方式来实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(3) = some_u8_value {
    println!(&quot;three&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>这两种匹配对于新手来说，可能有些难以抉择，但是只要记住一点就好：<strong>当你只要匹配一个条件，且忽略其他条件时就用<code>if let</code>，否则都用match</strong>。</p>
<h2 id="matches宏"><a class="header" href="#matches宏">matches!宏</a></h2>
<p>Rust标准库中提供了一个非常实用的宏:<code>matches!</code>，它可以将一个表达式跟模式进行匹配，然后返回匹配的结果<code>true</code> or <code>false</code>。</p>
<p>例如，有一个动态数组，里面存有以下枚举：</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum MyEnum {
    Foo,
    Bar
}

fn main() {
    let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];
}
</code></pre></pre>
<p>现在如果想对<code>v</code>进行过滤，只保留类型是<code>MyEnum::Foo</code>的元素，你可能想这么写：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>v.iter().filter(|x| x == MyEnum::Foo);
<span class="boring">}
</span></code></pre></pre>
<p>但是，实际上这行代码会报错，因为你无法将<code>x</code>直接跟一个枚举成员进行比较。好在，你可以使用<code>match</code>来完成，但是会导致代码更为啰嗦，是否有更简洁的方式？答案是使用<code>matches!</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>v.iter().filter(|x| matches!(x, MyEnum::Foo));
<span class="boring">}
</span></code></pre></pre>
<p>很简单也很简洁，再来看看更多的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = 'f';
assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));

let bar = Some(4);
assert!(matches!(bar, Some(x) if x &gt; 2));
<span class="boring">}
</span></code></pre></pre>
<h2 id="变量覆盖"><a class="header" href="#变量覆盖">变量覆盖</a></h2>
<p>无论是是<code>match</code>还是<code>if let</code>，他们都可以在模式匹配时覆盖掉老的值，绑定新的值:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let age = Some(30);
   println!(&quot;在匹配前，age是{:?}&quot;,age);
   if let Some(age) = age {
       println!(&quot;匹配出来的age是{}&quot;,age);
   }

   println!(&quot;在匹配后，age是{:?}&quot;,age);
}
</code></pre></pre>
<p><code>cargo run</code>运行后输出如下：</p>
<pre><code class="language-console">在匹配前，age是Some(30)
匹配出来的age是30
在匹配后，age是Some(30)
</code></pre>
<p>可以看出在<code>if let</code>中，<code>=</code>右边<code>Some(i32)</code>类型的<code>age</code>被左边<code>i32</code>类型的新<code>age</code>覆盖了，该覆盖一直持续到<code>if let</code>语句块的结束。因此第三个<code>println!</code>输出的<code>age</code>依然是<code>Some(i32)</code>类型。</p>
<p>对于<code>match</code>类型也是如此:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let age = Some(30);
   println!(&quot;在匹配前，age是{:?}&quot;,age);
   match age {
       Some(age) =&gt;  println!(&quot;匹配出来的age是{}&quot;,age),
       _ =&gt; ()
   }
   println!(&quot;在匹配后，age是{:?}&quot;,age);
}
</code></pre></pre>
<p>需要注意的是，<strong><code>match</code>中的变量覆盖其实不是那么的容易看出</strong>，因此要小心！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="解构option"><a class="header" href="#解构option">解构Option</a></h1>
<p>在枚举那章，提到过<code>Option</code>枚举，它用来解决Rust中变量是否有值的问题，定义如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>简单解释就是： <strong>一个变量要么有值:<code>Some(T)</code>, 要么为空: <code>None</code></strong>.</p>
<p>那么现在的问题就是该如何去使用这个<code>Option</code>枚举类型，根据我们上一节的经验，可以通过<code>match</code>来实现。</p>
<blockquote>
<p>因为<code>Option</code>，<code>Some</code>，<code>None</code>都包含在<code>prelude</code>中，因此你可以直接通过名称来使用它们，而无需以<code>Option::Some</code>这种形式去使用，总之，千万不要因为调用路径变短了，就忘记<code>Some</code>和<code>None</code>也是<code>Option</code>底下的枚举成员！</p>
</blockquote>
<h2 id="匹配-optiont"><a class="header" href="#匹配-optiont">匹配 <code>Option&lt;T&gt;</code></a></h2>
<p>使用<code>Option&lt;T&gt;</code>，是为了从 <code>Some</code> 中取出其内部的 <code>T</code> 值以及处理没有值的情况，为了演示这一点，下面一起来编写一个函数，它获取一个 <code>Option&lt;i32&gt;</code>，如果其中含有一个值，将其加一；如果其中没有值，则函数返回 <code>None</code> 值：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<p><code>plus_one</code>接受一个<code>Option&lt;i32&gt;</code>类型的参数，同时返回一个<code>Option&lt;i32&gt;</code>类型的值(这种形式的函数在标准库内随处所见)，在该函数的内部处理中，如果传入的是一个<code>None</code>，则返回一个<code>None</code>且不做任何处理；如果传入的是一个<code>Some(i32)</code>，则通过模式绑定，把其中的值绑定到变量<code>i</code>上，然后返回<code>i+1</code>的值，同时用<code>Some</code>进行包裹。</p>
<p>为了进一步说明，假设<code>plus_one</code>函数接受的参数值x是<code>Some(5)</code>，来看看具体的分支匹配情况：</p>
<h4 id="传入参数some5"><a class="header" href="#传入参数some5">传入参数<code>Some(5)</code></a></h4>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>首先是匹配<code>None</code>分支，因为值<code>Some(5)</code> 并不匹配模式 <code>None</code>，所以继续匹配下一个分支。</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<p><code>Some(5)</code> 与 <code>Some(i)</code> 匹配吗？当然匹配！它们是相同的成员。<code>i</code> 绑定了 <code>Some</code> 中包含的值，因此 <code>i</code> 的值是 <code>5</code>。接着匹配分支的代码被执行，最后将 <code>i</code> 的值加一并返回一个含有值 <code>6</code> 的新 <code>Some</code>。</p>
<h4 id="传入参数none"><a class="header" href="#传入参数none">传入参数None</a></h4>
<p>接着考虑下<code>plus_one</code> 的第二个调用，这次传入的<code>x</code> 是<code>None</code>， 我们进入 <code>match</code> 并与第一个分支相比较。</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>匹配上了！接着程序继续执行该分支后的代码：返回表达式<code>None</code>的值，也就是返回一个<code>None</code>，因为第一个分支就匹配到了，其他的分支将不再比较。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式适用场景"><a class="header" href="#模式适用场景">模式适用场景</a></h1>
<h2 id="模式"><a class="header" href="#模式">模式</a></h2>
<p>模式是Rust中的特殊语法，它用来匹配类型中的结构和数据，它往往和<code>match</code>表达式联用，以实现强大的模式匹配能力。模式一般由以下内容组合而成：</p>
<ul>
<li>字面值</li>
<li>解构的数组、枚举、结构体或者元组</li>
<li>变量</li>
<li>通配符</li>
<li>占位符</li>
</ul>
<h3 id="所有可能用到模式的地方"><a class="header" href="#所有可能用到模式的地方">所有可能用到模式的地方</a></h3>
<h4 id="match分支"><a class="header" href="#match分支">match分支</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
<span class="boring">}
</span></code></pre></pre>
<p>如上所示，<code>match</code>的每个分支就是一个<strong>模式</strong>，因为<code>match</code>匹配是穷尽式的，因此我们往往需要一个特殊的模式<code>_</code>，来匹配剩余的所有情况：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    _ =&gt; EXPRESSION,
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="if-let分支"><a class="header" href="#if-let分支">if let分支</a></h4>
<p><code>if let</code>往往用于匹配一个模式，而忽略剩下的所有模式的场景：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let PATTERN = SOME_VALUE {

}
<span class="boring">}
</span></code></pre></pre>
<h4 id="while-let条件循环"><a class="header" href="#while-let条件循环">while let条件循环</a></h4>
<p>一个与 <code>if let</code> 类似的结构是 <code>while let</code> 条件循环，它允许只要模式匹配就一直进行 <code>while</code> 循环。下面展示了一个使用<code>while let</code>的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Vec是动态数组
let mut stack = Vec::new();

// 向数组尾部插入元素
stack.push(1);
stack.push(2);
stack.push(3);

// stack.pop从数组尾部弹出元素
while let Some(top) = stack.pop() {
    println!(&quot;{}&quot;, top);
}
<span class="boring">}
</span></code></pre></pre>
<p>这个例子会打印出 <code>3</code>、<code>2</code> 接着是 <code>1</code>。<code>pop</code> 方法取出动态数组的最后一个元素并返回 <code>Some(value)</code>，如果动态数组是空的，将返回 <code>None</code>，对于<code>while</code>来说，只要 <code>pop</code> 返回 <code>Some</code> 就会一直不停的循环。一旦其返回 <code>None</code>，<code>while</code> 循环停止。我们可以使用 <code>while let</code> 来弹出栈中的每一个元素。</p>
<p>你也可以用<code>loop</code> + <code>if let</code> 或者<code>match</code>来实现这个功能，但是会更加啰嗦。</p>
<h4 id="for循环-1"><a class="header" href="#for循环-1">for循环</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
    println!(&quot;{} is at index {}&quot;, value, index);
}
<span class="boring">}
</span></code></pre></pre>
<p>这里使用 <code>enumerate</code> 方法产生一个迭代器，该迭代器每次迭代会返回一个<code>(索引，值)</code>形式的元组，然后用<code>(index,value)</code>来匹配。</p>
<h4 id="let语句"><a class="header" href="#let语句">let语句</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let PATTERN = EXPRESSION;
<span class="boring">}
</span></code></pre></pre>
<p>是的， 该语句我们已经用了无数次了，它也是一种模式匹配：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>这其中，<code>x</code>也是一种模式绑定，代表将<strong>匹配的值绑定到变量x上</strong>。因此，在Rust中,<strong>变量名也是一种模式</strong>，只不过它比较朴素很不起眼罢了。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x, y, z) = (1, 2, 3);
<span class="boring">}
</span></code></pre></pre>
<p>上面将一个元组与模式进行匹配(<strong>模式和值的类型必需相同！</strong>)，然后把<code>1,2,3</code>分别绑定到<code>x,y,z</code>上。</p>
<p>模式匹配要求两边的类型必须相同，否则就会导致下面的报错：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x, y) = (1, 2, 3);
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0308]: mismatched types
 --&gt; src/main.rs:4:5
  |
4 | let (x, y) = (1, 2, 3);
  |     ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |     |
  |     expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`
For more information about this error, try `rustc --explain E0308`.
error: could not compile `playground` due to previous error
<span class="boring">}
</span></code></pre></pre>
<p>对于元组来说，元素个数也是类型的一部分！</p>
<h4 id="函数参数-1"><a class="header" href="#函数参数-1">函数参数</a></h4>
<p>函数参数也是模式：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: i32) {
    // 代码
}
<span class="boring">}
</span></code></pre></pre>
<p>其中<code>x</code>就是一个模式，你还可以在参数中匹配元组：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<p><code>&amp;(3,5)</code>会匹配模式<code>&amp;(x,y)</code>,因此<code>x</code>得到了<code>3</code>，<code>y</code>得到了<code>5</code>.</p>
<h4 id="if-和-if-let"><a class="header" href="#if-和-if-let">if 和 if let</a></h4>
<p>对于以下代码，编译器会报错：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Some(x) = some_option_value;
<span class="boring">}
</span></code></pre></pre>
<p>因为右边的值可能不为<code>Some</code>，而是<code>None</code>，这种时候就不能进行匹配，也就是上面的代码遗漏了<code>None</code>的匹配。</p>
<p>类似<code>let</code>和<code>for</code>、<code>match</code>都必须要求完全覆盖匹配，才能通过编译。</p>
<p>但是对于<code>if let</code>，就可以这样使用：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(x) = some_option_value {
    println!(&quot;{}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p>因为<code>if let</code>允许匹配一种模式，而忽略其余的模式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全模式列表"><a class="header" href="#全模式列表">全模式列表</a></h1>
<p>在本书中我们已领略过许多不同类型模式的例子，本节的目标就是把这些模式语法都罗列出来，方便大家检索查阅（模式匹配在我们的开发中会经常用到）。</p>
<h3 id="匹配字面值"><a class="header" href="#匹配字面值">匹配字面值</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>这段代码会打印 <code>one</code> 因为 <code>x</code> 的值是 1，如果希望代码获得特定的具体值，那么这种语法很有用。</p>
<h3 id="匹配命名变量"><a class="header" href="#匹配命名变量">匹配命名变量</a></h3>
<p>在<a href="basic/match-pattern/./match-if-let#%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96">match一章</a>中，我们有讲过变量覆盖的问题，这个在<strong>匹配命名变量</strong>时会遇到：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<p>让我们看看当 <code>match</code> 语句运行的时候发生了什么。第一个匹配分支的模式并不匹配 <code>x</code> 中定义的值，所以代码继续执行。</p>
<p>第二个匹配分支中的模式引入了一个新变量 <code>y</code>，它会匹配任何 <code>Some</code> 中的值。因为这里的<code>y</code>在 <code>match</code> 表达式的作用域中，而不是之前<code>main</code>作用域中，所以这是一个新变量，不是开头声明为值 10 的那个 <code>y</code>。这个新的 <code>y</code> 绑定会匹配任何 <code>Some</code> 中的值，在这里是 <code>x</code> 中的值。因此这个 <code>y</code> 绑定了 <code>x</code> 中 <code>Some</code> 内部的值。这个值是 5，所以这个分支的表达式将会执行并打印出 <code>Matched，y = 5</code>。</p>
<p>如果 <code>x</code> 的值是 <code>None</code> 而不是 <code>Some(5)</code>，头两个分支的模式不会匹配，所以会匹配模式<code>_</code>。这个分支的模式中没有引入变量 <code>x</code>，所以此时表达式中的 <code>x</code> 会是外部没有被覆盖的 <code>x</code>，也就是<code>Some(5)</code>。</p>
<p>一旦 <code>match</code> 表达式执行完毕，其作用域也就结束了，同理内部 <code>y</code> 的作用域也结束了。最后的 <code>println!</code> 会打印 <code>at the end: x = Some(5), y = 10</code>。</p>
<p>如果你不想引入变量覆盖，那么需要使用匹配守卫(match guard)的方式，稍后在<a href="basic/match-pattern/all-patterns.html#%E5%8C%B9%E9%85%8D%E5%AE%88%E5%8D%AB%E6%8F%90%E4%BE%9B%E7%9A%84%E9%A2%9D%E5%A4%96%E6%9D%A1%E4%BB%B6">匹配守卫提供的额外条件</a>中会讲解。</p>
<h3 id="单分支多模式"><a class="header" href="#单分支多模式">单分支多模式</a></h3>
<p>在 <code>match</code> 表达式中，可以使用 <code>|</code> 语法匹配多个模式，它代表 <strong>或</strong>的意思。例如，如下代码将 <code>x</code> 的值与匹配分支相比较，第一个分支有 <strong>或</strong> 选项，意味着如果 <code>x</code> 的值匹配此分支的任何一个模式，它就会运行：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>上面的代码会打印 <code>one or two</code>。</p>
<h3 id="通过序列-匹配值的范围"><a class="header" href="#通过序列-匹配值的范围">通过序列<code>..=</code> 匹配值的范围</a></h3>
<p>在<a href="basic/match-pattern/../base-type/numbers#%E5%BA%8F%E5%88%97(Range)">数值类型</a>中我们有讲到一个序列语法，该语言不仅可以用循环中，还能用于匹配模式。</p>
<p><code>..=</code> 语法允许你匹配一个闭区间序列内的值。在如下代码中，当模式匹配任何在此序列内的值时，该分支会执行：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;

match x {
    1..=5 =&gt; println!(&quot;one through five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>如果 <code>x</code> 是 1、2、3、4 或 5，第一个分支就会匹配。这相比使用 <code>|</code> 运算符表达相同的意思更为方便；相比 <code>1..=5</code>，使用 <code>|</code> 则不得不指定 <code>1 | 2 | 3 | 4 | 5</code>这五个值，而使用<code>..=</code>指定序列就简短的多，比如希望匹配比如从 1 到 1000 的数字的时候！</p>
<p>序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。</p>
<p>如下是一个使用字符类型序列的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 'c';

match x {
    'a'..='j' =&gt; println!(&quot;early ASCII letter&quot;),
    'k'..='z' =&gt; println!(&quot;late ASCII letter&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust 知道 <code>c</code> 位于第一个模式的序列内，所以会打印出 <code>early ASCII letter</code>。</p>
<h3 id="解构并分解值"><a class="header" href="#解构并分解值">解构并分解值</a></h3>
<p>也可以使用模式来解构结构体、枚举、元组和引用。</p>
<h4 id="解构结构体"><a class="header" href="#解构结构体">解构结构体</a></h4>
<p>下面代码展示了如何用<code>let</code>解构一个带有两个字段 <code>x</code> 和 <code>y</code> 的结构体 <code>Point</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<p>这段代码创建了变量 <code>a</code> 和 <code>b</code> 来匹配结构体 <code>p</code> 中的 <code>x</code> 和 <code>y</code> 字段，这个例子展示了<strong>模式中的变量名不必与结构体中的字段名一致</strong>。不过通常希望变量名与字段名一致以便于理解变量来自于哪些字段。</p>
<p>因为变量名匹配字段名是常见的，同时因为 <code>let Point { x: x, y: y } = p;</code> 中<code>x</code> 和 <code>y</code>重复了，所以对于匹配结构体字段的模式存在简写：只需列出结构体字段的名称，则模式创建的变量会有相同的名称。下例与上例有着相同行为的代码，不过 <code>let</code> 模式创建的变量为 <code>x</code> 和 <code>y</code> 而不是 <code>a</code> 和 <code>b</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<p>这段代码创建了变量 <code>x</code> 和 <code>y</code>，与结构体<code>p</code> 中的 <code>x</code> 和 <code>y</code>字段相匹配。其结果是变量 <code>x</code> 和 <code>y</code> 包含结构体 <code>p</code> 中的值。</p>
<p>也可以使用字面值作为结构体模式的一部分进行进行解构，而不是为所有的字段创建变量。这允许我们测试一些字段为特定值的同时创建其他字段的变量。</p>
<p>下文展示了固定某个字段的匹配方式：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<p>首先是<code>match</code>第一个分支，指定匹配<code>y</code>为<code>0</code>的<code>Point</code>； 
然后第二个分支在第一个分支之后，匹配<code>y</code>不为<code>0</code>，<code>x</code>为<code>0</code>的<code>Point</code>; 
最后一个分支匹配<code>x</code>不为<code>0</code>，<code>y</code>也不为<code>0</code>的<code>Point</code>。</p>
<p>在这个例子中，值 <code>p</code> 因为其 <code>x</code> 包含 0 而匹配第二个分支，因此会打印出 <code>On the y axis at 7</code>。</p>
<h4 id="解构枚举"><a class="header" href="#解构枚举">解构枚举</a></h4>
<p>下面代码以<code>Message</code>枚举为例，编写一个 <code>match</code> 使用模式解构每一个内部值：</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        }
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x,
                y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; {
            println!(
                &quot;Change the color to red {}, green {}, and blue {}&quot;,
                r,
                g,
                b
            )
        }
    }
}
</code></pre></pre>
<p>这里老生常谈一句话，模式匹配一样要类型相同，因此匹配<code>Message::Move{1,2}</code>这样的枚举值，就必须要用<code>Message::Move{x,y}</code>这样的同类型模式才行。</p>
<p>这段代码会打印出 <code>Change the color to red 0, green 160, and blue 255</code>。尝试改变 <code>msg</code> 的值来观察其他分支代码的运行。</p>
<p>对于像 <code>Message::Quit</code> 这样没有任何数据的枚举成员，不能进一步解构其值。只能匹配其字面值 <code>Message::Quit</code>，因此模式中没有任何变量。</p>
<p>对于另外两个枚举成员，就用相同类型的模式去匹配出对应的值即可。</p>
<h4 id="解构嵌套的结构体和枚举"><a class="header" href="#解构嵌套的结构体和枚举">解构嵌套的结构体和枚举</a></h4>
<p>目前为止，所有的例子都只匹配了深度为一级的结构体或枚举。 <code>match</code>也可以匹配嵌套的项！</p>
<p>例如使用下面的代码来同时支持 RGB 和 HSV 色彩模式：</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Color {
   Rgb(i32, i32, i32),
   Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!(
                &quot;Change the color to red {}, green {}, and blue {}&quot;,
                r,
                g,
                b
            )
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!(
                &quot;Change the color to hue {}, saturation {}, and value {}&quot;,
                h,
                s,
                v
            )
        }
        _ =&gt; ()
    }
}
</code></pre></pre>
<p><code>match</code>第一个分支的模式匹配一个<code>Message::ChangeColor</code>枚举成员，该枚举成员又包含了一个<code>Color::Rgb</code>的枚举成员，最终绑定了3个内部的<code>i32</code>值。第二个，就交给亲爱的读者来思考完成。</p>
<h4 id="解构结构体和元组"><a class="header" href="#解构结构体和元组">解构结构体和元组</a></h4>
<p>我们甚至可以用复杂的方式来混合、匹配和嵌套解构模式。如下是一个复杂结构体的例子，其中结构体和元组嵌套在元组中，并将所有的原始类型解构出来：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
     x: i32,
     y: i32,
 }

let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}
</span></code></pre></pre>
<p>这种将复杂类型分解匹配的方式，可以让我们单独得到感兴趣的某个值。</p>
<h3 id="忽略模式中的值"><a class="header" href="#忽略模式中的值">忽略模式中的值</a></h3>
<p>有时忽略模式中的一些值是很有用的，比如在<code>match</code>中的最后一个分支使用<code>_</code>模式匹配所有剩余的值。 你也可以在另一个模式中使用 <code>_</code> 模式，使用一个以下划线开始的名称，或者使用 <code>..</code> 忽略所剩部分的值。</p>
<h4 id="使用-_-忽略整个值"><a class="header" href="#使用-_-忽略整个值">使用 <code>_</code> 忽略整个值</a></h4>
<p>虽然 <code>_</code> 模式作为 <code>match</code> 表达式最后的分支特别有用，但是它的作用还不限于此。例如可以将其用于函数参数中：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn foo(_: i32, y: i32) {
    println!(&quot;This code only uses the y parameter: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre></pre>
<p>这段代码会完全忽略作为第一个参数传递的值 <code>3</code>，并会打印出 <code>This code only uses the y parameter: 4</code>。</p>
<p>大部分情况当你不再需要特定函数参数时，最好修改签名不再包含无用的参数。在一些情况下忽略函数参数会变得特别有用，比如实现特征时，当你需要特定类型签名但是函数实现并不需要某个参数时。此时编译器就<strong>不会警告说存在未使用的函数参数</strong>，就跟使用命名参数一样。</p>
<h4 id="使用嵌套的-_-忽略部分值"><a class="header" href="#使用嵌套的-_-忽略部分值">使用嵌套的 <code>_</code> 忽略部分值</a></h4>
<p>可以在一个模式内部使用<code>_</code> 忽略部分值：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    (Some(_), Some(_)) =&gt; {
        println!(&quot;Can't overwrite an existing customized value&quot;);
    }
    _ =&gt; {
        setting_value = new_setting_value;
    }
}

println!(&quot;setting is {:?}&quot;, setting_value);
<span class="boring">}
</span></code></pre></pre>
<p>这段代码会打印出 <code>Can't overwrite an existing customized value</code> 接着是 <code>setting is Some(5)</code>。</p>
<p>第一个匹配分支，我们不关心里面的值，只关心元组中两个元素的类型，因此对于<code>Some</code>中的值，直接进行忽略。
剩下的形如<code>(Some(_),None)</code>，<code>(None, Some(_))</code>, <code>(None,None)</code>形式，都由第二个分支<code>_</code>进行分配。</p>
<p>还可以在一个模式中的多处使用下划线来忽略特定值，如下所示，这里忽略了一个五元元组中的第二和第四个值：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) =&gt; {
        println!(&quot;Some numbers: {}, {}, {}&quot;, first, third, fifth)
    },
}
<span class="boring">}
</span></code></pre></pre>
<p>老生常谈：模式匹配一定要类型相同，因此匹配<code>numbers</code>元组的模式，也必须有五个值（元组中元素的数量也属于元组类型的一部分）。</p>
<p>这会打印出 <code>Some numbers: 2, 8, 32</code>, 值 4 和 16 会被忽略。</p>
<h4 id="使用下划线开头忽略未使用的变量"><a class="header" href="#使用下划线开头忽略未使用的变量">使用下划线开头忽略未使用的变量</a></h4>
<p>如果你创建了一个变量却不在任何地方使用它，Rust 通常会给你一个警告，因为这可能会是个bug。但是有时创建一个不会被使用的变量是有用的，比如你正在设计原型或刚刚开始一个项目。这时你希望告诉 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<p>这里得到了警告说未使用变量 <code>y</code>，至于<code>x</code>则没有警告。</p>
<p>注意, 只使用 <code>_</code> 和使用以下划线开头的名称有些微妙的不同：比如 <strong><code>_x</code> 仍会将值绑定到变量，而 <code>_</code> 则完全不会绑定</strong>。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_s) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<p><code>s</code>是一个拥有所有权的动态字符串，在上面代码中，我们会得到一个错误，因为 <code>s</code> 的值会被转移给 <code>_s</code>，在<code>println!</code>中再次使用<code>s</code>会报错：</p>
<pre><code class="language-console">error[E0382]: borrow of partially moved value: `s`
 --&gt; src/main.rs:8:22
  |
4 |     if let Some(_s) = s {
  |                 -- value partially moved here
...
8 |     println!(&quot;{:?}&quot;, s);
  |                      ^ value borrowed here after partial move
</code></pre>
<p>只使用下划线本身，则并不会绑定值，因为 <code>s</code> 没有被移动进 <code>_</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<h4 id="用--忽略剩余值"><a class="header" href="#用--忽略剩余值">用 <code>..</code> 忽略剩余值</a></h4>
<p>对于有多个部分的值，可以使用 <code>..</code> 语法来只使用部分值而忽略其它值，这样也不用再为每一个被忽略的值都单独列出下划线。<code>..</code> 模式会忽略模式中剩余的任何没有显式匹配的值部分. </p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}
<span class="boring">}
</span></code></pre></pre>
<p>这里列出了 <code>x</code> 值，接着使用了<code>..</code> 模式来忽略其它字段，这样的写法要比一一列出其它字段，然后用<code>_</code>忽略简洁的多。</p>
<p>还可以用<code>..</code>来忽略元组中间的某些值：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {}, {}&quot;, first, last);
        },
    }
}
</code></pre></pre>
<p>这里用 <code>first</code> 和 <code>last</code> 来匹配第一个和最后一个值。<code>..</code> 将匹配并忽略中间的所有值。</p>
<p>然而使用 <code>..</code> 必须是无歧义的。如果期望匹配和忽略的值是不明确的，Rust 会报错。下面代码展示了一个带有歧义的 <code>..</code> 例子，因此不能编译：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {}&quot;, second)
        },
    }
}
</code></pre></pre>
<p>如果编译上面的例子，会得到下面的错误：</p>
<pre><code class="language-text">error: `..` can only be used once per tuple pattern // 每个元组模式只能使用一个`..`
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here // 上一次使用在这里

error: could not compile `world_hello` due to previous error              ^^
</code></pre>
<p>Rust无法判断，<code>second</code>应该匹配<code>numbers</code>中的第几个元素，因此这里使用两个<code>..</code>模式，是由很大歧义的！</p>
<h3 id="匹配守卫提供的额外条件"><a class="header" href="#匹配守卫提供的额外条件">匹配守卫提供的额外条件</a></h3>
<p><strong>匹配守卫</strong>（<em>match guard</em>）是一个位于 <code>match</code> 分支模式之后的额外 <code>if</code> 条件，它能为分支模式提供更进一步的匹配条件。</p>
<p>这个条件可以使用模式中创建的变量：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num = Some(4);

match num {
    Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: {}&quot;, x),
    Some(x) =&gt; println!(&quot;{}&quot;, x),
    None =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p>这个例子会打印出 <code>less than five: 4</code>。当 <code>num</code> 与模式中第一个分支匹配时，<code>Some(4)</code> 可以与 <code>Some(x)</code>匹配，接着匹配守卫检查 <code>x</code> 值是否小于 <code>5</code>，因为 <code>4</code> 小于 <code>5</code>，所以第一个分支被选择。</p>
<p>相反如果 <code>num</code> 为 <code>Some(10)</code>，因为 10 不小于 5 ，所以第一个分支的匹配守卫为假。接着 Rust 会前往第二个分支，因为这里没有匹配守卫所以会匹配任何 <code>Some</code> 成员。</p>
<p>模式中无法提供类如<code>if x &lt; 5</code>的表达能力，我们可以通过匹配守卫的方式来实现。</p>
<p>在之前，我们提到可以使用匹配守卫来解决模式中变量覆盖的问题，那里 <code>match</code> 表达式的模式中新建了一个变量而不是使用 <code>match</code> 之外的同名变量。内部变量覆盖了外部变量，意味着此时不能够使用外部变量的值，下面代码展示了如何使用匹配守卫修复这个问题。</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {}&quot;, n),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {}&quot;, x, y);
}
</code></pre></pre>
<p>现在这会打印出 <code>Default case, x = Some(5)</code>。现在第二个匹配分支中的模式不会引入一个覆盖外部 <code>y</code> 的新变量 <code>y</code>，这意味着可以在匹配守卫中使用外部的 <code>y</code>。相比指定会覆盖外部 <code>y</code> 的模式 <code>Some(y)</code>，这里指定为 <code>Some(n)</code>。此新建的变量 <code>n</code> 并没有覆盖任何值，因为 <code>match</code> 外部没有变量 <code>n</code>。</p>
<p>匹配守卫 <code>if n == y</code> 并不是一个模式所以没有引入新变量。这个 <code>y</code> <strong>正是</strong> 外部的 <code>y</code> 而不是新的覆盖变量 <code>y</code>，这样就可以通过比较 <code>n</code> 和 <code>y</code> 来表达寻找一个与外部 <code>y</code> 相同的值的概念了。</p>
<p>也可以在匹配守卫中使用 <strong>或</strong> 运算符 <code>|</code> 来指定多个模式，<strong>同时匹配守卫的条件会作用于所有的模式</strong>。下面代码展示了匹配守卫与 <code>|</code> 的优先级。这个例子中看起来好像 <code>if y</code> 只作用于 <code>6</code>，但实际上匹配守卫 <code>if y</code> 作用于 <code>4</code>、<code>5</code> <strong>和</strong> <code>6</code> ，在满足<code>x</code>属于 <code>4 | 5 | 6</code> 后才会判断 <code>y</code> 是否为 <code>true</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 4;
let y = false;

match x {
    4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
    _ =&gt; println!(&quot;no&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>这个匹配条件表明此分支只匹配 <code>x</code> 值为 <code>4</code>、<code>5</code> 或 <code>6</code> <strong>同时</strong> <code>y</code> 为 <code>true</code> 的情况。</p>
<p>虽然在第一个分支中，<code>x</code> 匹配了模式 <code>4</code> ，但是对于匹配守卫 <code>if y</code> 来说，因为 <code>y</code> 是 <code>false</code>，因此该守卫条件的值永远是 <code>false</code>，也意味着第一个分支永远无法被匹配。</p>
<p>下面的文字图解释了匹配守卫作用于多个模式时的优先级规则，第一张是正确的：</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>而第二张图是错误的</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>可以通过运行代码时的情况看出这一点：如果匹配守卫只作用于由 <code>|</code> 运算符指定的值列表的最后一个值，这个分支就会匹配且程序会打印出 <code>yes</code>。</p>
<h2 id="绑定"><a class="header" href="#绑定">@绑定</a></h2>
<p><code>@</code>(读作at)运算符允许为一个字段绑定另外一个变量。下面例子中，我们希望测试 <code>Message::Hello</code> 的 <code>id</code> 字段是否位于 <code>3..=7</code> 范围内，同时也希望能将其值绑定到 <code>id_variable</code> 变量中以便此分支中相关的代码可以使用它。我们可以将 <code>id_variable</code> 命名为 <code>id</code>，与字段同名，不过出于示例的目的这里选择了不同的名称。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello { id: id_variable @ 3..=7 } =&gt; {
        println!(&quot;Found an id in range: {}&quot;, id_variable)
    },
    Message::Hello { id: 10..=12 } =&gt; {
        println!(&quot;Found an id in another range&quot;)
    },
    Message::Hello { id } =&gt; {
        println!(&quot;Found some other id: {}&quot;, id)
    },
}
<span class="boring">}
</span></code></pre></pre>
<p>上例会打印出 <code>Found an id in range: 5</code>。通过在 <code>3..=7</code> 之前指定 <code>id_variable @</code>，我们捕获了任何匹配此范围的值并同时将该值绑定到变量<code>id_variable</code>上。</p>
<p>第二个分支只在模式中指定了一个范围，<code>id</code> 字段的值可以是 <code>10、11 或 12</code>，不过这个模式的代码并不知情也不能使用 <code>id</code> 字段中的值，因为没有将 <code>id</code> 值保存进一个变量。</p>
<p>最后一个分支指定了一个没有范围的变量，此时确实拥有可以用于分支代码的变量 <code>id</code>，因为这里使用了结构体字段简写语法。不过此分支中没有像头两个分支那样对 <code>id</code> 字段的值进行测试：任何值都会匹配此分支。</p>
<p>当你既想要限定分支范围，又想要使用分支的变量时，就可以用<code>@</code>来绑定到一个新的变量上，实现想要的功能。</p>
<h4 id="前绑定后解构rust156新增"><a class="header" href="#前绑定后解构rust156新增">@前绑定后解构(Rust1.56新增)</a></h4>
<p>使用<code>@</code>还可以在绑定新变量的同时，对目标进行解构：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    // 绑定新变量`p`，同时对`Point`进行解构
    let p @ Point {x: px, y: py } = Point {x: 10, y: 23};
    println!(&quot;x: {}, y: {}&quot;, px, py);
    println!(&quot;{:?}&quot;, p);

    
    let point = Point {x: 10, y: 5};
    if let p @ Point {x: 10, y} = point {
        println!(&quot;x is 10 and y is {} in {:?}&quot;, y, p);
    } else {
        println!(&quot;x was not 10 :(&quot;);
    }
}
</code></pre></pre>
<h4 id="新特性rust153新增"><a class="header" href="#新特性rust153新增">@新特性(Rust1.53新增)</a></h4>
<p>考虑下面一段代码:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    match 1 {
        num @ 1 | 2 =&gt; {
            println!(&quot;{}&quot;, num);
        }
        _ =&gt; {}
    }
}
</code></pre></pre>
<p>编译不通过，是因为<code>num</code>没有绑定到所有的模式上，只绑定了模式<code>1</code>，你可能会试图通过这个方式来解决：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>num @ (1 | 2)
<span class="boring">}
</span></code></pre></pre>
<p>但是，如果你用的是Rust1.53之前的版本，那这种写法会报错，因为编译器不支持。</p>
<p>至此，模式匹配的内容已经全部完结，复杂但是详尽，想要一次性全部记住属实不易，因此读者可以先留一个印象，等未来需要时，再来翻阅寻找具体的模式实现方式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方法method"><a class="header" href="#方法method">方法Method</a></h1>
<p>从面向对象语言过来的同学对于方法肯定不陌生，<code>class</code> 里面就充斥着方法的概念。在 Rust 中，方法的概念也大差不差，往往和对象成对出现：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>object.method()
<span class="boring">}
</span></code></pre></pre>
<p>例如读取一个文件写入缓冲区，如果用函数的写法 <code>read(f,buffer)</code>，用方法的写法 <code>f.read(buffer)</code>。不过与其它语言 <code>class</code> 跟方法的联动使用不同（这里可能要修改下），Rust 的方法往往跟结构体、枚举、特征一起使用，特征(Trait)将在后面几章进行介绍。</p>
<h2 id="定义方法"><a class="header" href="#定义方法">定义方法</a></h2>
<p>Rust 使用 <code>impl</code> 来定义方法，例如以下代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    // new是Circle的关联函数，因为它的第一个参数不是self
    // 这种方法往往用于初始化当前结构体的实例
    fn new(x: f64, y: f64, radius: f64) -&gt; Circle {
        Circle {
            x: x,
            y: y,
            radius: radius,
        }
    }

    // Circle的方法，&amp;self表示借用当前的Circle结构体
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们这里先不详细展开讲解，只是先建立对方法定义的大致印象。下面的图片将 Rust 方法定义与其它语言的方法定义做了对比：</p>
<img alt="" src="basic//img/method-01.png" class="center"/>
<p>可以看出，其它语言中所有定义都在 <code>class</code> 中，但是 Rust 的对象定义和方法定义是分离的，这种数据和使用分离的方式，会给予使用者极高的灵活度。</p>
<p>再来看一个例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<p>该例子定义了一个 <code>Rectangle</code> 结构体，并且在其上定义了一个 <code>area</code> 方法，用于计算该矩形的面积。</p>
<p><code>impl Rectangle {}</code> 表示为 <code>Rectangle</code> 实现方法(<code>impl</code> 是实现 <em>implementation</em> 的缩写)，这样的写法表明 <code>impl</code> 语句块中的一切都是跟 <code>Rectangle</code> 相关联的。</p>
<p>接下里的内容非常重要，请大家仔细看。在 <code>area</code> 的签名中，我们使用 <code>&amp;self</code> 替代 <code>rectangle: &amp;Rectangle</code>，<code>&amp;self</code> 其实是 <code>self: &amp;Self</code> 的简写（注意大小写）。在一个 <code>impl</code> 块内，<code>Self</code> 指代被实现方法的结构体类型，<code>self</code> 指代此类型的实例，换句话说，<code>self</code> 指代的是 <code>Rectangle</code> 结构体实例，这样的写法会让我们的代码简洁很多，而且非常便于理解：我们为哪个结构体实现方法，那么 <code>self</code> 就是指代哪个结构体的实例。</p>
<p>需要注意的是，<code>self</code> 依然有所有权的概念：</p>
<ul>
<li><code>self</code> 表示 <code>Rectangle</code> 的所有权转移到该方法中，这种形式用的较少</li>
<li><code>&amp;self</code> 表示该方法对 <code>Rectangle</code> 的不可变借用</li>
<li><code>&amp;mut self</code> 表示可变借用</li>
</ul>
<p>总之，<code>self</code> 的使用就跟函数参数一样，要严格遵守 Rust 的所有权规则。</p>
<p>回到上面的例子中，选择 <code>&amp;self</code> 的理由跟在函数中使用 <code>&amp;Rectangle</code> 是相同的：我们并不想获取所有权，也无需去改变它，只是希望能够读取结构体中的数据。如果想要在方法中去改变当前的结构体，需要将第一个参数改为 <code>&amp;mut self</code>。仅仅通过使用 <code>self</code> 作为第一个参数来使方法获取实例的所有权是很少见的，这种使用方式往往用于把当前的对象转成另外一个对象时使用，转换完后，就不再关注之前的对象，且可以防止对之前对象的误调用。</p>
<p>简单总结下，使用方法代替函数有以下好处：</p>
<ul>
<li>不用在函数签名中重复书写 <code>self</code> 对应的类型</li>
<li>代码的组织性和内聚性更强，对于代码维护和阅读来说，好处巨大</li>
</ul>
<h4 id="方法名跟结构体字段名相同"><a class="header" href="#方法名跟结构体字段名相同">方法名跟结构体字段名相同</a></h4>
<p>在 Rust 中，允许方法名跟结构体的字段名相同：</p>
<pre><pre class="playground"><code class="language-rust edition2021">impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!(&quot;The rectangle has a nonzero width; it is {}&quot;, rect1.width);
    }
}
</code></pre></pre>
<p>当我们使用 <code>rect1.width()</code> 时， Rust 知道我们调用的是它的方法，如果使用 <code>rect1.witdh</code>，则是访问它的字段。</p>
<p>一般来说，方法跟字段同名，往往适用于实现 <code>getter</code> 访问器，例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021">pub struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    pub fn new(width: u32, height: u32) -&gt; Self {
        Rectangle { width, height }
    }
    pub fn width(&amp;self) -&gt; u32 {
        return self.width;
    }
}

fn main() {
    let rect1 = Rectangle::new(30, 50);

    println!(&quot;{}&quot;, rect1.width());
}
</code></pre></pre>
<p>用这种方式，我们可以把 <code>Rectangle</code> 的字段设置为私有属性，只需把它的 <code>new</code> 和 <code>width</code> 方法设置为公开可见，那么用户就可以创建一个矩形，同时通过访问器 <code>rect1.width()</code> 方法来获取矩形的宽度，因为 <code>width</code> 字段是私有的，当用户访问 <code>rect1.width</code> 字段时，就会报错。注意在此例中，<code>Self</code> 指代的就是被实现方法的结构体 <code>Rectangle</code>。</p>
<blockquote>
<h3 id="--运算符到哪去了"><a class="header" href="#--运算符到哪去了"><code>-&gt;</code> 运算符到哪去了？</a></h3>
<p>在 C/C++ 语言中，有两个不同的运算符来调用方法：<code>.</code> 直接在对象上调用方法，而 <code>-&gt;</code> 在一个对象的指针上调用方法，这时需要先解引用指针。换句话说，如果 <code>object</code> 是一个指针，那么 <code>object-&gt;something()</code> 和 <code>(*object).something()</code> 是一样的。</p>
<p>Rust 并没有一个与 <code>-&gt;</code> 等效的运算符；相反，Rust 有一个叫 <strong>自动引用和解引用</strong>的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。</p>
<p>他是这样工作的：当使用 <code>object.something()</code> 调用方法时，Rust 会自动为 <code>object</code> 添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code> 以便使 <code>object</code> 与方法签名匹配。也就是说，这些代码是等价的：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>第一行看起来简洁的多。这种自动引用的行为之所以有效，是因为方法有一个明确的接收者———— <code>self</code> 的类型。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是仅仅读取（<code>&amp;self</code>），做出修改（<code>&amp;mut self</code>）或者是获取所有权（<code>self</code>）。事实上，Rust 对方法接收者的隐式借用让所有权在实践中更友好。</p>
</blockquote>
<h2 id="带有多个参数的方法"><a class="header" href="#带有多个参数的方法">带有多个参数的方法</a></h2>
<p>方法和函数一样，可以使用多个参数：</p>
<pre><pre class="playground"><code class="language-rust edition2021">impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre></pre>
<h2 id="关联函数"><a class="header" href="#关联函数">关联函数</a></h2>
<p>现在大家可以思考一个问题，如何为一个结构体定义一个构造器方法？也就是接受几个参数，然后构造并返回该结构体的实例。其实答案在开头的代码片段中就给出了，很简单，不使用 <code>self</code> 中即可。</p>
<p>这种定义在 <code>impl</code> 中且没有 <code>self</code> 的函数被称之为<strong>关联函数</strong>： 因为它没有 <code>self</code>，不能用 <code>f.read()</code> 的形式调用，因此它是一个函数而不是方法，它又在<code>impl</code> 中，与结构体紧密关联，因此称为关联函数。</p>
<p>在之前的代码中，我们已经多次使用过关联函数，例如 <code>String::from</code>，用于创建一个动态字符串。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn new(w: u32, h: u32) -&gt; Rectangle {
        Rectangle { width: w, height: h }
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Rust 中有一个约定俗称的规则，使用 <code>new</code> 来作为构造器的名称，出于设计上的考虑，Rust 特地没有用 <code>new</code> 作为关键字</p>
</blockquote>
<p>因为是函数，所以不能用 <code>.</code> 的方式来调用，我们需要用<code>::</code>来调用，例如 <code>let sq = Rectangle::new(3,3);</code>。这个方法位于结构体的命名空间中：<code>::</code> 语法用于关联函数和模块创建的命名空间。</p>
<h2 id="多个impl定义"><a class="header" href="#多个impl定义">多个impl定义</a></h2>
<p>Rust 允许我们为一个结构体定义多个 <code>impl</code> 块，目的是提供更多的灵活性和代码组织性，例如当方法多了后，可以把相关的方法组织在同一个 <code>impl</code> 块中，那么就可以形成多个 <code>impl</code> 块，各自完成一块儿目标：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>当然，就这个例子而言，我们没必要使用两个 <code>impl</code> 块，这里只是为了演示方便。</p>
<h2 id="为枚举实现方法"><a class="header" href="#为枚举实现方法">为枚举实现方法</a></h2>
<p>枚举类型之所以强大，不仅仅在于它好用、可以<a href="basic/./compound-type/enum.html#%E5%90%8C%E4%B8%80%E5%8C%96%E7%B1%BB%E5%9E%8B">同一化类型</a>，还在于，我们可以像结构体一样，为枚举实现方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![allow(unused)]
fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&amp;self) {
        // 在这里定义方法体
    }
}

let m = Message::Write(String::from(&quot;hello&quot;));
m.call();
}
</code></pre></pre>
<p>除了结构体和枚举，我们还能为特征(trait)实现方法，这将在下一章进行讲解，在此之前，先来看看泛型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型和特征"><a class="header" href="#泛型和特征">泛型和特征</a></h1>
<p>泛型和特征是Rust中最最重要的抽象类型，也是你在学习Rust路上的拦路虎，但是挑战往往与乐趣并存，一旦学会，在后面学习Rust的路上，你将一往无前。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型generics"><a class="header" href="#泛型generics">泛型Generics</a></h1>
<p>Go语言在2022年，就要正式引入泛型，被视为在1.0版本后，语言特性发展迈出的一大步，为什么泛型这么重要？到底什么是泛型？Rust的泛型有几种？
本章将一一为你讲解。</p>
<p>我们在编程中，经常有这样的需求：用同一功能的函数处理不同类型的数据，例如两个数的加法，无论是整数还是浮点数，甚至是自定义类型，都能进行支持。在不支持泛型的编程语言中，通常需要为每一种类型编写一个函数：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn add_i8(a:i8, b:i8) -&gt; i8 {
    a + b
}
fn add_i32(a:i32, b:i32) -&gt; i32 {
    a + b
}
fn add_f64(a:f64, b:f64) -&gt; f64 {
    a + b
}

fn main() {
    println!(&quot;add i8: {}&quot;, add_i8(2i8, 3i8));
    println!(&quot;add i32: {}&quot;, add_i32(20, 30));
    println!(&quot;add f64: {}&quot;, add_f64(1.23, 1.23));
}
</code></pre></pre>
<p>上述代码可以正常运行，但是很啰嗦，如果你要支持更多的类型，那么会更繁琐。程序员或多或少都有强迫症，一个好程序员的公认特征就是 - 懒，这么勤快的写一大堆代码，显然不是咱们的优良传统，是不？</p>
<p>在开始讲解Rust的泛型之前，先来看看什么是多态。</p>
<p>在编程的时候，我们经常利用多态。通俗的讲，多态就是好比坦克的炮管，既可以发射普通弹药，也可以发射制导炮弹（导弹），也可以发射贫铀穿甲弹，甚至发射子母弹，没有必要为每一种炮弹都在坦克上分别安装一个专用炮管，即使生产商愿意，炮手也不愿意，累死人啊。所以在编程开发中，我们也需要这样“通用的炮管”，这个“通用的炮管”就是多态。</p>
<p>实际上，泛型就是一种多态。泛型主要目的是为程序员提供编程的便利，减少代码的臃肿，同时可以极大地丰富语言本身的表达能力，为程序员提供了一个合适的炮管。想想，一个函数，可以代替几十个，甚至数百个函数，是一件多么让人兴奋的事情：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn add&lt;T&gt;(a:T, b:T) -&gt; T {
    a + b
}

fn main() {
    println!(&quot;add i8: {}&quot;, add(2i8, 3i8));
    println!(&quot;add i32: {}&quot;, add(20, 30));
    println!(&quot;add f64: {}&quot;, add(1.23, 1.23));
}
</code></pre></pre>
<p>将之前的代码改成上面这样，就是Rust泛型的初印象，这段代码虽然很简洁，但是并不能编译通过，我们会在后面进行详细讲解，现在只要对泛型有个大概的印象即可。</p>
<h2 id="泛型详解"><a class="header" href="#泛型详解">泛型详解</a></h2>
<p>上面代码的 <code>T</code> 就是<strong>泛型参数</strong>，实际上在Rust中，泛型参数的名称你可以任意起，但是出于惯例，我们都用 <code>T</code> ( <code>T</code> 是 <code>type</code> 的首字母)来作为首选，这个名称越短越好，除非需要表达含义，否则一个字母是最完美的。</p>
<p>使用泛型参数，有一个先决条件，必需在使用前对其进行声明：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
<span class="boring">}
</span></code></pre></pre>
<p>该泛型函数的作用是从列表中找出最大的值，其中列表中的元素类型为T。首先 <code>largest&lt;T&gt;</code> 对泛型参数 <code>T</code> 进行了声明，然后才在函数参数中进行使用该泛型参数 <code>list: &amp;[T]</code> (还记得 <code>&amp;[T]</code> 类型吧？这是<a href="basic/trait/../compound-type/array#%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87">数组切片</a>)。</p>
<p>总之，我们可以这样理解这个函数定义：函数 <code>largest</code> 有泛型类型 <code>T</code>，它有个参数 <code>list</code>，其类型是元素为 <code>T</code> 的数组切片，最后，该函数返回值的类型也是 <code>T</code>。</p>
<p>具体的泛型函数实现如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p>运行后报错：</p>
<pre><code class="language-console">error[E0369]: binary operation `&gt;` cannot be applied to type `T` // `&gt;`操作符不能用于类型`T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T` // 考虑对T进行类型上的限制 :
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
  |             ++++++++++++++++++++++
</code></pre>
<p>因为T可以是任何类型，但不是所有的类型都能进行比较，因此上面的错误中，编译器建议我们给 <code>T</code> 添加一个类型限制：使用 <code>std::cmp::PartialOrd</code> 特征（Trait）对T进行限制，特征在下一节会详细介绍，现在你只要理解，该特征的目的就是让<strong>类型实现可比较的功能</strong>。</p>
<p>还记得我们一开始的 <code>add</code> 泛型函数吗？如果你运行它，会得到以下的报错：</p>
<pre><code class="language-console">error[E0369]: cannot add `T` to `T` // 无法将 `T` 类型跟 `T` 类型进行相加
 --&gt; src/main.rs:2:7
  |
2 |     a + b
  |     - ^ - T
  |     |
  |     T
  |
help: consider restricting type parameter `T`
  |
1 | fn add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) -&gt; T { 
  |         +++++++++++++++++++++++++++
</code></pre>
<p>同样的，不是所有 <code>T</code> 类型都能进行相加操作，因此我们需要用 <code>std::ops::Add&lt;Output = T&gt;</code> 对 <code>T</code> 进行限制：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) -&gt; T {
    a + b
}
<span class="boring">}
</span></code></pre></pre>
<p>进行如上修改后，就可以正常运行。</p>
<h2 id="结构体中使用泛型"><a class="header" href="#结构体中使用泛型">结构体中使用泛型</a></h2>
<p>结构体中的字段类型也可以用泛型来定义，下面代码定义了一个坐标点 <code>Point</code>，它可以存放任何类型的坐标值：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p>这里有两点需要特别的注意：</p>
<ul>
<li><strong>提前声明</strong>，跟泛型函数定义类似，首先我们在使用泛型参数之前必需要进行声明 <code>Point&lt;T&gt;</code>，接着就可以在结构体的字段类型中使用 <code>T</code> 来替代具体的类型</li>
<li><strong>x和y是相同的类型</strong></li>
</ul>
<p>第二点非常重要，如果使用不同的类型，那么它会导致下面代码的报错：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let p = Point{x: 1, y :1.1};
}
</code></pre></pre>
<p>错误如下：</p>
<pre><code class="language-console">error[E0308]: mismatched types //类型不匹配
 --&gt; src/main.rs:7:28
  |
7 |     let p = Point{x: 1, y :1.1};
  |                            ^^^ expected integer, found floating-point number //期望y是整数，但是却是浮点数

</code></pre>
<p>当把 <code>1</code> 赋值给 <code>x</code> 时，变量 <code>p</code> 的 <code>T</code> 类型就被确定为整数类型，因此 <code>y</code> 也必须是整数类型，但是我们却给它赋予了浮点数，因此导致报错。</p>
<p>如果想让 <code>x</code> 和 <code>y</code> 即能类型相同，又能类型不同，需要使用不同的泛型参数：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T,U&gt; {
    x: T,
    y: U,
}
fn main() {
    let p = Point{x: 1, y :1.1};
}
</code></pre></pre>
<p>切记，所有的泛型参数都要提前声明：<code>Point&lt;T,U&gt;</code> ! 但是如果你的结构体变成这鬼样：<code>struct Woo&lt;T,U,V,W,X&gt;</code>，那么你需要考虑拆分这个结构体，减少泛型参数的个数和代码复杂度。</p>
<h2 id="枚举中使用泛型"><a class="header" href="#枚举中使用泛型">枚举中使用泛型</a></h2>
<p>提到枚举类型，<code>Option</code> 永远是第一个应该被想起来的，在之前的章节中，它也多次出现：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Option&lt;T&gt;</code> 是一个拥有泛型 <code>T</code> 的枚举类型，它第一个成员是 <code>Some(T)</code>，存放了一个类型为 <code>T</code> 的值。得益于泛型的引入，我们可以在任何一个需要返回值的函数中，去使用 <code>Option&lt;T&gt;</code> 枚举类型来做为返回值，用于返回一个任意类型的值 <code>Some(T)</code>，或者没有值 <code>None</code>。</p>
<p>对于枚举而言，卧龙凤雏永远是绕不过去的存在：如果是 <code>Option</code> 是卧龙，那么 <code>Result</code> 就一定是凤雏，得两者可得天下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>这个枚举和 <code>Option</code> 一样，主要用于函数返回值，与 <code>Option</code> 用于值的存在与否不同，<code>Result </code>关注的主要是值的正确性。</p>
<p>如果函数正常运行，则最后返回一个 <code>Ok(T)</code>，<code>T</code> 是函数具体的返回值类型，如果函数异常运行，则返回一个 <code>Err(E)</code>，<code>E</code> 是错误类型。例如打开一个文件：如果成功打开文件，则返回 <code>Ok(std::fs::File)</code>，因此 <code>T</code> 对应的是 <code>std::fs::File</code> 类型；而当打开文件时出现问题时，返回 <code>Err(std::io::Error)</code>，<code>E</code> 对应的就是 <code>std::io::Error</code> 类型。</p>
<h2 id="方法中使用泛型"><a class="header" href="#方法中使用泛型">方法中使用泛型</a></h2>
<p>上一章中，我们讲到什么是方法以及如何在结构体和枚举上定义方法。方法上也可以使用泛型：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p>使用泛型参数前，依然需要提前声明：<code>impl&lt;T&gt;</code>，只有提前声明了，我们才能在<code>Point&lt;T&gt;</code>中使用它，这样Rust就知道 <code>Point</code> 的尖括号中的类型是泛型而不是具体类型。需要注意的是，这里的 <code>Point&lt;T&gt;</code> 不再是泛型声明，而是一个完整的结构体类型，因为我们定义的结构体就是 <code>Point&lt;T&gt;</code> 而不再是 <code>Point</code>。</p>
<p>除了结构体中的泛型参数，我们还能在该结构体的方法中定义额外的泛型参数，就跟泛型函数一样：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c'};

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p>这个例子中，<code>T,U</code> 是定义在结构体 <code>Point</code> 上的泛型参数，<code>V,W</code> 是单独定义在方法 <code>mixup</code> 上的泛型参数，它们并不冲突，说白了，你可以理解为，一个是结构体泛型，一个是函数泛型。</p>
<h4 id="为具体的泛型类型实现方法"><a class="header" href="#为具体的泛型类型实现方法">为具体的泛型类型实现方法</a></h4>
<p>对于 <code>Point&lt;T&gt;</code> 类型，你不仅能定义基于 <code>T</code> 的方法，还能针对特定的具体类型，进行方法定义：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这段代码意味着 <code>Point&lt;f32&gt;</code> 类型会有一个方法 <code>distance_from_origin</code>，而其他 <code>T</code> 不是 <code>f32</code> 类型的 <code>Point&lt;T&gt; </code>实例则没有定义此方法。这个方法计算点实例与坐标<code>(0.0, 0.0)</code> 之间的距离，并使用了只能用于浮点型的数学运算符。</p>
<p>这样我们就能针对特定的泛型类型实现某个特定的方法，对于其它泛型类型则没有定义该方法。</p>
<h2 id="const泛型rust-151版本引入的重要特性"><a class="header" href="#const泛型rust-151版本引入的重要特性">const泛型（Rust 1.51版本引入的重要特性）</a></h2>
<p>在之前的泛型中，可以抽象为一句话：针对类型实现的泛型，所有的泛型都是为了抽象不同的类型，那有没有针对值的泛型？可能很多同学感觉很难理解，值怎么使用泛型？不急，我们先从数组讲起。</p>
<p>在<a href="basic/trait/../compound-type/array.html">数组</a>那节，有提到过很重要的一点：<code>[i32; 2]</code> 和 <code>[i32; 3]</code> 是不同的数组类型，比如下面的代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn display_array(arr: [i32; 3]) {
    println!(&quot;{:?}&quot;, arr);
}
fn main() {
    let arr: [i32; 3] = [1, 2, 3];
    display_array(arr);

    let arr: [i32;2] = [1,2];
    display_array(arr);
}
</code></pre></pre>
<p>运行后报错：</p>
<pre><code class="language-console">error[E0308]: mismatched types // 类型不匹配
  --&gt; src/main.rs:10:19
   |
10 |     display_array(arr);
   |                   ^^^ expected an array with a fixed size of 3 elements, found one with 2 elements
                          // 期望一个长度为3的数组，却发现一个长度为2的
</code></pre>
<p>结合代码和报错，可以很清楚的看出，<code>[i32; 3]</code> 和 <code>[i32; 2]</code> 确实是两个完全不同的类型，因此无法用同一个函数调用。</p>
<p>首先，让我们修改代码，让 <code>display_array</code> 能打印任意长度的 <code>i32</code> 数组：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn display_array(arr: &amp;[i32]) {
    println!(&quot;{:?}&quot;, arr);
}
fn main() {
    let arr: [i32; 3] = [1, 2, 3];
    display_array(&amp;arr);

    let arr: [i32;2] = [1,2];
    display_array(&amp;arr);
}
</code></pre></pre>
<p>很简单，只要使用数组切片，然后传入 <code>arr</code> 的不可变引用即可。</p>
<p>接着，将 <code>i32</code> 改成所有类型的数组：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn display_array&lt;T: std::fmt::Debug&gt;(arr: &amp;[T]) {
    println!(&quot;{:?}&quot;, arr);
}
fn main() {
    let arr: [i32; 3] = [1, 2, 3];
    display_array(&amp;arr);

    let arr: [i32;2] = [1,2];
    display_array(&amp;arr);
}
</code></pre></pre>
<p>也不难，唯一要注意的是需要对T加一个限制 <code>std::fmt::Debug</code>，该限制表明 <code>T</code> 可以用在 <code>println!(&quot;{:?}&quot;, arr)</code>中，因为 <code>{:?}</code> 形式的格式化输出需要 <code>arr</code> 实现该特征。</p>
<p>通过引用，我们可以很轻松的解决处理任何类型数组的问题，但是如果在某些场景下引用不适宜用或者干脆不能用呢？你们知道为什么以前Rust的一些数组库，在使用的时候都限定长度不超过32吗？因为它们会为每个长度都单独实现一个函数，简直。。。毫无人性。难道没有什么办法可以解决这个问题吗？</p>
<p>好在，现在咱们有了const泛型，也就是针对值的泛型，正好可以用于处理数组长度的问题：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn display_array&lt;T: std::fmt::Debug, const N: usize&gt;(arr: [T; N]) {
    println!(&quot;{:?}&quot;, arr);
}
fn main() {
    let arr: [i32; 3] = [1, 2, 3];
    display_array(arr);

    let arr: [i32; 2] = [1, 2];
    display_array(arr);
}
</code></pre></pre>
<p>如上所示，我们定义了一个类型为 <code>[T; N]</code> 的数组，其中 <code>T</code> 是一个基于类型的泛型参数，这个和之前讲的泛型没有区别，而重点在于 <code>N</code> 这个泛型参数，它是一个基于值的泛型参数！因为它用来替代的是数组的长度。</p>
<p><code>N</code> 就是const泛型，定义的语法是 <code>const N: usize</code>，表示const泛型N，它基于的值类型是 <code>usize</code>。</p>
<p>在泛型参数之前，Rust完全不适合复杂矩阵的运算，自从有了const泛型，一切即将改变。</p>
<h4 id="const泛型表达式"><a class="header" href="#const泛型表达式">const泛型表达式</a></h4>
<p>假设我们某段代码需要在内存很小的平台上工作，因此需要限制函数参数占用的内存大小，此时就可以使用const泛型表达式来实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021">// 目前只能在nightly版本下使用
#![allow(incomplete_features)]
#![feature(generic_const_exprs)]

fn something&lt;T&gt;(val: T)
where
    Assert&lt;{ core::mem::size_of::&lt;T&gt;() &lt; 768 }&gt;: IsTrue,
    //       ^-----------------------------^ 这里是一个const表达式，换成其它的const表达式也可以
{
    //
}

fn main() {
    something([0u8; 0]); // ok
    something([0u8; 512]); // ok
    something([0u8; 1024]); // 编译错误，数组长度是1024字节，超过了768字节的参数长度限制
}

// ---

pub enum Assert&lt;const CHECK: bool&gt; {
    //
}

pub trait IsTrue {
    //
}

impl IsTrue for Assert&lt;true&gt; {
    //
}
</code></pre></pre>
<h4 id="const-fn"><a class="header" href="#const-fn">const fn</a></h4>
<p>@todo</p>
<h2 id="泛型的性能"><a class="header" href="#泛型的性能">泛型的性能</a></h2>
<p>在Rust中泛型是零成本的抽象，意味着你在使用泛型时，完全不用担心性能上的问题。</p>
<p>但是任何选择都是权衡得失的，既然我们获得了性能上的巨大优势，那么又失去了什么呢？Rust是在编译期为泛型对应的多个类型，生成各自的代码，因此损失了编译速度和增大了最终生成文件的大小。</p>
<p>具体来说：</p>
<p>Rust 通过在编译时进行泛型代码的 <strong>单态化</strong>（<em>monomorphization</em>）来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。</p>
<p>编译器所做的工作正好与我们创建泛型函数的步骤相反，编译器寻找所有泛型代码被调用的位置并针对具体类型生成代码。</p>
<p>让我们看看一个使用标准库中 <code>Option</code> 枚举的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<p>当 Rust 编译这些代码的时候，它会进行单态化。编译器会读取传递给 <code>Option&lt;T&gt;</code> 的值并发现有两种 <code>Option&lt;T&gt;</code>：一种对应 <code>i32</code> 另一种对应 <code>f64</code>。为此，它会将泛型定义 <code>Option&lt;T&gt;</code> 展开为 <code>Option_i32</code> 和 <code>Option_f64</code>，接着将泛型定义替换为这两个具体的定义。</p>
<p>编译器生成的单态化版本的代码看起来像这样：</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>我们可以使用泛型来编写不重复的代码，而 Rust 将会为每一个实例编译其特定类型的代码。这意味着在使用泛型时没有运行时开销；当代码运行，它的执行效率就跟好像手写每个具体定义的重复代码一样。这个单态化过程正是 Rust 泛型在运行时极其高效的原因。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="特征trait"><a class="header" href="#特征trait">特征Trait</a></h1>
<p>如果我们想定义一个文件系统，那么把该系统跟底层存储解耦是很重要的。文件操作主要包含三个：<code>open</code>、<code>write</code>、<code>read</code>，这些操作可以发生在硬盘，也可以发生在缓存，可以通过网络也可以通过(我实在编不下去了，大家来帮帮我)。总之如果你要为每一种情况都单独实现一套代码，那这种实现将过于繁杂，而且也没那个必要。</p>
<p>要解决上述问题，需要把这些行为抽象出来，就要使用Rust中的特征 <code>trait</code> 概念。可能你是第一次听说这个名词，但是不要怕，如果学过其他语言，那么大概率你听说过接口，没错，特征很类似接口。</p>
<p>在之前的代码中，我们也多次见过特征的使用，例如 <code>#[derive(Debug)]</code>，它在我们定义的类型（struct）上自动派生 <code>Debug</code> 特征，接着可以使用 <code>println!(&quot;{:?}&quot;,x)</code> 打印这个类型；再例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) -&gt; T {
    a + b
}
<span class="boring">}
</span></code></pre></pre>
<p>通过 <code>std::ops::Add</code> 特征来限制<code>T</code>，只有 <code>T</code> 实现了 <code>std::ops::Add</code> 才能进行合法的加法操作，毕竟不是所有的类型都能进行相加。</p>
<p>这些都说明一个道理，特征定义了<strong>一个可以被共享的行为，只要实现了特征，你就能使用该行为</strong>。</p>
<h2 id="定义特征"><a class="header" href="#定义特征">定义特征</a></h2>
<p>如果不同的类型具有相同的行为，那么我们就可以定义一个特征，然后为这些类型实现该特征。<strong>定义特征</strong>是把一些方法组合在一起，目的是定义一个实现某些目标所必需的行为的集合。</p>
<p>例如，我们现在有文章<code>Post</code>和微博<code>Weibo</code>两种内容载体，而我们想对相应的内容进行总结，也就是无论是文章内容，还是微博内容，都可以在某个时间点进行总结，那么总结这个行为就是共享的，因此可以用特征来定义：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p>这里使用 <code>trait</code> 关键字来声明一个特征，<code>Summary</code> 是特征名。在大括号中定义了该特征的所有方法，在这个例子中是： <code>fn summarize(&amp;self) -&gt; String</code>。</p>
<p>特征只定义行为看起来是什么样的，而不定义行为具体是怎么样的。因此，我们只定义特征方法的签名，而不进行实现，此时方法签名结尾是 <code>;</code>，而不是一个 <code>{}</code>。</p>
<p>接下来，每一个实现这个特征的类型都需要具体实现该特征的相应方法，编译器也会确保任何实现 <code>Summary</code> 特征的类型都拥有与这个签名的定义完全一致的 <code>summarize</code> 方法。</p>
<h2 id="为类型实现特征"><a class="header" href="#为类型实现特征">为类型实现特征</a></h2>
<p>因为特征只定义行为看起来是什么样的，因此我们需要为类型实现具体的特征，定义行为具体是怎么样的。</p>
<p>首先来为 <code>Post</code> 和 <code>Weibo</code> 实现 <code>Summary</code> 特征：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
pub struct Post {
    pub title: String, // 标题
    pub author: String, // 作者
    pub content: String, // 内容
}

impl Summary for Post {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;文章{}, 作者是{}&quot;, self.title, self.author)
    }
}

pub struct Weibo {
    pub username: String,
    pub content: String
}

impl Summary for Weibo {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}发表了微博{}&quot;, self.username, self.content)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>实现特征的语法与为结构体、枚举实现方法很像：<code>impl Summary for Post</code>，读作“为<code>Post</code>类型实现 <code>Summary</code> 特征”，然后在 <code>impl</code> 的花括号中实现该特征的具体方法。</p>
<p>接下来就可以在这个类型上调用特征的方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let post = Post{title: &quot;Rust语言简介&quot;.to_string(),author: &quot;Sunface&quot;.to_string(), content: &quot;Rust棒极了!&quot;.to_string()};
    let weibo = Weibo{username: &quot;sunface&quot;.to_string(),content: &quot;好像微博没Tweet好用&quot;.to_string()};
    
    post.summarize();
    weibo.summarize();
}
</code></pre></pre>
<p>运行输出：</p>
<pre><code class="language-console">文章Rust语言简介, 作者是Sunface
sunface发表了微博好像微博没Tweet好用
</code></pre>
<p>说实话，如果特征仅仅如此，你可能会觉得花里胡哨没啥用，接下来就让你见识下 <code>trait</code> 真正的威力。</p>
<h4 id="特征定义与实现的位置孤儿规则"><a class="header" href="#特征定义与实现的位置孤儿规则">特征定义与实现的位置(孤儿规则)</a></h4>
<p>上面我们将 <code>Summary</code> 定义成了 <code>pub</code> 公开的。这样，如果他人想要使用我们的 <code>Summary</code> 特征，则可以引入到他们的包中，然后再进行实现。</p>
<p>关于特征实现与定义的位置，有一条非常重要的原则：<strong>如果你想要为类型 <code>A</code> 实现特征 <code>T</code>，那么 <code>A</code> 或者 <code>T </code>至少有一个是在当前作用域中定义的！</strong>。例如我们可以为上面的 <code>Post</code> 类型实现标准库中的 <code>Display</code> 特征，这是因为 <code>Post</code> 类型定义在当前的作用域中。同时，我们也可以在当前包中为 <code>String</code> 类型实现 <code>Summary</code> 特征，因为 <code>Summary</code> 定义在当前作用域中。</p>
<p>但是你无法在当前作用域中，为 <code>String</code> 类型实现 <code>Display</code> 特征，因为它们俩都定义在标准库中，其定义所在的位置都不在当前作用域，跟你半毛钱关系都没有，看看就行了。</p>
<p>该规则被称为<strong>孤儿规则</strong>，可以确保其它人编写的代码不会破坏你的代码，也确保了你不会莫名其妙就破坏了风马牛不相及的代码。</p>
<h4 id="默认实现"><a class="header" href="#默认实现">默认实现</a></h4>
<p>你可以在特征中定义具有<strong>默认实现</strong>的方法，这样其它类型无需再实现该方法，或者也可以选择重载该方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面为 <code>Summary</code> 定义了一个默认实现，下面我们编写段代码来测试下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Summary for Post {}

impl Summary for Weibo {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}发表了微博{}&quot;, self.username, self.content)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>可以看到，<code>Post</code>选择了默认实现，而<code>Weibo</code>重载了该方法，调用和输出如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;{}&quot;,post.summarize());
    println!(&quot;{}&quot;,weibo.summarize());
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">(Read more...)
sunface发表了微博好像微博没Tweet好用
</code></pre>
<p>默认实现允许调用相同特征中的其他方法，哪怕这些方法没有默认实现。如此，特征可以提供很多有用的功能而只需要实现指定的一小部分内容。例如，我们可以定义 <code>Summary</code> 特征，使其具有一个需要实现的 <code>summarize_author</code> 方法，然后定义一个 <code>summarize</code> 方法，此方法的默认实现调用 <code>summarize_author</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>为了使用 <code>Summary</code>，只需要实现 <code>summarize_author</code> 方法即可：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Summary for Weibo {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
println!(&quot;1 new weibo: {}&quot;, weibo.summarize());

<span class="boring">}
</span></code></pre></pre>
<p><code>weibo.summarize()</code> 会先调用 <code>Summary</code> 特征默认实现的 <code>summarize</code> 方法，通过该方法进而调用 <code>Weibo</code> 为 <code>Summary</code> 实现的 <code>summarize_author</code> 方法，最终输出：<code>1 new weibo: (Read more from @horse_ebooks...)</code>。</p>
<h2 id="使用特征作为函数参数"><a class="header" href="#使用特征作为函数参数">使用特征作为函数参数</a></h2>
<p>之前提到过，特征如果仅仅是用来实现方法，那真的有些大材小用，现在我们来讲下，真正可以让特征大放光彩的地方。</p>
<p>现在，先定义一个函数，使用特征用做函数参数：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify(item: &amp;impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
<span class="boring">}
</span></code></pre></pre>
<p><code>impl Summary</code>，只能说想出这个类型的人真的是起名鬼才，简直太贴切了，故名思义，它的意思是 <code>实现了Summary特征</code> 的 <code>item</code> 参数。</p>
<p>你可以使用任何实现了 <code>Summary</code> 特征的类型作为该函数的参数，同时在函数体内，还可以调用该特征的的方法，例如 <code>summarize</code> 方法。具体的说，可以传递 <code>Post</code> 或 <code>Weibo</code> 的实例来作为参数，而其它类如 <code>String</code> 或者 <code>i32</code> 的类型则不能用做该函数的参数，因为它们没有实现 <code>Summary</code> 特征。</p>
<h2 id="特征约束trait-bound"><a class="header" href="#特征约束trait-bound">特征约束(trait bound)</a></h2>
<p>虽然 <code>impl Trait</code> 这种语法非常好理解，但是实际上它只是一个语法糖：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
<span class="boring">}
</span></code></pre></pre>
<p>真正的完整书写形式如上所述，形如<code>T:Summary</code>被称为<strong>特征约束</strong>。</p>
<p>在简单的场景下 <code>impl Trait</code> 的语法就足够使用，但是对于复杂的场景，特征约束可以让我们拥有更大的灵活性和语法表现能力，例如一个函数接受两个 <code>impl Summary</code> 的参数：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {}
<span class="boring">}
</span></code></pre></pre>
<p>如果函数两个参数是不同的类型，那么上面的方法很好，只要这两个类型都实现了 <code>Summary</code> 特征即可。但是如果我们想要强制函数的两个参数是同一类型呢？上面的语法就无法做到这种限制，此时我们只能使特征约束来实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {}
<span class="boring">}
</span></code></pre></pre>
<p>泛型类型 <code>T</code> 说明了 <code>item1</code> 和 <code>item2</code> 必须拥有同样的类型，同时 <code>T: Summary</code> 说明了 <code>T</code> 必须实现 <code>Summary</code> 特征。</p>
<h4 id="多重约束"><a class="header" href="#多重约束">多重约束</a></h4>
<p>除了单个约束条件，我们还可以指定多个约束条件，例如除了让参数实现 <code>Summary</code> 特征外，还可以让参数实现 <code>Display</code> 特征以控制它的格式化输出：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify(item: &amp;(impl Summary + Display)) {
<span class="boring">}
</span></code></pre></pre>
<p>除了上述的语法糖形式，还能使用特征约束的形式：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {}
<span class="boring">}
</span></code></pre></pre>
<p>通过这两个特征，就可以使用 <code>item.summarize</code> 方法，以及通过 <code>println!(&quot;{}&quot;,item)</code> 来格式化输出 <code>item</code>。</p>
<h4 id="where约束"><a class="header" href="#where约束">Where约束</a></h4>
<p>当特征约束变得很多时，函数的签名将变得很复杂：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
<span class="boring">}
</span></code></pre></pre>
<p>严格来说，上面的例子还是不够复杂，但是我们还是能对其做一些形式上的改进，通过 <code>where</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
<span class="boring">}
</span></code></pre></pre>
<h4 id="使用特征约束有条件的实现方法或特征"><a class="header" href="#使用特征约束有条件的实现方法或特征">使用特征约束有条件的实现方法或特征</a></h4>
<p>特征约束，可以让我们在指定类型 + 指定特征的条件下去实现方法，例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>cmd_display</code> 方法，并不是所有的 <code>Pair&lt;T&gt;</code> 结构体对象都可以拥有，只有 <code>T</code> 同时实现了 <code>Display + PartialOrd</code>的<code>Part&lt;T&gt;</code> 才可以拥有此方法。
该函数可读性会更好，因为泛型参数、参数、返回值都在一起，可以快速的阅读，同时每个泛型参数的特征也在新的代码行中通过<strong>特征约束</strong>进行了约束。</p>
<p><strong>也可以有条件的实现特征</strong>, 例如，标准库为任何实现了 <code>Display</code> 特征的类型实现了 <code>ToString</code> 特征：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p>我们可以对任何实现了 <code>Display</code> 特征的类型调用由 <code>ToString</code> 定义的 <code>to_string</code> 方法。例如，可以将整型转换为对应的 <code>String</code> 值，因为整型实现了 <code>Display</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<h2 id="函数返回中的impl-trait"><a class="header" href="#函数返回中的impl-trait">函数返回中的<code>impl Trait</code></a></h2>
<p>可以通过<code>impl Trait</code>来说明一个函数返回了一个类型，该类型实现了某个特征：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_summarizable() -&gt; impl Summary {
    Weibo {
        username: String::from(&quot;sunface&quot;),
        content: String::from(
            &quot;m1 max太厉害了，电脑再也不会卡&quot;,
        )
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>因为 <code>Weibo</code> 实现了 <code>Summary</code>，因此这里可以用它来作为返回值。要注意的是，虽然我们知道这里是一个 <code>Weibo</code> 类型，但是对于 <code>returns_summarizable</code> 的调用者而言，他只知道返回了一个实现了 <code>Summary</code> 特征的对象，但是并不知道返回了一个 <code>Weibo</code> 类型。</p>
<p>这种 <code>impl Trait</code> 形式的返回值，在一种场景下非常非常有用，那就是返回的真实类型非常复杂，你不知道该怎么声明时(毕竟Rust要求你必须标出所有的类型)，此时就可以用 <code>impl Trait</code> 的方式简单返回。例如，闭包和迭代器就是很复杂，只有编译器才知道那玩意的真实类型，如果让你写出来它们的具体类型，我估计想杀人的心都有，好在你可以用 <code>impl Iterator</code> 来告诉调用者，返回了一个迭代器，因为所有迭代器都会实现 <code>Iterator</code> 特征。</p>
<p>但是这种返回值方式有一个很大的限制：只能有一个具体的类型，例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        Post {
            title: String::from(
                &quot;Penguins win the Stanley Cup Championship!&quot;,
            ),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.&quot;,
            ),
        }
    } else {
        Weibo {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;of course, as you probably already know, people&quot;,
            ),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>以上的代码就无法通过编译，因为它返回了两个不同的类型 <code>Post</code> 和 <code>Weibo</code>。</p>
<pre><code class="language-console">`if` and `else` have incompatible types
expected struct `Post`, found struct `Weibo`
</code></pre>
<p>报错提示我们 <code>if</code> 和 <code>else</code> 返回了不同的类型。如果想要实现返回不同的类型，需要使用下一章节中的<a href="basic/trait/./trait-object.html">特征对象</a>。</p>
<h2 id="修复上一节中的largest函数"><a class="header" href="#修复上一节中的largest函数">修复上一节中的<code>largest</code>函数</a></h2>
<p>还记得上一节中的<a href="basic/trait/./generic#%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3">例子</a>吧,当时留下一个疑问，该如何解决编译报错：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0369]: binary operation `&gt;` cannot be applied to type `T` // 无法在`T`类型上应用`&gt;`运算符
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T` // 考虑使用以下的特征来约束T
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
  |             ^^^^^^^^^^^^^^^^^^^^^^
<span class="boring">}
</span></code></pre></pre>
<p>在 <code>largest</code> 函数体中我们想要使用大于运算符（&gt;）比较两个 <code>T</code> 类型的值。这个运算符是标准库中特征 <code>std::cmp::PartialOrd</code> 的一个默认方法。所以需要在 <code>T</code> 的特征约束中指定 <code>PartialOrd</code>，这样 <code>largest</code> 函数可以用于内部元素类型可比较大小的数组切片。</p>
<p>由于 <code>PartialOrd</code> 位于 <code>prelude</code> 中所以并不需要通过 <code>std::cmp</code> 手动将其引入作用域。所以可以将 <code>largest</code> 的签名修改为如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
<span class="boring">}
</span></code></pre></pre>
<p>但是此时编译，又会出现新的错误：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       help: consider using a reference instead: `&amp;list[0]`

error[E0507]: cannot move out of borrowed content
 --&gt; src/main.rs:4:9
  |
4 |     for &amp;item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
<span class="boring">}
</span></code></pre></pre>
<p>错误的核心是 <code>cannot move out of type [T], a non-copy slice</code>， 原因是<code>T</code>没有<a href="basic/trait/../ownership/ownership.html#%E6%8B%B7%E8%B4%9D(%E6%B5%85%E6%8B%B7%E8%B4%9D)">实现<code>Copy</code>特性</a>，因此我们只能把所有权进行转移，毕竟只有<code>i32</code>等基础类型才实现了 <code>Copy</code> 特性，可以存储在栈上，而 <code>T</code> 可以指代任何类型(严格来说是实现了<code>PartialOrd</code>特征的所有类型)。</p>
<p>因此，为了让T拥有 <code>Copy</code> 特性，我们可以增加特征约束：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p>如果并不希望限制 <code>largest</code> 函数只能用于实现了 <code>Copy</code> 特征的类型，我们可以在 <code>T</code> 的特征约束中指定 <a href="basic/trait/../ownership/ownership.html#%E5%85%8B%E9%9A%86(%E6%B7%B1%E6%8B%B7%E8%B4%9D)"><code>Clone</code>特征</a> 而不是 <code>Copy</code> 特征。并克隆 <code>list</code> 中的每一个值使得 <code>largest</code> 函数拥有其所有权。使用 <code>clone</code> 函数意味着对于类似 <code>String</code> 这样拥有堆上数据的类型，会潜在地分配更多堆上空间，而堆分配在涉及大量数据时可能会相当缓慢。</p>
<p>另一种 <code>largest</code> 的实现方式是返回在 <code>list</code> 中 <code>T</code> 值的引用。如果我们将函数返回值从 <code>T</code> 改为 <code>&amp;T</code> 并改变函数体使其能够返回一个引用，我们将不需要任何 <code>Clone</code> 或 <code>Copy</code> 的特征约束而且也不会有任何的堆分配。尝试自己实现这种替代解决方式吧！</p>
<h2 id="通过derive派生特征"><a class="header" href="#通过derive派生特征">通过<code>derive</code>派生特征</a></h2>
<p>在本书中，形如 <code>#[derive(Debug)]</code> 的代码已经出现了很多次，这种是一种特征派生语法，被 <code>derive</code> 标记的对象会自动实现对应的默认特征代码，继承相应的功能。</p>
<p>例如 <code>Debug</code> 特征，它有一套自动实现的默认代码，当你给一个结构体标记后，就可以使用 <code>println!(&quot;{:?}&quot;,s)</code> 的形式打印该结构体的对象。</p>
<p>再如 <code>Copy</code> 特征，它也有一套自动实现的默认代码，当标记到一个类型上时，可以让这个类型自动实现 <code>Copy</code> 特征，进而可以调用 <code>copy</code> 方法，进行自我复制。</p>
<p>总之，<code>derive</code> 派生出来的是Rust默认给我们提供的特征，在开发过程中极大的简化了自己手动实现相应特征的需求，当然，如果你有特殊的需求，还可以自己手动重载该实现。</p>
<p>详细的 <code>derive</code> 列表参加<a href="basic/trait/../../appendix/derive.html">附录-派生特征</a>。</p>
<h2 id="调用方法需要引入特征"><a class="header" href="#调用方法需要引入特征">调用方法需要引入特征</a></h2>
<p>在一些场景中，使用 <code>as</code> 关键字做类型转换会有比较大的限制，因为你想要在类型转换上拥有完全的控制，例如处理转换错误，那么你将需要 <code>TryInto</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::convert::TryInto;
 
fn main() {
  let a: i32 = 10;
  let b: u16 = 100;

  let b_ = b.try_into()
            .unwrap();

  if a &lt; b_ {
    println!(&quot;Ten is less than one hundred.&quot;);
  }
}
</code></pre></pre>
<p>上面代码中引入了 <code>std::convert::TryInto</code> 特征，但是却没有使用它，可能有些同学会为此困惑，主要原因在于<strong>如果你要使用一个特征的方法，那么你需要引入该特征到当前的作用域中</strong>，我们在上面用到了 <code>try_into</code> 方法，因此需要引入对应的特征。</p>
<p>但是Rust又提供了一个非常便利的办法，即把最常用的标准库中的特征通过<a href="std::convert::TryInto"><code>std::prelude</code></a>模块提前引入到当前作用域中，其中包括了 <code>std::convert::TryInto</code>，你可以尝试删除第一行的代码 <code>use ...</code>，看看是否会报错.</p>
<h2 id="几个综合例子"><a class="header" href="#几个综合例子">几个综合例子</a></h2>
<h4 id="为自定义类型实现操作"><a class="header" href="#为自定义类型实现操作">为自定义类型实现<code>+</code>操作</a></h4>
<p>在Rust中除了数值类型的加法，<code>String</code> 也可以做<a href="basic/trait/../compound-type/string-slice.html#%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2">加法</a>，因为Rust为该类型实现了 <code>std::ops::Add</code> 特征，同理，如果我们为自定义类型实现了该特征，那就可以自己实现 <code>Point1 + Point2</code> 的操作: </p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Add;

// 为Point结构体派生Debug特征，用于格式化输出
#[derive(Debug)]
struct Point&lt;T: Add&lt;T, Output = T&gt;&gt; { //限制类型T必须实现了Add特征，否则无法进行+操作。
    x: T,
    y: T,
}

impl&lt;T: Add&lt;T, Output = T&gt;&gt; Add for Point&lt;T&gt; {
    type Output = Point&lt;T&gt;;

    fn add(self, p: Point&lt;T&gt;) -&gt; Point&lt;T&gt; {
        Point{
            x: self.x + p.x,
            y: self.y + p.y,
        }
    }
}

fn add&lt;T: Add&lt;T, Output=T&gt;&gt;(a:T, b:T) -&gt; T {
    a + b
}

fn main() {
    let p1 = Point{x: 1.1f32, y: 1.1f32};
    let p2 = Point{x: 2.1f32, y: 2.1f32};
    println!(&quot;{:?}&quot;, add(p1, p2));

    let p3 = Point{x: 1i32, y: 1i32};
    let p4 = Point{x: 2i32, y: 2i32};
    println!(&quot;{:?}&quot;, add(p3, p4));
}
</code></pre></pre>
<h4 id="自定义类型的打印输出"><a class="header" href="#自定义类型的打印输出">自定义类型的打印输出</a></h4>
<p>在开发过程中，往往只要使用 <code>#[derive(Debug)]</code> 对我们的自定义类型进行标注，即可实现打印输出的功能：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Point{
    x: i32,
    y: i32
}
fn main() {
    let p = Point{x:3,y:3};
    println!(&quot;{:?}&quot;,p);
}
</code></pre></pre>
<p>但是在实际项目中，往往需要对我们的自定义类型进行自定义的格式化输出，以让用户更好的阅读理解我们的类型，此时就要为自定义类型实现 <code>std::fmt::Display</code> 特征：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![allow(dead_code)]
 
use std::fmt;
use std::fmt::{Display};
 
#[derive(Debug,PartialEq)]
enum FileState {
  Open,
  Closed,
}
 
#[derive(Debug)]
struct File {
  name: String,
  data: Vec&lt;u8&gt;,
  state: FileState,
}
 
impl Display for FileState {
   fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
     match *self {
         FileState::Open =&gt; write!(f, &quot;OPEN&quot;),
         FileState::Closed =&gt; write!(f, &quot;CLOSED&quot;),
     }
   }
}
 
impl Display for File {
   fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
      write!(f, &quot;&lt;{} ({})&gt;&quot;,
             self.name, self.state)
   }
}
 
impl File {
  fn new(name: &amp;str) -&gt; File {
    File {
        name: String::from(name),
        data: Vec::new(),
        state: FileState::Closed,
    }
  }
}
 
fn main() {
  let f6 = File::new(&quot;f6.txt&quot;);
  //...
  println!(&quot;{:?}&quot;, f6);
  println!(&quot;{}&quot;, f6);
}
</code></pre></pre>
<p>以上两个例子较为复杂，目的是为读者展示下真实的使用场景长什么样，因此需要读者细细阅读，最终消化这些知识对于你的Rust之路会有莫大的帮助。</p>
<p>最后，特征和特征约束，是Rust中极其重要的概念，如果你还是没搞懂，强烈建议回头再看一遍，或者寻找相关的资料进行补充学习。如果已经觉得掌握了，那么就可以进入下一节的学习。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="特征对象"><a class="header" href="#特征对象">特征对象</a></h1>
<p>在上一节中有一段代码无法通过编译:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        Post {
           // ...
        }
    } else {
        Weibo {
            // ...
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>其中 <code>Post</code> 和 <code>Weibo</code> 都实现了 <code>Summary</code> 特征，因此上面的函数试图通过返回 <code>impl Summary</code> 来返回这两个类型，但是编译器却无情地报错了，原因是
<code>impl Trait</code> 的返回值类型并不支持多种不同的类型返回，那如果我们想返回多种类型，该怎么办？</p>
<p>再来考虑一个问题：现在在做一款游戏，需要将多个对象渲染在屏幕上，这些对象属于不同的类型，存储在列表中，渲染的时候，需要循环该列表并顺序渲染每个对象，在Rust中该怎么实现？</p>
<p>聪明的同学可能已经能想到一个办法，利用枚举：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
enum UiObject {
    Button,
    SelectBox,
}

fn main() {
    let objects = [
        UiObject::Button,
        UiObject::SelectBox
    ];

    for o in objects {
        draw(o)
    }
}

fn draw(o: UiObject) {
    println!(&quot;{:?}&quot;,o);
}
</code></pre></pre>
<p>Bingo，这个确实是一个办法，但是问题来了，如果你的对象集合并不能事先明确地知道呢？或者别人想要实现一个UI组件呢？此时枚举中的类型是有些缺少的，是不是还要修改你的代码增加一个枚举成员？</p>
<p>总之，在编写这个UI库时，我们无法知道所有的UI对象类型，只知道的是：</p>
<ul>
<li>UI对象的类型不同</li>
<li>需要一个统一的类型来处理这些对象，无论是作为函数参数还是作为列表中的一员</li>
<li>需要对每一个对象调用 <code>draw</code> 方法</li>
</ul>
<p>在拥有继承的语言中，可以定义一个名为 <code>Component</code> 的类，该类上有一个 <code>draw</code> 方法。其他的类比如 <code>Button</code>、<code>Image</code> 和 <code>SelectBox</code> 会从 <code>Component</code> 派生并因此继承 <code>draw</code> 方法。它们各自都可以覆盖 <code>draw</code> 方法来定义自己的行为，但是框架会把所有这些类型当作是 <code>Component</code> 的实例，并在其上调用 <code>draw</code>。不过 Rust 并没有继承，我们得另寻出路。</p>
<h2 id="特征对象定义"><a class="header" href="#特征对象定义">特征对象定义</a></h2>
<p>为了解决上面的所有问题，Rust引入了一个概念 - 特征对象。</p>
<p>在介绍特征对象之前，先来为之前的UI组件定义一个特征：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Draw {
    fn draw(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<p>只要组件实现了 <code>Draw</code> 特征，就可以调用 <code>draw</code> 方法来进行渲染。假设有一个 <code>Button</code> 和 <code>SelectBox</code> 组件实现了 <code>Draw</code> 特征：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // 绘制按钮的代码
    }
}

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // 绘制SelectBox的代码
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>此时，还需要一个动态数组来存储这些UI对象：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Screen {
    pub components: Vec&lt;?&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>注意到上面代码中的 <code>?</code> 吗？它的意思是：我们应该填入什么类型，可以说就之前学过的内容里，你找不到哪个类型可以填入这里，但是因为 <code>Button</code> 和 <code>SelectBox</code> 都实现了 <code>Draw</code> 特征，那我们是不是可以把 <code>Draw</code> 特征的对象作为类型，填入到数组中呢？答案是肯定的。</p>
<p><strong>特征对象</strong>指向实现了 <code>Draw</code> 特征的类型的实例，也就是指向了 <code>Button</code> 或者 <code>SelectBox</code> 的实例，这种映射关系是存储在一张表中，可以在运行时通过特征对象找到具体调用的类型方法。</p>
<p>可以通过<code>&amp;</code>引用或者<code>Box&lt;T&gt;</code>智能指针的方式来创建特征对象:</p>
<pre><pre class="playground"><code class="language-rust edition2021">trait Draw {
    fn draw(&amp;self) -&gt; String; 
}

impl Draw for u8 {
    fn draw(&amp;self) -&gt; String {
        format!(&quot;u8: {}&quot;, *self) 
    } 
}

impl Draw for f64 {
    fn draw(&amp;self) -&gt; String {
        format!(&quot;f64: {}&quot;, *self) 
    } 
}

fn draw1(x: Box&lt;dyn Draw&gt;) {
    x.draw();
}

fn draw2(x: &amp;dyn Draw) {
    x.draw();
}

fn main() {
    let x = 1.1f64;
    // do_something(&amp;x);
    let y = 8u8;

    draw1(Box::new(x));
    draw1(Box::new(y));
    draw2(&amp;x);
    draw2(&amp;y);
}
</code></pre></pre>
<p>上面代码，有几个非常重要的点：</p>
<ul>
<li><code>draw1</code> 函数的参数是 <code>Box&lt;dyn Draw&gt;</code> 形式的特征对象，该特征对象是通过 <code>Box::new(x)</code> 的方式创建的</li>
<li><code>draw2</code> 函数的参数是 <code>&amp;dyn Draw</code> 形式的特征对象，该特征对象是通过 <code>&amp;x</code> 的方式创建的</li>
<li><code>dyn</code> 关键字只用在特征对象的类型声明上，在创建时无需使用 <code>dyn</code></li>
</ul>
<p>因此，可以使用特征对象来代表泛型或具体的类型。</p>
<p>继续来完善之前的UI组件代码，首先来实现 <code>Screen</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>其中存储了一个动态数组，里面元素的类型是 <code>Draw</code> 特征对象：<code>Box&lt;dyn Draw&gt;</code>，任何实现了 <code>Draw</code> 特征的类型，都可以存放其中。</p>
<p>再来为 <code>Screen</code> 定义 <code>run</code> 方法，用于将列表中的UI组件渲染在屏幕上：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>至此，我们就完成了之前的目标：在列表中存储多种不同类型的实例，然后将它们使用同一个方法逐一渲染在屏幕上！</p>
<p>再来看看，如果通过泛型实现，会如何：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
    where T: Draw {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面的 <code>Screen</code> 的列表中，存储了类型为 <code>T</code> 的元素，然后在 <code>Screen</code> 中使用特征约束让 <code>T</code> 实现了 <code>Draw</code> 特征，进而可以调用 <code>draw</code> 方法。</p>
<p>但是这种写法限制了 <code>Screen</code> 实例的 <code>Vec&lt;T&gt;</code> 中的每个元素必须是 <code>Button</code> 类型或者全是 <code>SelectBox</code> 类型。如果只需要同质（相同类型）集合，更倾向于这种写法：使用泛型和 特征约束，因为实现更清晰，且性能更好(特征对象，需要在运行时从 <code>vtable</code> 动态查找需要调用的方法。</p>
<p>现在来运行渲染下咱们精心设计的UI组件列表：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;)
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}
</code></pre></pre>
<p>上面使用 <code>Box::new(T)</code> 的方式来创建了两个 <code>Box&lt;dyn Draw&gt;</code> 特征对象，如果以后还需要增加一个UI组件，那么让该组件实现 <code>Draw</code> 特征，则可以很轻松的将其渲染在屏幕上，甚至用户可以引入我们的库作为三方库，然后在自己的库中为自己的类型实现 <code>Draw</code> 特征，然后进行渲染。</p>
<p>在动态类型语言中，有一个很重要的概念： <strong>鸭子类型</strong>（<em>duck typing</em>），简单来说，就是只关心值长啥样，而不关心它实际是什么。当一个东西走起来像鸭子，叫起来像鸭子，那么它就是一只鸭子，就算它实际上是一个奥特曼，也不重要，我们就当它是鸭子。</p>
<p>在上例中，<code>Screen</code> 在 <code>run</code> 的时候，我们并不需要知道各个组件的具体类型是什么。它也不检查组件到底是 <code>Button</code> 还是 <code>SelectBox</code> 的实例，只要它实现了 <code>Draw</code> 特征，就能通过 <code>Box::new</code> 包装成 <code>Box&lt;dyn Draw&gt;</code> 特征对象，然后被渲染在屏幕上。</p>
<p>使用特征对象和 Rust 类型系统来进行类似鸭子类型操作的优势是，无需在运行时检查一个值是否实现了特定方法或者担心在调用时因为值没有实现方法而产生错误。如果值没有实现特征对象所需的特征， 那么 Rust 根本就不会编译这些代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let screen = Screen {
        components: vec![
            Box::new(String::from(&quot;Hi&quot;)),
        ],
    };

    screen.run();
}
</code></pre></pre>
<p>因为 <code>String</code> 类型没有实现 <code>Draw</code> 特征，编译器直接就会报错，不会让上述代码运行。如果想要 <code>String</code> 类型被渲染在屏幕上，那么只需要为其实现 <code>Draw</code> 特征即可，非常容易。</p>
<h4 id="dyn和boxdyn的区别"><a class="header" href="#dyn和boxdyn的区别">&amp;dyn和Box&lt;dyn&gt;的区别</a></h4>
<p>前文提到， <code>&amp;dyn</code> 和 <code>Box&lt;dyn&gt;</code> 都可以用于特征对象，因此在功能上 <code>&amp;dyn</code> 和 <code>Box&lt;dyn&gt;</code> 几乎没有区别，唯一的区别就是：<code>&amp;dyn</code> 减少了一次指针调用。</p>
<p>因为 <code>Box&lt;dyn&gt;</code> 是一个宽指针(<code>fat pointer</code>)，它需要一次额外的解引用后，才能获取到指向<code>vtable</code>的指针，然后再通过该指针访问 <code>vtable</code> 查询到具体的函数指针，最后进行调用。</p>
<p>所以，如果你在乎性能，又想使用特征对象简化代码，可以优先考虑 <code>&amp;dyn</code>。</p>
<p>注意 <code>dyn</code> 不能单独作为特征对象的定义，例如下面的代码编译器会报错，原因是特征对象可以是任意实现了某个特征的类型，编译器在编译期不知道该类型的大小，不同的类型大小是不同的。</p>
<p>而 <code>&amp;dyn</code> 和 <code>Box&lt;dyn&gt;</code> 在编译期都是已知大小，所以可以用作特征对象的定义。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw2(x: dyn Draw) {
    x.draw();
}
<span class="boring">}
</span></code></pre></pre>
<pre><code>10 | fn draw2(x: dyn Draw) {
   |          ^ doesn't have a size known at compile-time
   |
   = help: the trait `Sized` is not implemented for `(dyn Draw + 'static)`
help: function arguments must have a statically known size, borrowed types always have a known size
</code></pre>
<h2 id="特征对象的动态分发"><a class="header" href="#特征对象的动态分发">特征对象的动态分发</a></h2>
<p>回忆一下泛型章节我们提到过的，泛型是在编译期完成处理的：编译器会为每一个泛型参数对应的具体类型生成一份代码，这种方式是<strong>静态分发(static dispatch)</strong>，因为是在编译期完成的，对于运行期性能完全没有任何影响。</p>
<p>与静态分发相对应的是<strong>动态分发(dynamic dispatch)</strong>，在这种情况下，直到运行时，才能确定需要调用什么方法。</p>
<p>当使用特征对象时，Rust 必须使用动态分发。编译器无法知晓所有可能用于特征对象代码的类型，所以它也不知道应该调用哪个类型的哪个方法实现。为此，Rust 在运行时使用特征对象中的指针来知晓需要调用哪个方法。动态分发也阻止编译器有选择的内联方法代码，这会相应的禁用一些优化。</p>
<h2 id="self与self"><a class="header" href="#self与self">Self与self</a></h2>
<p>在Rust中，有两个<code>self</code>，一个指代当前的实例对象，一个指代特征或者方法类型的别名：</p>
<pre><pre class="playground"><code class="language-rust edition2021">trait Draw {
    fn draw(&amp;self) -&gt;  Self;
}

#[derive(Clone)]
struct Button;
impl Draw for Button {
    fn draw(&amp;self) -&gt; Self {
        return self.clone()
    }
}

fn main() {
    let button = Button;
    let newb = button.draw();
}
</code></pre></pre>
<p>上述代码中，<code>self</code>指代的就是当前的实例对象，也就是 <code>button.draw()</code> 中的 <code>button</code> 实例，<code>Self</code> 则指代的是 <code>Button</code> 类型。</p>
<p>当理解了 <code>self</code> 与 <code>Self</code> 的区别后，我们再来看看何为对象安全。</p>
<h2 id="特征对象的限制"><a class="header" href="#特征对象的限制">特征对象的限制</a></h2>
<p>不是所有特征都能拥有特征对象，只有对象安全的特征才行。当一个特征的所有方法都有如下属性时，它的对象才是安全的：</p>
<ul>
<li>方法的返回类型不能是 <code>Self</code></li>
<li>方法没有任何泛型参数</li>
</ul>
<p>对象安全对于特征对象是必须的，因为一旦有了特征对象，就不再需要知道实现该特征的具体类型是什么了。如果特征方法返回了具体的 <code>Self</code> 类型，但是特征对象忘记了其真正的类型，那这个 <code>Self</code> 就非常尴尬，因为没人知道它是谁了。但是对于泛型类型参数来说，当使用特征时其会放入具体的类型参数：此具体类型变成了实现该特征的类型的一部分。而当使用特征对象时其具体类型被抹去了，故而无从得知放入泛型参数类型到底是什么。</p>
<p>标准库中的 <code>Clone</code> 特征就不符合对象安全的要求：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>因为它的其中一个方法，返回了 <code>Self</code> 类型，因此它是对象不安全的。</p>
<p><code>String</code> 类型实现了 <code>Clone</code> 特征， <code>String</code> 实例上调用 <code>clone</code> 方法时会得到一个 <code>String</code> 实例。类似的，当调用 <code>Vec&lt;T&gt;</code> 实例的 <code>clone</code> 方法会得到一个 <code>Vec&lt;T&gt;</code> 实例。<code>clone</code> 的签名需要知道什么类型会代替 <code>Self</code>，因为这是它的返回值。</p>
<p>如果违反了对象安全的规则，编译器会提示你。例如，如果尝试使用之前的 <code>Screen</code> 结构体来存放实现了 <code>Clone</code> 特征的类型：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Clone&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>将会得到如下错误：</p>
<pre><code class="language-text">error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --&gt; src/lib.rs:2:5
  |
2 |     pub components: Vec&lt;Box&lt;dyn Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone`
  cannot be made into an object
  |
  = note: the trait cannot require that `Self : Sized`
</code></pre>
<p>这意味着不能以这种方式使用此特征作为特征对象。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="深入了解特征"><a class="header" href="#深入了解特征">深入了解特征</a></h1>
<p>特征之于Rust更甚于接口之于其他语言，因此特征在Rust中很重要也相对较为复杂，我们决定把特征分为两篇进行介绍，<a href="basic/trait/./trait.html">第一篇</a>在之前已经讲过，现在就是第二篇：关于特征的进阶篇，会讲述一些不常用到但是你该了解的特性。</p>
<h2 id="关联类型"><a class="header" href="#关联类型">关联类型</a></h2>
<p>在方法一章中，我们将到了<a href="basic/trait/../method.html#%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0">关联函数</a>，但是实际上关联类型和关联函数并没有任何交集，虽然它们的名字有一半的交集。</p>
<p>关联类型是在特征定义的语句块中，申明一个自定义类型，这样就可以在特征的方法签名中使用该类型：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>以上是标准库中的迭代器特征 <code>Iterator</code>，它有一个 <code>Item</code> 关联类型，用于替代遍历的值的类型。</p>
<p>同时，<code>next</code> 方法也返回了一个 <code>Item</code> 类型，不过使用 <code>Option</code> 枚举进行了包裹，假如迭代器中的值是 <code>i32</code> 类型，那么调用 <code>next</code> 方法就将获取一个 <code>Option&lt;i32&gt;</code> 的值。</p>
<p>还记得 <code>Self</code> 吧？在之前的章节<a href="basic/trait/./trait-object#Self%E4%B8%8Eself">提到过</a>， <code>Self</code> 用来指代当前的特征实例，那么 <code>Self::Item</code> 就用来指代特征实例中具体的 <code>Item</code> 类型：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
<span class="boring">}
</span></code></pre></pre>
<p>在上述代码中，我们为 <code>Counter</code> 类型实现了 <code>Iterator</code> 特征，那么 <code>Self</code> 就是当前的 <code>Iterator</code> 特征对象， <code>Item</code> 就是 <code>u32</code> 类型。</p>
<p>聪明的读者之所以聪明，是因为你们喜欢联想和举一反三，同时你们也喜欢提问：为何不用泛型，例如如下代码</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;Item&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>答案其实很简单，为了代码的可读性，当你使用了泛型后，你需要在所有地方都这样写 <code>Iterator&lt;Item&gt;</code>，而使用了关联类型，你只需要这样写 <code>Iterator</code>，当类型定义复杂时，这种写法可以极大的增加可读性：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait CacheableItem: Clone + Default + fmt::Debug + Decodable + Encodable {
  type Address: AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hash;
  fn is_null(&amp;self) -&gt; bool;
}
<span class="boring">}
</span></code></pre></pre>
<p>例如上面的代码， <code>Address</code> 的写法自然远比 <code>AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hash</code> 要简单的多，而且含义清晰。</p>
<p>再例如，如果使用泛型，你将得到以下的代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Container&lt;A,B&gt; {
    fn contains(&amp;self,a: A,b: B) -&gt; bool;
}

fn difference&lt;A,B,C&gt;(container: &amp;C) -&gt; i32
  where
    C : Container&lt;A,B&gt; {...}
<span class="boring">}
</span></code></pre></pre>
<p>可以看到，由于使用了泛型，导致函数头部也必须增加泛型的声明，而使用关联类型，将得到可读性好的多的代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Container{
    type A;
    type B;
    fn contains(&amp;self, a: &amp;Self::A, b: &amp;Self::B) -&gt; bool;
}

fn difference&lt;C: Container&gt;(container: &amp;C) {}
<span class="boring">}
</span></code></pre></pre>
<h2 id="默认泛型类型参数"><a class="header" href="#默认泛型类型参数">默认泛型类型参数</a></h2>
<p>当使用泛型类型参数时，可以为其指定一个默认的具体类型，例如标准库中的 <code>std::ops::Add</code> 特征：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;RHS=Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>它有一个泛型参数 <code>RHS</code>，但是与我们以往的用法不同，这里它给 <code>RHS</code> 一个默认值，也就是当用户不指定 <code>RHS</code> 时，默认使用两个同样类型的值进行相加，然后返回一个关联类型 <code>Output</code>。</p>
<p>可能上面那段不太好理解，下面我们用代码来举例：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}
</code></pre></pre>
<p>上面的代码主要干了一件事，就是为 <code>Point</code> 结构体提供 <code>+</code> 的能力，这就是<strong>运算符重载</strong>，不过Rust并不支持创建自定义运算符，你也无法为所有运算符进行重载，目前来说，只有定义在 <code>std::ops</code> 中的运算符才能进行重载。</p>
<p>跟 <code>+</code> 对应的特征是 <code>std::ops::Add</code>，我们在之前也看过它的定义 <code>trait Add&lt;RHS=Self&gt;</code>，但是上面的例子中并没有为 <code>Point</code> 实现 <code>Add&lt;RHS&gt;</code> 特征，而是实现了 <code>Add</code> 特征（没有默认泛型类型参数），这意味着我们使用了 <code>RHS</code> 的默认类型，也就是 <code>Self</code>。换句话说，我们这里定义的是两个相同的 <code>Point</code> 类型相加，因此无需指定 <code>RHS</code>。</p>
<p>与上面的例子相反，下面的例子，我们来创建两个不同类型的相加：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这里，是进行 <code>Millimeters + Meters</code> 两种数据类型的 <code>+</code> 操作，因此此时不能再使用默认的 <code>RHS</code>，否则就会变成 <code>Millimeters + Millimeters</code> 的形式。使用 <code>Add&lt;Meters&gt;</code> 可以将 <code>RHS</code> 指定为 <code>Meters</code>，那么 <code>fn add(self, rhs: RHS)</code> 自然而言的变成了 <code>Millimeters</code> 和 <code>Meters</code> 的相加。</p>
<p>默认类型参数主要用于两个方面：</p>
<ol>
<li>减少实现的样板代码</li>
<li>扩展类型但是无需大幅修改现有的代码</li>
</ol>
<p>之前的例子就是第一点，虽然效果也就那样。在 <code>+</code> 左右两边都是同样类型时，只需要 <code>impl Add</code> 即可，否则你需要 <code>impl Add&lt;SOME_TYPE&gt;</code>，嗯，会多写几个字:)</p>
<p>对于第二点，也很好理解，如果你在一个复杂类型的基础上，新引入一个泛型参数，可能需要修改很多地方，但是如果新引入的泛型参数有了默认类型，情况就会好很多，添加泛型参数后，使用这个类型的代码需要逐个在类型提示部分添加泛型参数，就很麻烦；但是有了默认参数（且默认参数取之前的实现里假设的值的情况下）之后，原有的使用这个类型的代码就不需要做改动了。</p>
<p>归根到底，默认泛型参数，是有用的，但是大多数情况下，咱们确实用不到，当需要用到时，大家再回头来查阅本章即可，<strong>手上有剑，心中不慌</strong>。</p>
<h2 id="调用同名的方法"><a class="header" href="#调用同名的方法">调用同名的方法</a></h2>
<p>不同特征拥有同名的方法是很正常的事情，你没有任何办法阻止这一点；甚至除了特征上的同名方法外，在你的类型上，也有同名方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*waving arms furiously*&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这里，不仅仅两个特征 <code>Pilot</code> 和 <code>Wizard</code> 有 <code>fly</code> 方法，就连实现那两个特征的 <code>Human</code> 元结构体，也拥有一个同名方法 <code>fly</code> (这世界怎么了，非要这么卷吗？程序员何苦难为程序员，哎)。</p>
<p>既然代码已经不可更改，那下面我们来讲讲该如何调用这些 <code>fly</code> 方法。</p>
<h4 id="优先调用类型上的方法"><a class="header" href="#优先调用类型上的方法">优先调用类型上的方法</a></h4>
<p>当调用 <code>Human</code> 实例的 <code>fly</code> 时，编译器默认调用该类型中定义的方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let person = Human;
    person.fly();
}
</code></pre></pre>
<p>这段代码会打印 <code>*waving arms furiously*</code>，说明直接调用了类型上定义的方法。</p>
<h4 id="调用特征上的方法"><a class="header" href="#调用特征上的方法">调用特征上的方法</a></h4>
<p>为了能够调用两个特征的方法，需要使用显式调用的语法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let person = Human;
    Pilot::fly(&amp;person); // 调用Pilot特征上的方法
    Wizard::fly(&amp;person); // 调用Wizard特征上的方法
    person.fly(); // 调用Human类型自身的方法
}
</code></pre></pre>
<p>运行后依次输出：</p>
<pre><code class="language-console">This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>因为 <code>fly</code> 方法的参数是 <code>self</code>，当显式调用时，编译器就可以根据调用的类型( <code>self</code> 的类型)决定具体调用哪个方法。</p>
<p>这个时候问题又来了，如果方法没有 <code>self</code> 参数呢？稍等，估计有读者会问：还有方法没有 <code>self</code> 参数？看到这个疑问，作者的眼泪不禁流了下来，大明湖畔的<a href="basic/trait/../method.html#%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0">关联函数</a>，你还记得嘛？</p>
<p>但是成年人的世界，就算再伤心，事还得做，咱们继续：</p>
<pre><pre class="playground"><code class="language-rust edition2021">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());
}
</code></pre></pre>
<p>就像人类妈妈会给自己的宝宝起爱称一样，狗妈妈也会。狗妈妈称呼自己的宝宝为<strong>Spot</strong>，其它动物称呼狗宝宝为<strong>puppy</strong>，这个时候假如有动物不知道该称如何呼狗宝宝，它需要查询一下。</p>
<p><code>Dog::baby_name()</code> 的调用方式显然不行，因为这只是狗妈妈对宝宝的爱称，可能你会想到通过下面的方式查询其他动物对狗狗的称呼：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
}
</code></pre></pre>
<p>铛铛，无情报错了：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0283]: type annotations needed // 需要类型注释
  --&gt; src/main.rs:20:43
   |
20 |     println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^ cannot infer type // 无法推断类型
   |
   = note: cannot satisfy `_: Animal`
<span class="boring">}
</span></code></pre></pre>
<p>因为单纯从 <code>Animal::baby_name()</code> 上，编译器无法得到任何有效的信息：实现 <code>Animal</code> 特征的类型可能有很多，你究竟是想获取哪个动物宝宝的名称？狗宝宝？猪宝宝？还是熊宝宝？</p>
<p>此时，就需要使用<strong>完全限定语法</strong>。</p>
<h5 id="完全限定语法"><a class="header" href="#完全限定语法">完全限定语法</a></h5>
<p>完全限定语法是调用函数最为明确的方式：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
}
</code></pre></pre>
<p>在尖括号中，通过 <code>as</code> 关键字，我们向Rust编译器提供了类型注解，也就是 <code>Animal</code> 就是 <code>Dog</code>，而不是其他动物，因此最终会调用 <code>impl Animal for Dog</code> 中的方法，获取到其它动物对狗宝宝的称呼：<strong>puppy</strong>。</p>
<p>言归正题，完全限定语法定义为：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
<span class="boring">}
</span></code></pre></pre>
<p>上面定义中，第一个参数是方法接收器<code>receiver</code>(三种<code>self</code>)，只有方法才拥有，例如关联函数就没有<code>receiver</code>。</p>
<p>完全限定语法可以用于任何函数或方法调用，那么我们为何很少用到这个语法？原因是Rust编译器能根据上下文自动推导出调用的路径，因此大多数时候，我们都无需使用完全限定语法。只有当存在多个同名函数或方法，且Rust无法区分出你想调用的目标函数时，该用法才能真正有用武之地。</p>
<h2 id="特征定义中的特征约束"><a class="header" href="#特征定义中的特征约束">特征定义中的特征约束</a></h2>
<p>有时，我们会需要让某个特征A能使用另一个特征B的功能(另一种形式的特征约束)，这种情况下，不仅仅要为类型实现特征A，还要为类型实现特征B才行，这就是 <code>supertrait</code> (实在不知道该如何翻译，有大佬指导下嘛？)</p>
<p>例如有一个特征 <code>OutlinePrint</code>，它有一个方法，能够对当前的实现类型进行格式化输出：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

trait OutlinePrint: Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>等等，这里有一个眼熟的语法: <code>OutlinePrint: Display</code>，感觉很像之前讲过的<strong>特征约束</strong>，只不过用在了特征定义中而不是函数的参数中，是的，在某种意义上来说，这和特征约束非常类似，都用来说明一个特征需要实现另一个特征，这里就是：如果你想要实现 <code>OutlinePrint</code> 特征，首先你需要实现 <code>Display</code> 特征。</p>
<p>想象一下，假如没有这个特征约束，那么 <code>self.to_string</code> 还能够调用吗( <code>to_string</code> 方法会为实现 <code>Display</code> 特征的类型自动实现)？编译器肯定是不愿意的，会报错说当前作用域中找不到用于 <code>&amp;Self</code> 类型的方法 <code>to_string</code> ：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">}
</span></code></pre></pre>
<p>因为 <code>Point</code> 没有实现 <code>Display</code> 特征，会得到下面的报错：</p>
<pre><code class="language-console">error[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter;
try using `:?` instead if you are using a format string
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
</code></pre>
<p>既然我们有求于编译器，那只能选择满足它咯：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面代码为 <code>Point</code> 实现了 <code>Display</code> 特征，那么 <code>to_string</code> 方法也将自动实现：最终获得字符串是通过这里的 <code>fmt</code> 方法获得的。</p>
<h2 id="在外部类型上实现外部特征newtype"><a class="header" href="#在外部类型上实现外部特征newtype">在外部类型上实现外部特征(newtype)</a></h2>
<p>在<a href="basic/trait/./trait#%E7%89%B9%E5%BE%81%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE(%E5%AD%A4%E5%84%BF%E8%A7%84%E5%88%99)">特征</a>章节中，有提到孤儿规则，简单来说，就是特征或者类型必需至少有一个是本地的，才能在此类型上定义特征。</p>
<p>这里提供一个办法来绕过孤儿规则，那就是使用<strong>newtype模式</strong>，简而言之：就是为一个<a href="basic/trait/../compound-type/struct.html#%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93">元组结构体</a>创建新类型。该元组结构体封装有一个字段，该字段就是希望实现特征的具体类型。</p>
<p>该封装类型是本地的，因此我们可以为此类型实现外部的特征。</p>
<p><code>newtype</code> 不仅仅能实现以上的功能，而且它在运行时没有任何性能损耗，因为在编译期，该类型会被自动忽略。</p>
<p>下面来看一个例子，我们有一个动态数组类型： <code>Vec&lt;T&gt;</code>，它定义在标准库中，还有一个特征 <code>Display</code>，它也定义在标准库中，如果没有 <code>newtype</code>，我们是无法为 <code>Vec&lt;T&gt;</code> 实现 <code>Display</code> 的：</p>
<pre><code class="language-console">error[E0117]: only traits defined in the current crate can be implemented for arbitrary types
--&gt; src/main.rs:5:1
|
5 | impl&lt;T&gt; std::fmt::Display for Vec&lt;T&gt; {
| ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^------
| |                             |
| |                             Vec is not defined in the current crate
| impl doesn't use only types from inside the current crate
|
= note: define and implement a trait or new type instead
</code></pre>
<p>编译器给了我们提示： <code>define and implement a trait or new type instead</code>，重新定义一个特征，或者使用 <code>new type</code>，前者当然不可行，那么来试试后者：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<p>其中， <code>struct Wrapper(Vec&lt;String&gt;)</code> 就是一个元组结构体，它定义了一个新类型 <code>Wrapper</code>，代码很简单，相信大家也很容易看懂。</p>
<p>既然<code>new type</code>有这么多好处，它有没有不好的地方呢？答案是肯定的。注意到我们怎么访问里面的数组吗？<code>self.0.join(&quot;, &quot;)</code>，是的，很啰嗦，因为需要先从 <code>Wrapper</code> 中取出数组: <code>self.0</code>，然后才能执行 <code>join</code> 方法。</p>
<p>类似的，任何数组上的方法，你都无法直接调用，需要先用 <code>self.0</code> 取出数组，然后再进行调用。</p>
<p>当然，解决办法还是有的，要不怎么说Rust是极其强大灵活的编程语言！Rust提供了一个特征叫<a href="basic/trait/../../traits/deref.html"> <code>Deref</code> </a>，实现该特征后，可以自动做一层类似类型转换的操作，可以将 <code>Wrapper</code> 变成 <code>Vec&lt;String&gt;</code> 来使用。这样就会像直接使用数组那样去使用 <code>Wrapper</code>，而无需为每一个操作都添加上 <code>self.0</code>。</p>
<p>同时，如果不想 <code>Wrapper</code> 暴漏底层数组的所有方法，我们还可以为 <code>Wrapper</code> 去重载这些方法，实现隐藏的目的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集合类型"><a class="header" href="#集合类型">集合类型</a></h1>
<p>在Rust标准库中有这样一批原住民，它们天生贵族，当你看到的一瞬间，就能爱上它们，上面是我瞎编的，其实主要是离了它们不行，不信等会我介绍后，你放个狠话，非它们不用试试？</p>
<p>集合在Rust中是一类比较特殊的类型，因为Rust中大多数数据类型都只能代表一个特定的值，但是集合却可以代表一大堆值。而且与语言级别的数组、字符串类型不同，标准库里的这些家伙是分配在堆上，因此都可以进行动态的增加和减少。</p>
<p>瞧，第一个集合排着整体的队列登场了，它里面的每个元素都雄赳赳气昂昂跟在另外一个元素后面，大小、宽度、高度竟然全部一致，真是令人惊叹。 它就是 <code>Vector</code> 类型，允许你创建一个动态数组，它里面的元素是一个紧挨着另一个排列的。</p>
<p>紧接着，第二个集合在全场的嘘声和羡慕眼光中闪亮登场，只见里面的元素排成一对一对的，彼此都手牵着手，非对方莫属，这种情深深雨蒙蒙的样子真是...挺欠扁的。 它就是 <code>HashMap</code> 类型，该类型允许你在里面存储 <code>KV</code> 对，每一个 <code>K</code> 都有唯一的 <code>V</code> 与之配对。</p>
<p>最后，请用热烈的掌声迎接我们的 <code>String </code>集合，哦，抱歉，<code>String</code> 集合天生低调，见不得前两个那样，因此被气走了，你可以去<a href="basic/collections/../compound-type/string-slice">这里</a>找它。</p>
<p>言归正传，本章所讲的 <code>Vector</code>、<code>HashMap </code>再加上之前的 <code>String</code> 类型，是标准库中最最常用的集合类型，可以说，几乎任何一段代码中都可以找到它们的身影，那么先来看看<code>Vector</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动态数组vector"><a class="header" href="#动态数组vector">动态数组Vector</a></h1>
<p>动态数组类型用<code>Vec&lt;T&gt;</code>表示，事实上，在之前的章节，它的身影多次出现，我们一直没有细讲，只是简单的把它当作数组处理。</p>
<p>动态数组允许你存储多个值，这些值在内存中一个紧挨着另一个排列，因此访问其中某个元素的成本非常低。动态数组只能存储相同类型的元素，如果你想存储不同类型的元素，可以使用之前讲过的枚举类型或者特征对象。</p>
<p>总之，当我们想拥有一个列表，里面都是相同类型的数据时，动态数组将会非常有用。</p>
<h2 id="创建动态数组"><a class="header" href="#创建动态数组">创建动态数组</a></h2>
<p>在Rust中，有多种方式可以创建动态数组。</p>
<h4 id="vecnew"><a class="header" href="#vecnew">Vec::new</a></h4>
<p>使用 <code>Vec::new</code> 创建动态数组是最 rusty 的方式，它调用了 <code>Vec</code> 中的 <code>new</code> 关联函数：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<p>这里，<code>v</code> 被显式地声明了类型<code>Vec&lt;i32&gt;</code>，这是因为 Rust 编译器无法从 <code>Vec::new()</code> 中得到任何关于类型的暗示信息，因此也无法推导出 <code>v</code> 的具体类型，但是当你向里面增加一个元素后，一切又不同了：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = Vec::new();
v.push(1);
<span class="boring">}
</span></code></pre></pre>
<p>此时，<code>v</code> 就无需手动声明类型，因为编译器通过 <code>v.push(1)</code>，推测出 <code>v</code> 中的元素类型是 <code>i32</code>，因此推导出 <code>v</code> 的类型是 <code>Vec&lt;i32&gt;</code>。</p>
<blockquote>
<p>如果预先知道要存储的元素个数，可以使用 <code>Vec::with_capacity(capacity)</code> 创建动态数组，这样可以避免因为插入大量新数据导致频繁的内存分配和拷贝，提升性能</p>
</blockquote>
<h4 id="vec"><a class="header" href="#vec">vec![]</a></h4>
<p>还可以使用宏 <code>vec!</code> 来创建数组，与 <code>Vec::new</code> 有所不同，前者能在创建同时给予初始化值：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p>同样，此处的 <code>v</code> 也无需标注类型，编译器只需检查它内部的元素即可自动推导出 <code>v</code> 的类型是 <code>Vec&lt;i32&gt;</code> (Rust中，整数默认类型是i32，在<a href="basic/collections/../base-type/numbers.html#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B">数值类型</a>中有详细介绍)。</p>
<h2 id="更新vector"><a class="header" href="#更新vector">更新Vector</a></h2>
<p>向数组尾部添加元素，可以使用 <code>push</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = Vec::new();
v.push(1);
<span class="boring">}
</span></code></pre></pre>
<p>与其它类型一样，必须将 <code>v</code> 声明为 <code>mut</code> 后，才能进行修改。</p>
<h2 id="vector与其元素共存亡"><a class="header" href="#vector与其元素共存亡">Vector与其元素共存亡</a></h2>
<p>跟结构体一样，<code>Vector</code> 类型在超出作用域范围后，会被自动删除：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let v = vec![1, 2, 3];

    // ...
} // &lt;- v超出作用域并在此处被删除
<span class="boring">}
</span></code></pre></pre>
<p>当 <code>Vector</code> 被删除后，它内部存储的所有内容也会随之被删除。目前来看，这种解决方案简单直白，但是当 <code>Vector</code> 中的元素被引用后，事情可能会没那么简单。</p>
<h2 id="从vector中读取元素"><a class="header" href="#从vector中读取元素">从Vector中读取元素</a></h2>
<p>读取指定位置的元素有两种方式可选：通过下标索引访问或者使用 <code>get</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
println!(&quot;第三个元素是 {}&quot;, third);

match v.get(2) {
    Some(third) =&gt; println!(&quot;第三个元素是 {}&quot;, third),
    None =&gt; println!(&quot;去你的第三个元素，根本没有！&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>和其它语言一样，集合类型的索引下标都是从 <code>0</code> 开始，<code>&amp;v[2]</code> 表示借用 <code>v</code> 中的第三个元素，最终会获得该元素的引用。而 <code>v.get(2)</code> 也是访问第三个元素，但是有所不同的是，它返回了 <code>Option&lt;&amp;T&gt;</code>，因此还需要额外的 <code>match</code> 来匹配解构出具体的值。</p>
<h4 id="下标索引与-get-的区别"><a class="header" href="#下标索引与-get-的区别">下标索引与 <code>.get</code> 的区别</a></h4>
<p>这两种方式都能成功的读取到指定的数组元素，既然如此为什么会存在两种方法？何况 <code>.get</code> 还会增加使用复杂度，让我们通过示例说明：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
<span class="boring">}
</span></code></pre></pre>
<p>运行以上代码，<code>&amp;v[100]</code> 的访问方式会导致程序无情报错退出，因为发生了数组越界访问。 但是 <code>v.get</code> 就不会，它在内部做了处理，有值的时候返回 <code>Some(T)</code>，无值的时候返回 <code>None</code>，因此 <code>v.get</code> 的使用方式非常安全。</p>
<p>既然如此，为何不统一使用 <code>v.get</code> 的形式？因为实在是有些啰嗦，Rust语言的设计者和使用者在审美这方面还是相当统一的：简洁即正义，何况性能上也会有轻微的损耗。</p>
<p>既然有两个选择，肯定就有如何选择的问题，答案很简单，当你确保索引不会越界的时候，就用索引访问，否则用 <code>.get</code>。例如，访问第几个数组元素并不取决于我们，而是取决于用户的输入时，用 <code>.get</code> 会非常适合，天知道那些可爱的用户会输入一个什么样的数字进来！</p>
<h5 id="同时借用多个数组元素"><a class="header" href="#同时借用多个数组元素">同时借用多个数组元素</a></h5>
<p>既然涉及到借用数组元素，那么很可能会遇到同时借用多个数组元素的情况，还记得在<a href="basic/collections/../ownership/borrowing.html#%E5%80%9F%E7%94%A8%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93">所有权和借用</a>章节咱们讲过的借用规则嘛？如果记得，就来看看下面的代码：）</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);

println!(&quot;The first element is: {}&quot;, first);
<span class="boring">}
</span></code></pre></pre>
<p>先不运行，来推断下结果，首先 <code>first = &amp;v[0]</code> 进行了不可变借用，<code>v.push</code> 进行了可变借用，如果 <code>first</code> 在 <code>v.push</code> 之后不再使用，那么该段代码可以成功编译(原因见<a href="basic/collections/../ownership/borrowing.html#%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8">引用的作用域</a>)。</p>
<p>可是上面的代码中，<code>first</code> 这个不可变借用在可变借用 <code>v.push</code> 后被使用了，那么妥妥的，编译器就会报错：</p>
<pre><code class="language-console">$ cargo run
Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable 无法对v进行可变借用，因此之前已经进行了不可变借用
--&gt; src/main.rs:6:5
|
4 |     let first = &amp;v[0];
|                  - immutable borrow occurs here // 不可变借用发生在此处
5 | 
6 |     v.push(6);
|     ^^^^^^^^^ mutable borrow occurs here // 可变借用发生在此处
7 | 
8 |     println!(&quot;The first element is: {}&quot;, first);
|                                          ----- immutable borrow later used here // 不可变借用在这里被使用

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` due to previous error
</code></pre>
<p>其实，按理来说，这两个引用不应该互相影响的：一个是查询元素，一个是在数组尾部插入元素，完全不相干的操作，为何编译器要这么严格呢？</p>
<p>原因在于：数组的大小是可变的，当旧数组的大小不够用时，Rust会重新分配一块更大的内存空间，然后把旧数组拷贝过来。这种情况下，之前的引用显然会指向一块无效的内存，这非常rusty - 对用户进行严格的教育。</p>
<p>其实想想，<strong>在长大之后，我们感激人生路上遇到过的严师益友，正是因为他们，我们才在正确的道路上不断前行，虽然在那个时候，并不能理解他们</strong>，而 Rust 就如那个良师益友，它不断的在纠正我们不好的编程习惯，直到某一天，你发现自己能写出一次性通过的漂亮代码时，就能明白它的良苦用心。</p>
<blockquote>
<p>若读者想要更深入的了解<code>Vec&lt;T&gt;</code>，可以看看[Rustonomicon]，其中从零手撸一个动态数组，非常适合深入学习</p>
</blockquote>
<h2 id="迭代遍历vector中的元素"><a class="header" href="#迭代遍历vector中的元素">迭代遍历Vector中的元素</a></h2>
<p>如果想要依次访问数组中的元素，可以使用迭代的方式去遍历数组，这种方式比用下标的方式去遍历数组更安全也更高效(每次下标访问都会触发数组边界检查)：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<p>也可以在迭代过程中，修改 <code>Vector</code> 中的元素：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3];
for i in &amp;mut v {
    *i += 10
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="存储不同类型的元素"><a class="header" href="#存储不同类型的元素">存储不同类型的元素</a></h2>
<p>在本节开头，有讲到数组的元素必需类型相同，但是也提到了解决方案：那就是通过使用枚举类型和特征对象来实现不同类型元素的存储。先来看看通过枚举如何实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
enum IpAddr {
    V4(String),
    V6(String)
}
fn main() {
    let v = vec![
        IpAddr::V4(&quot;127.0.0.1&quot;.to_string()),
        IpAddr::V6(&quot;::1&quot;.to_string())
    ];

    for ip in v {
        show_addr(ip)
    }
}

fn show_addr(ip: IpAddr) {
    println!(&quot;{:?}&quot;,ip);
}
</code></pre></pre>
<p>数组 <code>v</code> 中存储了两种不同的 <code>ip</code> 地址，但是这两种都属于 <code>IpAddr</code> 枚举类型的成员，因此可以存储在数组中。</p>
<p>再来看看特征对象的实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021">trait IpAddr {
    fn display(&amp;self);
}

struct V4(String);
impl IpAddr for V4 {
    fn display(&amp;self) {
        println!(&quot;ipv4: {:?}&quot;,self.0)
    }
}
struct V6(String);
impl IpAddr for V6 {
    fn display(&amp;self) {
        println!(&quot;ipv6: {:?}&quot;,self.0)
    }
}

fn main() {
    let v: Vec&lt;Box&lt;dyn IpAddr&gt;&gt; = vec![
        Box::new(V4(&quot;127.0.0.1&quot;.to_string())),
        Box::new(V6(&quot;::1&quot;.to_string())),
    ];

    for ip in v {
        ip.display();
    }
}
</code></pre></pre>
<p>比枚举实现要稍微复杂一些，我们为 <code>V4</code> 和 <code>V6</code> 都实现了特征 <code>IpAddr</code>，然后将它俩的实例用 <code>Box::new</code> 包裹后，存在了数组 <code>v</code> 中，需要注意的是，这里必需手动的指定类型：<code>Vec&lt;Box&lt;dyn IpAddr&gt;&gt;</code>，表示数组 <code>v</code> 存储的是特征 <code>IpAddr</code> 的对象，这样就实现了在数组中存储不同的类型。</p>
<p>在实际使用场景中，特征对象数组要比枚举数组常见很多，主要原因在于<a href="basic/collections/../trait/trait-object.html">特征对象非常灵活</a>，而编译器对枚举的限制较多，且无法动态增加类型。</p>
<p>最后，如果你想要了解 <code>Vector </code>更多的用法，请参见本书的标准库解析章节：<a href="basic/collections/../../std/vector.html"><code>Vector</code>常用方法</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kv存储hashmap"><a class="header" href="#kv存储hashmap">KV存储HashMap</a></h1>
<p>和动态数组一样，<code>HashMap</code> 也是 Rust 标准库中提供的集合类型，但是又与动态数组不同，<code>HashMap</code> 中存储的是一一映射的 <code>KV </code>键值对，并提供了平均复杂度为 <code>O(1)</code> 的查询方法，当我们希望通过一个 <code>Key</code> 去查询值时，该类型非常有用，以致于 <code>Go语言</code> 将该类型设置成了语言级别的内置特性。</p>
<p>Rust 中哈希类型（哈希映射）为 <code>HashMap&lt;K,V&gt;</code>，在其它语言中，也有类似的数据结构，例如 <code>hash map</code>，<code>map</code>，<code>object</code>，<code>hash table</code>，<code>字典</code>等等，引用小品演员孙涛的一句台词：大家都是本地狐狸，别搁那装貂 :)。</p>
<h2 id="创建hashmap"><a class="header" href="#创建hashmap">创建HashMap</a></h2>
<p>跟创建动态数组 <code>Vec</code> 的方法类似，可以使用 <code>new</code> 方法来创建<code> HashMap</code>，然后通过<code> insert</code> 方法插入键值对。</p>
<h4 id="使用new方法创建"><a class="header" href="#使用new方法创建">使用new方法创建</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

// 创建一个HashMap，用于存储宝石种类和对应的数量
let mut my_gems = HashMap::new();

// 将宝石类型和对应的数量写入表中
my_gems.insert(&quot;红宝石&quot;, 1);
my_gems.insert(&quot;蓝宝石&quot;, 2);
my_gems.insert(&quot;河边捡的误以为是宝石的破石头&quot;, 18);
<span class="boring">}
</span></code></pre></pre>
<p>很简单对吧？跟其它语言没有区别，聪明的同学甚至能够猜到该 <code>HashMap</code> 的类型： <code>HashMap&lt;&amp;str,i32&gt;</code>。</p>
<p>但是还有一点，你可能没有注意，那就是使用 <code>HashMap</code> 需要手动通过 <code>use ...</code> 从标准库中引入到我们当前的作用域中来，仔细回忆下，之前使用另外两个集合类型 <code>String</code> 和<code> Vec</code> 时，我们是否有手动引用过？答案是 <code>No</code>，因为 <code>HashMap</code> 并没有包含在Rust的<a href="basic/collections/../../appendix/prelude.html"><code>prelude</code></a>中(Rust为了简化用户使用，提前将最常用的类型自动引入到作用域中)。</p>
<p>所有的集合类型都是动态的，意味着它们没有固定的内存大小，因此它们底层的数据都存储在内存堆上，然后通过一个存储在栈中的引用类型来访问。同时，跟其它集合类型一致，<code>HashMap</code> 也是内聚性的，即所有的<code>K</code>必须拥有同样的类型，<code>V</code>也是如此。</p>
<blockquote>
<p>跟Vec一样，如果预先知道要存储的KV对个数，可以使用 <code>HashMap::with_capacity(capacity)</code> 创建指定大小的HashMap，避免频繁的内存分配和拷贝，提升性能</p>
</blockquote>
<h4 id="使用迭代器和collect方法创建"><a class="header" href="#使用迭代器和collect方法创建">使用迭代器和collect方法创建</a></h4>
<p>在实际使用中，不是所有的场景都能 <code>new</code> 一个哈希表后，然后悠哉悠哉的依次插入对应的键值对，而是可能会从另外一个数据结构中，获取到对应的数据，最终生成 <code>HashMap</code>。</p>
<p>例如考虑一个场景，有一张表格中记录了足球联赛中各队伍名称和积分的信息，这张表如果被导入到Rust项目中，一个合理的数据结构是 <code>Vec&lt;(String,u32)&gt;</code> 类型，该数组中的元素是一个个元组，该数据结构跟表格数据非常契合：表格中的数据都是逐行存储，每一个行都存有一个 <code>(队伍名称,积分)</code> 的信息。</p>
<p>但是在很多时候，又需要通过队伍名称来查询对应的积分，此时动态数组就不适用了，因此可以用 <code>HashMap</code> 来保存相关的<strong>队伍名称 -&gt; 积分</strong>映射关系。 理想很骨感，现实很丰满，如何将 <code>Vec&lt;(String, u32)&gt;</code> 中的数据快速写入到<code>HashMap&lt;String, u32&gt;</code>中？</p>
<p>一个动动脚趾头就能想到的笨方法如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    use std::collections::HashMap;

    let teams_list = vec![
        (&quot;中国队&quot;.to_string(), 100),
        (&quot;美国队&quot;.to_string(),10),
        (&quot;日本队&quot;.to_string(),50),
    ];

    let mut teams_map = HashMap::new();
    for team in &amp;teams_list {
        teams_map.insert(&amp;team.0, team.1);
    }
    
    println!(&quot;{:?}&quot;,teams_map)
}
</code></pre></pre>
<p>遍历列表，将每一个元组作为一对 <code>KV </code>插入到 <code>HashMap</code> 中，很简单，但是。。。也不太聪明的样子，换个词说就是 - 不够<code>rusty</code>。</p>
<p>好在，Rust为我们提供了一个非常精妙的解决办法：先将 <code>Vec</code> 转为迭代器，接着通过 <code>collect</code> 方法，将迭代器中的元素收集后，转成 <code>HashMap</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    use std::collections::HashMap;

    let teams_list = vec![
        (&quot;中国队&quot;.to_string(), 100),
        (&quot;美国队&quot;.to_string(),10),
        (&quot;日本队&quot;.to_string(),50),
    ];

    let teams_map: HashMap&lt;_,_&gt; = teams_list.into_iter().collect();
    
    println!(&quot;{:?}&quot;,teams_map)
}
</code></pre></pre>
<p>代码很简单，<code>into_iter</code> 方法将列表转为迭代器，接着通过 <code>collect</code> 进行收集，不过需要注意的是，<code>collect</code> 方法在内部实际上支持生成多种类型的目标集合，因为我们需要通过类型标注 <code>HashMap&lt;_,_&gt;</code> 来告诉编译器：请帮我们收集为 <code>HashMap</code> 集合类型，具体的 <code>KV</code> 类型，麻烦编译器您老人家帮我们推导。</p>
<p>由此可见，Rust中的编译器时而小聪明，时而大聪明，不过好在，它大聪明的时候，会自家人知道自己事，总归会通知你一声：</p>
<pre><code class="language-console">error[E0282]: type annotations needed 需要类型标注
  --&gt; src/main.rs:10:9
   |
10 |     let teams_map = teams_list.into_iter().collect(); 
   |         ^^^^^^^^^ consider giving `teams_map` a type 给予teams_map一个具体的类型
</code></pre>
<h2 id="所有权转移"><a class="header" href="#所有权转移">所有权转移</a></h2>
<p><code>HashMap</code> 的所有权规则与其它 Rust 类型没有区别：</p>
<ul>
<li>若类型实现 <code>Copy</code> 特征，该类型会被复制进 <code>HashMap</code>，因此无所谓所有权</li>
<li>若没实现 <code>Copy</code> 特征，所有权将被转移给<code>HashMap</code>中</li>
</ul>
<p>例如我参选帅气男孩时的场景再现：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    use std::collections::HashMap;

    let name = String::from(&quot;Sunface&quot;);
    let age = 18;

    let mut handsome_boys = HashMap::new();
    handsome_boys.insert(name, age);

    println!(&quot;因为过于无耻，{}已经被从帅气男孩名单中除名&quot;, name);
    println!(&quot;还有，他的真实年龄远远不止{}岁&quot;,age);
}
</code></pre></pre>
<p>运行代码，报错如下：</p>
<pre><code class="language-console">error[E0382]: borrow of moved value: `name`
  --&gt; src/main.rs:10:32
   |
4  |     let name = String::from(&quot;Sunface&quot;);
   |         ---- move occurs because `name` has type `String`, which does not implement the `Copy` trait
...
8  |     handsome_boys.insert(name, age);
   |                          ---- value moved here
9  | 
10 |     println!(&quot;因为过于无耻，{}已经被除名&quot;, name);
   |                                            ^^^^ value borrowed here after move
</code></pre>
<p>提示很清晰，<code>name</code> 是 <code>String</code> 类型，因此它受到所有权的限制，在 <code>insert</code> 时，它的所有权被转移给 <code>handsome_boys</code>，所以最后在使用时，会遇到这个无情但是意料之中的报错。</p>
<p><strong>如果你使用引用类型放入HashMap中</strong>，请确保该引用的生命周期至少跟 <code>HashMap</code> 活得一样久：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    use std::collections::HashMap;

    let name = String::from(&quot;Sunface&quot;);
    let age = 18;

    let mut handsome_boys = HashMap::new();
    handsome_boys.insert(&amp;name, age);

    std::mem::drop(name);
    println!(&quot;因为过于无耻，{:?}已经被除名&quot;, handsome_boys);
    println!(&quot;还有，他的真实年龄远远不止{}岁&quot;,age);
}
</code></pre></pre>
<p>上面代码，我们借用 <code>name</code> 获取了它的引用，然后插入到 <code>handsome_boys</code> 中，至此一切都很完美。但是紧接着，就通过 <code>drop</code> 函数手动将 <code>name</code> 字符串从内存中移除，再然后就报错了：</p>
<pre><code class="language-console"> handsome_boys.insert(&amp;name, age);
   |                          ----- borrow of `name` occurs here // name借用发生在此处
9  | 
10 |     std::mem::drop(name);
   |                    ^^^^ move out of `name` occurs here // name的所有权被转移走
11 |     println!(&quot;因为过于无耻，{:?}已经被除名&quot;, handsome_boys);
   |                                              ------------- borrow later used here // 所有权转移后，还试图使用name
</code></pre>
<p>最终，某人因为过于无耻，真正的被除名了 :)</p>
<h2 id="查询hashmap"><a class="header" href="#查询hashmap">查询HashMap</a></h2>
<p>通过 <code>get</code> 方法可以获取元素：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score: Option&lt;&amp;i32&gt; = scores.get(&amp;team_name);
<span class="boring">}
</span></code></pre></pre>
<p>上面有几点需要注意：</p>
<ul>
<li><code>get</code> 方法返回一个 <code>Option&lt;&amp;i32&gt; </code>类型：当查询不到时，会返回一个 <code>None</code>，查询到时返回 <code>Some(&amp;i32)</code></li>
<li><code>&amp;i32</code> 是对 <code>HashMap</code> 中值的借用，如果不使用借用，可能会发生所有权的转移</li>
</ul>
<p>还可以通过循环的方式依次遍历 <code>KV</code> 对：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
<span class="boring">}
</span></code></pre></pre>
<p>最终输出：</p>
<pre><code class="language-console">Yellow: 50
Blue: 10
</code></pre>
<h2 id="更新hashmap中的值"><a class="header" href="#更新hashmap中的值">更新HashMap中的值</a></h2>
<p>更新值的时候，涉及多种情况，咱们在代码中一一进行说明：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(&quot;Blue&quot;, 10);

    // 覆盖已有的值
    let old = scores.insert(&quot;Blue&quot;, 20);
    assert_eq!(old, Some(10));

    // 查询新插入的值
    let new = scores.get(&quot;Blue&quot;);
    assert_eq!(new, Some(&amp;20));
    
    // 查询Yellow对应的值，若不存在则插入新值
    let v = scores.entry(&quot;Yellow&quot;).or_insert(5);
    assert_eq!(*v, 5); // 不存在，插入5

    // 查询Yellow对应的值，若不存在则插入新值
    let v = scores.entry(&quot;Yellow&quot;).or_insert(50);
    assert_eq!(*v, 5); // 已经存在，因此50没有插入
}
</code></pre></pre>
<p>具体的解释在代码注释中已有，这里不再进行赘述。</p>
<h4 id="在已有值的基础上更新"><a class="header" href="#在已有值的基础上更新">在已有值的基础上更新</a></h4>
<p>另一个常用场景如下：查询某个 <code>key</code> 对应的值，若不存在则插入新值，若存在则对已有的值进行更新，例如在文本中统计词语出现的次数：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();
// 根据空格来切分字符串(英文单词都是通过空格切分)
for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
<span class="boring">}
</span></code></pre></pre>
<p>上面代码中，新建一个 <code>map</code> 用于保存词语出现的次数，插入一个词语时会进行判断：若之前没有插入过，则使用该词语作Key，插入次数0作为Value，若之前插入过则取出之前统计的该词语出现的次数，对其加一。</p>
<p>有两点值得注意：</p>
<ul>
<li><code>or_insert</code> 返回了 <code>&amp;mut v</code> 引用，因此可以通过该可变引用直接修改 <code>map</code> 中对应的值</li>
<li>使用 <code>count</code> 引用时，需要先进行解引用 <code>*count</code>，否则会出现类型不匹配</li>
</ul>
<h2 id="哈希函数"><a class="header" href="#哈希函数">哈希函数</a></h2>
<p>你肯定比较好奇，为何叫哈希表，到底什么是哈希。</p>
<p>先来设想下，如果要实现 <code>Key</code> 与 <code>Value</code> 的一一对应，是不是意味着我们要能比较两个 <code>Key</code> 的相等性？例如&quot;a&quot;和&quot;b&quot;，1和2，当这些类型做Key且能比较时，可以很容易知道 <code>1</code> 对应的值不会错误的映射到 <code>2</code> 上，因为 <code>1</code> 不等于 <code>2</code>。因此，一个类型能否作为 <code>Key</code> 的关键就是是否能进行相等比较，或者说该类型是否实现了 <code>std::cmp::Eq</code> 特征。</p>
<blockquote>
<p>f32和f64浮点数，没有实现 <code>std::cmp::Eq</code> 特征，因此不可以用作 <code>HashMap</code> 的 <code>Key</code></p>
</blockquote>
<p>好了，理解完这个，再来设想一点，若一个复杂点的类型作为Key，那怎么在底层对它进行存储，怎么使用它进行查询和比较？ 是不是很棘手？好在我们有哈希函数：通过它把 <code>Key</code> 计算后映射为哈希值，然后使用该哈希值来进行存储、查询、比较等操作。</p>
<p>但是问题又来了，如何保证不同 <code>Key</code> 通过哈希后的两个值不会相同？如果相同，那意味着我们使用不同的 <code>Key</code>，却查到了同一个结果，这种明显是错误的行为。
此时，就涉及到安全性跟性能的取舍了。</p>
<p>若要追求安全，尽可能减少冲突，同时防止拒绝服务(Denial of Service, DoS)攻击，就要使用密码学安全的哈希函数，<code>HashMap</code> 就是使用了这样的哈希函数。反之若要追求性能，就需要使用没有那么安全的算法。</p>
<h4 id="高性能三方库"><a class="header" href="#高性能三方库">高性能三方库</a></h4>
<p>因此若性能测试显示当前标准库默认的哈希函数不能满足你的性能需求，就需要去<a href="https://crates.io"><code>crates.io</code></a>上寻找其它的哈希函数实现，使用方法很简单：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::hash::BuildHasherDefault;
use std::collections::HashMap;
// 引入第三方的哈希函数
use twox_hash::XxHash64;

// 指定HashMap使用第三方的哈希函数XxHash64
let mut hash: HashMap&lt;_, _, BuildHasherDefault&lt;XxHash64&gt;&gt; = Default::default();
hash.insert(42, &quot;the answer&quot;);
assert_eq!(hash.get(&amp;42), Some(&amp;&quot;the answer&quot;));
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>目前，<code>HashMap</code> 使用的哈希函数是 <code>SipHash</code>，它的性能不是很高，但是安全性很高。<code>SipHash</code> 在中等大小的 <code>Key</code> 上，性能相当不错，但是对于小型的 <code>Key</code> (例如整数)或者大型 <code>Key</code> (例如字符串)来说，性能还是不够好。若你需要极致性能，例如实现算法，可以考虑这个库：<a href="https://github.com/tkaitchuck/ahash">ahash</a></p>
</blockquote>
<p>最后，如果你想要了解 <code>HashMap</code> 更多的用法，请参见本书的标准库解析章节：<a href="basic/collections/../../std/hashmap.html">HashMap常用方法</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h1>
<p>Rust 是类型安全的语言，因此在 Rust 中做类型转换不是一件简单的事，这一章节我们将对 Rust 中的类型转换进行详尽讲解。</p>
<h2 id="as转换"><a class="header" href="#as转换"><code>as</code>转换</a></h2>
<p>先来看一段代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  let a: i32 = 10;
  let b: u16 = 100;

  if a &lt; b {
    println!(&quot;Ten is less than one hundred.&quot;);
  }
}
</code></pre></pre>
<p>能跟着这本书一直学习到这里，说明你对 Rust 已经有了一定的理解，那么一眼就能看出这段代码注定会报错，因为 <code>a</code> 和 <code>b</code> 拥有不同的类型，Rust 不允许两种不同的类型进行比较。</p>
<p>解决办法很简单，只要把 <code>b</code> 转换成 <code>i32</code> 类型即可，Rust 中内置了一些基本类型之间的转换，这里使用 <code>as</code> 操作符来完成： <code>if a &lt; (b as i32) {...}</code>。那么为什么不把 <code>a</code> 转换成 <code>u16</code> 类型呢？</p>
<p>因为每个类型能表达的数据范围不同，如果把范围较大的类型转换成较小的类型，会造成错误，因此我们需要把范围较小的类型转换成较大的类型，来避免这些问题的发生。</p>
<blockquote>
<p>使用类型转换需要小心，因为如果执行以下操作 <code>300_i32 as i8</code>，你将获得 <code>44</code> 这个值，而不是 <code>300</code>，因为 <code>i8</code> 类型能表达的的最大值为 <code>2^7 - 1</code>，使用以下代码可以查看 <code>i8</code> 的最大值：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = i8::MAX;
println!(&quot;{}&quot;,a);
<span class="boring">}
</span></code></pre></pre>
<p>下面列出了常用的转换形式：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let a = 3.1 as i8;
   let b = 100_i8 as i32;
   let c = 'a' as u8; // 将字符'a'转换为整数，97

   println!(&quot;{},{},{}&quot;,a,b,c)
}
</code></pre></pre>
<h4 id="内存地址转换为指针"><a class="header" href="#内存地址转换为指针">内存地址转换为指针</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut values: [i32; 2] = [1, 2];
let p1: *mut i32 = values.as_mut_ptr();
let first_address = p1 as usize; // 将p1内存地址转换为一个整数
let second_address = first_address + 4; // 4 == std:mem::size_of::&lt;i32&gt;()，i32类型占用4个字节，因此将内存地址 + 4
let p2 = second_address as *mut i32; // 访问该地址指向的下一个整数p2
unsafe {
    *p2 += 1;
}
assert_eq!(values[1], 3);
<span class="boring">}
</span></code></pre></pre>
<h4 id="强制类型转换的边角知识"><a class="header" href="#强制类型转换的边角知识">强制类型转换的边角知识</a></h4>
<ol>
<li>数组切片原生指针之间的转换，不会改变数组占用的内存字节数，尽管数组元素的类型发生了改变：</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a: *const [u16] = &amp;[1, 2, 3, 4, 5];
    let b = a as *const [u8];
    assert_eq!(std::mem::size_of_val(&amp;a), std::mem::size_of_val(&amp;b))
}
</code></pre></pre>
<ol start="2">
<li>转换不具有传递性
就算 <code>e as U1 as U2</code> 是合法的，也不能说明 <code>e as U2</code> 是合法的（<code>e</code> 不能直接转换成 <code>U2</code>）。</li>
</ol>
<h2 id="tryinto转换"><a class="header" href="#tryinto转换">TryInto转换</a></h2>
<p>在一些场景中，使用 <code>as</code> 关键字会有比较大的限制。如果你想要在类型转换上拥有完全的控制而不依赖内置的转换，例如处理转换错误，那么可以使用 <code>TryInto</code> ：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::convert::TryInto;
 
fn main() {
   let a: u8 = 10;
   let b: u16 = 1500;
 
   let b_: u8 = b.try_into().unwrap();
 
   if a &lt; b_ {
     println!(&quot;Ten is less than one hundred.&quot;);
   }
}
</code></pre></pre>
<p>上面代码中引入了 <code>std::convert::TryInto</code> 特征，但是却没有使用它，可能有些同学会为此困惑，主要原因在于<strong>如果你要使用一个特征的方法，那么你需要引入该特征到当前的作用域中</strong>，我们在上面用到了 <code>try_into</code> 方法，因此需要引入对应的特征。但是 Rust 又提供了一个非常便利的办法，把最常用的标准库中的特征通过<a href="std::convert::TryInto"><code>std::prelude</code></a>模块提前引入到当前作用域中，其中包括了 <code>std::convert::TryInto</code>，你可以尝试删除第一行的代码 <code>use ...</code>，看看是否会报错。</p>
<p><code>try_into</code> 会尝试进行一次转换，如果失败，则会返回一个 <code>Result</code>，然后你可以进行相应的错误处理，但是因为我们的例子只是为了快速测试，因此使用了 <code>unwrap</code> 方法，该方法在发现错误时，会直接调用 <code>panic</code> 导致程序的崩溃退出，在实际项目中，请不要这么使用，具体见<a href="basic/./exception-error.html#panic">panic</a>部分。</p>
<p>最主要的是 <code>try_into</code> 转换会捕获大类型向小类型转换时导致的溢出错误：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let b: i16 = 1500;

    let b_: u8 = match b.try_into() {
        Ok(b1) =&gt; b1,
        Err(e) =&gt; {
            println!(&quot;{:?}&quot;, e.to_string());
            0
        }
    };
}
</code></pre></pre>
<p>运行后输出如下 <code>&quot;out of range integral type conversion attempted&quot;</code>，在这里我们程序捕获了错误，编译器告诉我们类型范围超出的转换是不被允许的，因为我们试图把 <code>1500_i16</code> 转换为 <code>u8</code> 类型，后者明显不足以承载这么大的值。</p>
<h2 id="通用类型转换"><a class="header" href="#通用类型转换">通用类型转换</a></h2>
<p>虽然 <code>as</code> 和 <code>TryInto</code> 很强大，但是只能应用在数值类型上，可是 Rust 有如此多的类型，想要为这些类型实现转换，我们需要另谋出路，先来看看在一个笨办法，将一个结构体转换为另外一个结构体：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    x: u32,
    y: u16,
}

struct Bar {
    a: u32,
    b: u16,
}

fn reinterpret(foo: Foo) -&gt; Bar {
    let Foo { x, y } = foo;
    Bar { a: x, b: y }
}
<span class="boring">}
</span></code></pre></pre>
<p>简单粗暴，但是从另外一个角度来看，也挺啰嗦的，好在 Rust 为我们提供了更通用的方式来完成这个目的。</p>
<h4 id="强制类型转换"><a class="header" href="#强制类型转换">强制类型转换</a></h4>
<p>在某些情况下，类型是可以进行隐式强制转换的，虽然这些转换弱化了 Rust 的类型系统，但是它们的存在是为了让 Rust 在大多数场景可以工作(说白了，帮助用户省事)，而不是报各种类型上的编译错误。</p>
<p>首先，在匹配特征时，不会做任何强制转换(除了方法)。一个类型 <code>T</code> 可以强制转换为 <code>U</code>，不代表 <code>impl T</code> 可以强制转换为 <code>impl U</code>，例如下面的代码就无法通过编译检查：</p>
<pre><pre class="playground"><code class="language-rust edition2021">trait Trait {}

fn foo&lt;X: Trait&gt;(t: X) {}

impl&lt;'a&gt; Trait for &amp;'a i32 {}

fn main() {
    let t: &amp;mut i32 = &amp;mut 0;
    foo(t);
}
</code></pre></pre>
<p>报错如下：</p>
<pre><code class="language-console">error[E0277]: the trait bound `&amp;mut i32: Trait` is not satisfied
--&gt; src/main.rs:9:9
|
9 |     foo(t);
|         ^ the trait `Trait` is not implemented for `&amp;mut i32`
|
= help: the following implementations were found:
        &lt;&amp;'a i32 as Trait&gt;
= note: `Trait` is implemented for `&amp;i32`, but not for `&amp;mut i32`
</code></pre>
<p><code>&amp;i32</code> 实现了特征 <code>Trait</code>， <code>&amp;mut i32</code> 可以转换为 <code>&amp;i32</code>，但是 <code>&amp;mut i32</code> 依然无法作为 <code>Trait</code> 来使用。<!-- 这一段没读懂，代码中的例子好像和上面的文字描述关系不大 --></p>
<h4 id="点操作符"><a class="header" href="#点操作符">点操作符</a></h4>
<p>方法调用的点操作符看起来简单，实际上非常不简单，它在调用时，会发生很多魔法般的类型转换，例如：自动引用、自动解引用，强制类型转换直到类型能匹配等。</p>
<p>假设有一个方法 <code>foo</code>，它有一个接收器(接收器就是 <code>self</code>、<code>&amp;self</code>、<code>&amp;mut self</code> 参数)。如果调用 <code>value.foo()</code>，编译器在调用 <code>foo</code> 之前，需要决定到底使用哪个 <code>Self</code> 类型来调用。现在假设 <code>value</code> 拥有类型 <code>T</code>。</p>
<p>再进一步，我们使用<a href="https://course.rs/basic/trait/advance-trait.html#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95">完全限定语法</a>来进行准确的函数调用:</p>
<ol>
<li>首先，编译器检查它是否可以直接调用 <code>T::foo(value)</code>，称之为<strong>值方法调用</strong></li>
<li>如果上一步调用无法完成(例如方法类型错误或者特征没有针对 <code>Self</code> 进行实现，上文提到过特征不能进行强制转换)，那么编译器会尝试增加自动引用，以为着编译器会尝试以下调用： <code>&lt;&amp;T&gt;::foo(value)</code> 和 <code>&lt;&amp;mut T&gt;::foo(value)</code>，称之为<strong>引用方法调用</strong></li>
<li>若上面两个方法依然不工作，编译器会试着解引用 <code>T</code> ，然后再进行尝试。这里使用了 <code>Deref</code> 特征 —— 若 <code>T: Deref&lt;Target = U&gt;</code> (<code>T</code> 可以被解引用为 <code>U</code>)，那么编译器会使用 <code>U</code> 类型进行尝试，称之为<strong>解引用方法调用</strong></li>
<li>若 <code>T</code> 不能被解引用，且 <code>T</code> 是一个定长类型(在编译器类型长度是已知的)，那么编译器也会尝试将 <code>T</code> 从定长类型转为不定长类型，例如将 <code>[i32; 2]</code> 转为 <code>[i32]</code></li>
<li>若还是不行，那...没有那了，最后编译器大喊一声：汝欺我甚，不干了！</li>
</ol>
<p>下面我们来用一个例子来解释上面的方法查找算法:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array: Rc&lt;Box&lt;[T; 3]&gt;&gt; = ...;
let first_entry = array[0];
<span class="boring">}
</span></code></pre></pre>
<p><code>array</code> 数组的底层数据隐藏在了重重封锁之后，那么编译器如何使用 <code>array[0]</code> 这种数组原生访问语法通过重重封锁，准确的访问到数组中的第一个元素？</p>
<ol>
<li>首先， <code>array[0]</code> 只是<a href="https://doc.rust-lang.org/std/ops/trait.Index.html"><code>Index</code></a>特征的语法糖：编译器会将 <code>array[0]</code> 转换为 <code>array.index(0)</code> 调用，当然在调用之前，编译器会先检查 <code>array</code> 是否实现了 <code>Index</code> 特征。</li>
<li>接着，编译器检查 <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> 是否有否实现 <code>Index</code> 特征，结果是否，不仅如此，<code>&amp;Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> 与 <code>&amp;mut Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> 也没有实现。</li>
<li>上面的都不能工作，编译器开始对 <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> 进行解引用，把它转变成 <code>Box&lt;[T; 3]&gt;</code></li>
<li>此时继续对 <code>Box&lt;[T; 3]&gt;</code> 进行上面的操作 ：<code>Box&lt;[T; 3]&gt;</code>， <code>&amp;Box&lt;[T; 3]&gt;</code>，和 <code>&amp;mut Box&lt;[T; 3]&gt;</code> 都没有实现 <code>Index</code> 特征，所以编译器开始对 <code>Box&lt;[T; 3]&gt;</code> 进行解引用，然后我们得到了 <code>[T; 3]</code></li>
<li><code>[T; 3]</code> 以及它的各种引用都没有实现 <code>Index</code> 索引(是不是很反直觉:D，在直觉中，数组都可以通过索引访问，实际上只有数组切片才可以!)，它也不能再进行解引用，因此编译器只能祭出最后的大杀器：将定长转为不定长，因此 <code>[T; 3]</code> 被转换成 <code>[T]</code>，也就是数组切片，它实现了 <code>Index</code> 特征，因此最终我们可以通过 <code>index</code> 方法访问到对应的元素。</li>
</ol>
<p>过程看起来很复杂，但是也还好，挺好理解，如果你现在不能彻底理解，也不要紧，等以后对 Rust 理解更深了，同时需要深入理解类型转换时，再来细细品读本章。</p>
<p>再来看看以下更复杂的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_stuff&lt;T: Clone&gt;(value: &amp;T) {
    let cloned = value.clone();
}
<span class="boring">}
</span></code></pre></pre>
<p>上面例子中 <code>cloned</code> 的类型时什么？首先编译器检查能不能进行<strong>值方法调用</strong>， <code>value</code> 的类型是 <code>&amp;T</code>，同时 <code>clone</code> 方法的签名也是 <code>&amp;T</code> ： <code>fn clone(&amp;T) -&gt; T</code>，因此可以进行值方法调用，再加上编译器知道了 <code>T</code> 实现了 <code>Clone</code>，因此 <code>cloned</code> 的类型是 <code>T</code>。</p>
<p>如果 <code>T: Clone</code> 的特征约束被移除呢？</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_stuff&lt;T&gt;(value: &amp;T) {
    let cloned = value.clone();
}
<span class="boring">}
</span></code></pre></pre>
<p>首先，从直觉上来说，该方法会报错，因为 <code>T</code> 没有实现 <code>Clone</code> 特征，但是真实情况是什么呢？</p>
<p>我们先来推导一番。 首先通过值方法调用就不再可行，因为 <code>T</code> 没有实现 <code>Clone</code> 特征，也就无法调用 <code>T</code> 的 <code>clone</code> 方法。接着编译器尝试<strong>引用方法调用</strong>，此时 <code>T</code> 变成 <code>&amp;T</code>，在这种情况下， <code>clone</code> 方法的签名如下： <code>fn clone(&amp;&amp;T) -&gt; &amp;T</code>，接着我们现在对 <code>value</code> 进行了引用。 编译器发现 <code>&amp;T</code> 实现了 <code>Clone</code> 类型(所有的引用类型都可以被复制，因为其实就是复制一份地址)，因此可以可以推出 <code>cloned</code> 也是 <code>&amp;T</code> 类型。</p>
<p>最终，我们复制出一份引用指针，这很合理，因为值类型 <code>T</code> 没有实现 <code>Clone</code>，只能去复制一个指针了。</p>
<p>下面的例子也是自动引用生效的地方：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct Container&lt;T&gt;(Arc&lt;T&gt;);

fn clone_containers&lt;T&gt;(foo: &amp;Container&lt;i32&gt;, bar: &amp;Container&lt;T&gt;) {
    let foo_cloned = foo.clone();
    let bar_cloned = bar.clone();
}
<span class="boring">}
</span></code></pre></pre>
<p>推断下上面的 <code>foo_cloned</code> 和 <code>bar_cloned</code> 是什么类型？提示: 关键在 <code>Container</code> 的泛型参数，一个是 <code>i32</code> 的具体类型，一个是泛型类型，其中 <code>i32</code> 实现了 <code>Clone</code>，但是 <code>T</code> 并没有。</p>
<p>首先要复习一下复杂类型派生 <code>Clone</code> 的规则：一个复杂类型能否派生 <code>Clone</code>，需要它内部的所有子类型都能进行 <code>Clone</code>。因此 <code>Container&lt;T&gt;(Arc&lt;T&gt;)</code> 是否实现 <code>Clone</code> 的关键在于 <code>T</code> 类型是否实现了 <code>Clone</code> 特征。</p>
<p>上面代码中，<code>Container&lt;i32&gt;</code> 实现了 <code>Clone</code> 特征，因此编译器可以直接进行值方法调用，此时相当于直接调用 <code>foo.clone</code>，其中 <code>clone</code> 的函数签名是 <code>fn clone(&amp;T) -&gt; T</code>，由此可以看出 <code>foo_cloned</code> 的类型是 <code>Container&lt;i32&gt;</code>。</p>
<p>然而，<code>bar_cloned</code> 的类型却是 <code>&amp;Container&lt;T&gt;</code>，这个不合理啊，明明我们为 <code>Container&lt;T&gt;</code> 派生了 <code>Clone</code> 特征，因此它也应该是 <code>Container&lt;T&gt;</code> 类型才对。万事皆有因，我们先来看下 <code>derive</code> 宏最终生成的代码大概是啥样的：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Clone for Container&lt;T&gt; where T: Clone {
    fn clone(&amp;self) -&gt; Self {
        Self(Arc::clone(&amp;self.0))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>从上面代码可以看出，派生 <code>Clone</code> 能实现的根本是 <code>T</code> 实现了<a href="https://doc.rust-lang.org/std/clone/trait.Clone.html#derivable"><code>Clone</code>特征</a>：<code>where T: Clone</code>， 因此 <code>Container&lt;T&gt;</code> 就没有实现 <code>Clone</code> 特征。</p>
<p>编译器接着会去尝试引用方法调用，此时 <code>&amp;Container&lt;T&gt;</code> 引用实现了 <code>Clone</code>，最终可以得出 <code>bar_cloned</code> 的类型是 <code>&amp;Container&lt;T&gt;</code>。</p>
<p>当然，也可以为 <code>Container&lt;T&gt;</code> 手动实现 <code>Clone</code> 特征：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Clone for Container&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        Self(Arc::clone(&amp;self.0))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>此时，编译器首次尝试值方法调用即可通过，因此 <code>bar_cloned</code> 的类型变成 <code>Container&lt;T&gt;</code>。</p>
<p>这一块儿内容真的挺复杂，每一个坚持看完的读者都是真正的勇士，我也是：为了写好这块儿内容，作者足足花了 <strong>4</strong> 个小时！</p>
<h4 id="变形记transmutes"><a class="header" href="#变形记transmutes">变形记(Transmutes)</a></h4>
<p>前方危险，敬请绕行！</p>
<p>类型系统，你让开！我要自己转换这些类型，不成功便成仁！虽然本书大多是关于安全的内容，我还是希望你能仔细考虑避免使用本章讲到的内容。这是你在 Rust 中所能做到的真真正正、彻彻底底、最最可怕的非安全行为，在这里，所有的保护机制都形同虚设。</p>
<p>先让你看看深渊长什么样，开开眼，然后你再决定是否深入： <code>mem::transmute&lt;T, U&gt;</code> 将类型 <code>T</code> 直接转成类型 <code>U</code>，唯一的要求就是，这两个类型占用同样大小的字节数！我的天，这也算限制？这简直就是无底线的转换好吧？看看会导致什么问题：</p>
<ol>
<li>首先也是最重要的，转换后创建一个任意类型的实例会造成无法想象的混乱，而且根本无法预测。不要把 <code>3</code> 转换成 <code>bool</code> 类型，就算你根本不会去使用该 <code>bool</code> 类型，也不要去这样转换</li>
<li>变形后会有一个重载的返回类型，即使你没有指定返回类型，为了满足类型推导的需求，依然会产生千奇百怪的类型</li>
<li>将 <code>&amp;</code> 变形为 <code>&amp;mut</code> 是未定义的行为
<ul>
<li>这种转换永远都是未定义的</li>
<li>不，你不能这么做</li>
<li>不要多想，你没有那种幸运</li>
</ul>
</li>
<li>变形为一个未指定生命周期的引用会导致<a href="basic/../advance/lifetime/advance.html">无界生命周期</a></li>
<li>在复合类型之间互相变换时，你需要保证它们的排列布局是一模一样的！一旦不一样，那么字段就会得到不可预期的值，这也是未定义的行为，至于你会不会因此愤怒， <strong>WHO CARES</strong> ，你都用了变形了，老兄！</li>
</ol>
<p>对于第5条，你该如何知道内存的排列布局是一样的呢？对于 <code>repr(C)</code> 类型和 <code>repr(transparent)</code> 类型来说，它们的布局是有着精确定义的。但是对于你自己的&quot;普通却自信&quot;的 Rust 类型 <code>repr(Rust)</code> 来说，它可不是有着精确定义的。甚至同一个泛型类型的不同实例都可以有不同的内存布局。 <code>Vec&lt;i32&gt;</code> 和 <code>Vec&lt;u32&gt;</code> 它们的字段可能有着相同的顺序，也可能没有。对于数据排列布局来说，<strong>什么能保证，什么不能保证</strong>目前还在 Rust 开发组的<a href="https://rust-lang.github.io/unsafe-code-guidelines/layout.html">工作任务</a>中呢。</p>
<p>你以为你之前凝视的是深渊吗？不，你凝视的只是深渊的大门。 <code>mem::transmute_copy&lt;T, U&gt;</code> 才是真正的深渊，它比之前的还要更加危险和不安全。它从 <code>T</code> 类型中拷贝出 <code>U</code> 类型所需的字节数，然后转换成 <code>U</code>。 <code>mem::transmute</code> 尚有大小检查，能保证两个数据的内存大小一致，现在这哥们干脆连这个也丢了，只不过 <code>U</code> 的尺寸若是比 <code>T</code> 大，会是一个未定义行为。</p>
<p>当然，你也可以通过原生指针转换和 <code>unions</code> (todo!)获得所有的这些功能，但是你将无法获得任何编译提示或者检查。原生指针转换和 <code>unions</code> 也不是魔法，无法逃避上面说的规则。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="返回和错误处理"><a class="header" href="#返回和错误处理">返回和错误处理</a></h1>
<p>飞鸽传书、八百里加急，自古以来，掌权者最需要的就是及时获得对某个事物的信息反馈，在此过程中，也定义了相应的应急处理措施。</p>
<p>社会演变至今，这种思想依然没变，甚至来到计算中的微观世界，也是如此。及时、准确的获知系统在发生什么，是程序设计的重中之重。因此能够准确的分辨函数返回值是正确的还是错误的、以及在发生错误时该怎么快速处理，成了程序设计语言的必备功能。</p>
<p>Go 语言为人诟病的其中一点就是 <code>if err != nil {}</code> 的大量使用，缺乏一些程序设计的美感，不过我倒是觉得这种简单的方式也有其好处，就是阅读代码时的流畅感很强，你不需要过多的思考各种语法是什么意思。与 Go 语言不同，Rust 博采众家之长，实现了颇具自身色彩的返回值和错误处理体系，本章我们就高屋建瓴地来学习，更加深入的讲解见<a href="basic/result-error/../../errors/intro.html">此章</a>.</p>
<h2 id="rust的错误哲学"><a class="header" href="#rust的错误哲学">Rust的错误哲学</a></h2>
<p>错误对于软件来说是不可避免的，因此一门优秀的编程语言必须有其完整的错误处理哲学。在很多情况下，Rust 需要你承认自己的代码可能会出错，并提前采取行动，来处理这些错误。</p>
<p>Rust 中的错误主要分为两类：</p>
<ul>
<li><strong>可恢复错误</strong>，通常用于从系统全局角度来看可以接受的错误，例如处理用户的访问、操作等错误，这些错误只会影响某个用户自身的操作进程，而不会对系统的全局稳定性产生影响</li>
<li><strong>不可恢复错误</strong>，刚好相反，该错误通常是全局性或者系统性的错误，例如数组越界访问，系统启动时发生了影响启动流程的错误等等，这些错误的影响往往对于系统来说是致命的</li>
</ul>
<p>很多编程语言，并不会区分这些错误，而是直接采用异常的方式去处理。Rust没有异常，但是Rust也有自己的卧龙凤雏：<code>Result&lt;T,E&gt;</code> 用于可恢复错误，<code>panic!</code> 用于不可恢复错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic深入剖析"><a class="header" href="#panic深入剖析">panic深入剖析</a></h1>
<p>在正式开始之前，先来思考一个问题：假设我们想要从文件读取数据，如果失败，你有没有好的办法通知调用者为何失败？如果成功，你有没有好的办法把读取的结果返还给调用者？</p>
<h2 id="panic与不可恢复错误"><a class="header" href="#panic与不可恢复错误">panic!与不可恢复错误</a></h2>
<p>上面的问题在真实场景会经常遇到，其实处理起来挺复杂的，让我们先做一个假设：文件读取操作发生在系统启动阶段。那么可以轻易得出一个结论，一旦文件读取失败，那么系统启动也将失败，这意味着该失败是不可恢复的错误，无论是因为文件不存在还是操作系统硬盘的问题，这些只是错误的原因不同，但是归根到底都是不可恢复的错误(梳理清楚当前场景的错误类型非常重要)。</p>
<p>既然是不可恢复错误，那么一旦发生，只需让程序崩溃即可。对此，Rust 为我们提供了 <code>panic!</code> 宏，当调用执行该宏时，<strong>程序会打印出一个错误信息，展开报错点往前的函数调用堆栈，最后退出程序</strong>。 </p>
<p>切记，一定是不可恢复的错误，才调用 <code>panic!</code> 处理，你总不想系统仅仅因为用户随便传入一个非法参数就崩溃吧？所以，<strong>只有当你不知道该如何处理时，再去调用panic!</strong>.</p>
<h2 id="调用panic"><a class="header" href="#调用panic">调用panic!</a></h2>
<p>首先，来调用一下 <code>panic!</code>，这里使用了最简单的代码实现，实际上你在程序的任何地方都可以这样调用：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre></pre>
<p>运行后输出:</p>
<pre><code class="language-console">thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>以上信息包含了两条重要信息：</p>
<ul>
<li><code>main</code> 函数所在的线程崩溃了，发生的代码位置是 <code>src/main.rs</code> 中的第2行第5个字符(去除该行前面的空字符)</li>
<li>在使用时加上一个环境变量可以获取更详细的栈展开信息：<code>RUST_BACKTRACE=1 cargo run</code></li>
</ul>
<p>下面让我们针对第二点进行详细展开讲解。</p>
<h2 id="backtrace栈展开"><a class="header" href="#backtrace栈展开">backtrace栈展开</a></h2>
<p>在真实场景中，错误往往涉及到很长的调用链甚至会深入第三方库，如果没有栈展开技术，错误将难以跟踪处理，下面我们来看一个真实的崩溃例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<p>上面的代码很简单，数组只有<code>3</code>个元素，我们却尝试去访问它的第<code>100</code>号元素(数组索引从<code>0</code>开始)，那自然会崩溃。</p>
<p>我们的读者里不乏正义之士，此时肯定要质疑，一个简单的数组越界访问，为何要直接让程序崩溃？是不是有些小题大作了？</p>
<p>如果有过C语言的经验，即使你越界了，问题不大，我依然尝试去访问，至于这个值是不是你想要的(<code>100</code>号内存地址也有可能有值，只不过是其它变量或者程序的！)，抱歉，不归我管，我只负责取，你要负责管理好自己的索引访问范围。上面这种情况被称为<strong>缓冲区溢出</strong>，并可能会导致安全漏洞，例如攻击者可以通过索引来访问到数组后面不被允许的数据。</p>
<p>说实话，我宁愿程序崩溃，为什么？当你取到了一个不属于你的值，这在很多时候会导致程序上的逻辑bug! 有编程经验的人都知道这种逻辑上的bug是多么难被发现和修复！因此程序直接崩溃，然后告诉我们问题发生的位置，最后我们对此进行修复，这才是最合理的软件开发流程，而不是把问题藏着掖着：</p>
<pre><code class="language-console">thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>好的，现在成功知道问题发生的位置，但是如果我们想知道该问题之前经过了哪些调用环节，该怎么办？那就按照提示使用 <code>RUST_BACKTRACE=1 cargo run</code> 来再一次运行程序：</p>
<pre><code class="language-console">thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/std/src/panicking.rs:517:5
   1: core::panicking::panic_fmt
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:101:14
   2: core::panicking::panic_bounds_check
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:77:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:184:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:15:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/alloc/src/vec/mod.rs:2465:9
   6: world_hello::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p>上面的代码就是一次栈展开(也称栈回溯)，它包含了函数调用的顺序，当然按照逆序排列：最近调用的函数排在列表的最上方。因为咱们的 <code>main</code> 函数基本是最先调用的函数了，所以排在了倒数第二位，还有一个关注点，排在最顶部最后一个调用的函数是 <code>rust_begin_unwind</code>，该函数的目的就是进行栈展开，呈现这些列表信息给我们。</p>
<p>要获取到栈回溯信息，你还需要开启 <code>debug</code> 标志，该标志在使用 <code>cargo run</code> 或者 <code>cargo build</code> 时自动开启(这两个操作默认是 <code>Debug</code> 运行方式). 同时，栈展开信息在不同操作系统或者 Rust 版本上也所有不同。</p>
<h2 id="panic时的两种终止方式"><a class="header" href="#panic时的两种终止方式">panic时的两种终止方式</a></h2>
<p>当出现 <code>panic!</code> 时，程序提供了两种方式来处理终止流程: <strong>栈展开</strong> 和 <strong>直接终止</strong>。</p>
<p>其中，默认的方式就是 <code>栈展开</code>，这意味着 Rust 会回溯栈上数据和函数调用，因此也意味着更多的善后工作，好处是可以给出充分的报错信息和栈调用信息，便于事后的问题复盘。<code>直接终止</code>，顾名思义，不清理数据就直接退出程序，善后工作交与操作系统来负责。</p>
<p>对于绝大多数用户，使用默认选择是最好的，但是当你关心最终编译出的二进制可执行文件大小时，那么可以尝试去使用直接终止的方式，例如下面的配置修改 <code>Cargo.toml</code> 文件，实现在<a href="basic/result-error/../first-try/cargo.html#%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE"><code>release</code></a>模式下遇到 <code>panic</code> 直接终止：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[profile.release]
panic = 'abort'
<span class="boring">}
</span></code></pre></pre>
<h2 id="线程panic后程序会否终止"><a class="header" href="#线程panic后程序会否终止">线程<code>panic</code>后，程序会否终止？</a></h2>
<p>长话短说，如果是 <code>main</code> 线程，则程序会终止，如果是其它子线程，该线程会终止，但是不会影响 <code>main</code> 线程。因此，尽量不要在 <code>main</code> 线程中做太多任务，将这些任务交由子线程去做，就算子线程 <code>panic</code> 也不会导致整个程序的结束。</p>
<p>具体解析见<a href="basic/result-error/panic.html#panic%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90">panic原理剖析</a></p>
<h2 id="何时该使用panic"><a class="header" href="#何时该使用panic">何时该使用panic!</a></h2>
<p>下面让我们大概罗列下何时适合使用 <code>panic</code>，也许经过之前的学习，你已经能够对 <code>panic</code> 的使用有了自己的看法，但是我们还是会罗列一些常见的用法来加深你的理解。</p>
<p>先来一点背景知识，在前面章节我们粗略讲过 <code>Result&lt;T,E&gt;</code> 这个枚举类型，它是用来表示函数的返回结果：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>当没有错误发生时，函数返回一个用 <code>Result</code> 类型包裹的值 <code>Ok(T)</code>，当错误时，返回一个 <code>Err(E)</code>。对于 <code>Result</code> 返回我们有很多处理方法，最简单粗暴的就是 <code>unwrap</code> 和 <code>expect</code>，这两个函数非常类似，我们以 <code>unwrap</code> 举例：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::net::IpAddr;
let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>上面的 <code>parse</code> 方法试图将字符串 <code>&quot;127.0.0.1&quot; </code>解析为一个IP地址类型 <code>IpAddr</code>，它返回一个 <code>Result&lt;IpAddr,E&gt;</code> 类型，如果解析成功，则把 <code>Ok(IpAddr)</code> 中的值赋给 <code>home</code>，如果失败，则不处理 <code>Err(E)</code>，而是直接 <code>panic</code>。</p>
<p>因此 <code>unwrap</code> 简而言之：成功则返回值，失败则 <code>panic</code>，总之不进行任何错误处理。</p>
<h4 id="示例原型测试"><a class="header" href="#示例原型测试">示例、原型、测试</a></h4>
<p>这几个场景下，需要快速地搭建代码，错误处理会拖慢编码的速度，也不是特别有必要，因此通过<code>unwrap</code>、<code>expect</code>等方法来处理是最快的。</p>
<p>同时，当我们回头准备做错误处理时，可以全局搜索这些方法，不遗漏地进行替换。</p>
<h4 id="你确切的知道你的程序是正确时可以使用panic"><a class="header" href="#你确切的知道你的程序是正确时可以使用panic">你确切的知道你的程序是正确时，可以使用panic</a></h4>
<p>因为 <code>panic</code> 的触发方式比错误处理要简单，因此可以让代码更清晰，可读性也更加好，当我们的代码注定是正确时，你可以用 <code>unrawp</code> 等方法直接进行处理，反正也不可能<code>panic</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::net::IpAddr;
let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>例如上面的例子，<code>&quot;127.0.0.1&quot;</code> 就是 <code>ip</code> 地址，因此我们知道 <code>parse</code> 方法一定会成功，那么就可以直接用 <code>unwrap</code> 方法进行处理。</p>
<p>当然，如果该字符串是来自于用户输入，那在实际项目中，就必须用错误处理的方式，而不是 <code>unwrap</code>，否则你的程序一天要崩溃几十万次吧！</p>
<h4 id="可能导致全局有害状态时"><a class="header" href="#可能导致全局有害状态时">可能导致全局有害状态时</a></h4>
<p>有害状态大概分为几类：</p>
<ul>
<li>非预期的错误</li>
<li>后续代码的运行会受到显著影响</li>
<li>内存安全的问题</li>
</ul>
<p>当错误预期会出现时，返回一个错误较为合适，例如解析器接收到格式错误的数据，HTTP请求接收到错误的参数甚至该请求内的任何错误(不会导致整个程序有问题，只影响该此请求)。 <strong>因为错误是可预期的，因此也是可以处理的</strong>。</p>
<p>当启动时某个流程发生了错误，对后续代码的运行造成了影响，那么就应该使用 <code>panic</code>，而不是处理错误后继续运行，当然你可以通过重试的方式来继续。</p>
<p>上面提到过，数组访问越界，就要 <code>panic</code> 的原因，这个就是属于内存安全的范畴，一旦内存访问不安全，那么我们就无法保证自己的程序会怎么运行下去，也无法保证逻辑和数据的正确性。</p>
<h2 id="panic原理剖析"><a class="header" href="#panic原理剖析">panic原理剖析</a></h2>
<p>本来不想写这块儿内容，因为真的难写，但是转念一想，既然号称圣经，那么本书就得与众不同，避重就轻显然不是该有的态度。</p>
<p>当调用 <code>panic!</code> 宏时，它会</p>
<ol>
<li>格式化 <code>panic</code> 信息，然后使用该信息作为参数，调用 <code>std::panic::panic_any()</code> 函数</li>
<li><code>panic_any</code> 会检查应用是否使用了 <code>panic hook</code>，如果使用了，该 <code>hook</code> 函数就会被调用（hook是一个钩子函数，是外部代码设置的，用于在panic触发时，执行外部代码所需的功能）</li>
<li>当 <code>hook</code> 函数返回后，当前的线程就开始进行栈展开：从 <code>panic_any</code> 开始，如果寄存器或者栈因为某些原因信息错乱了，那很可能该展开会发生异常，最终线程会直接停止，展开也无法继续进行</li>
<li>展开的过程是一帧一帧的去回溯整个栈，每个帧的数据都会随之被丢弃，但是在展开过程中，你可能会遇到被用户标记为 <code>catching</code> 的帧(通过 <code>std::panic::catch_unwind()</code> 函数标记)，此时用户提供的 <code>catch</code> 函数会被调用，展开也随之停止：当然，如果 <code>catch</code> 选择在内部调用 <code>std::panic::resume_unwind()</code> 函数，则展开还会继续。</li>
</ol>
<p>还有一种情况，在展开过程中，如果展开本身 <code>panic</code> 了，那展开线程会终止，展开也随之停止。</p>
<p>一旦线程展开被终止或者完成，最终的输出结果是取决于哪个线程 <code>panic：对于 </code>main<code>线程，操作系统提供的终止功能</code>core::intrinsics::abort()<code>会被调用，最终结束当前的</code>panic<code>进程；如果是其它子线程，那么子线程就会简单的终止，同时信息会在稍后通过</code>std::thread::join()` 进行收集。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可恢复的错误result"><a class="header" href="#可恢复的错误result">可恢复的错误Result</a></h1>
<p>还记得上一节中，提到的关于文件读取的思考题吧？当时我们解决了读取文件时遇到不可恢复错误该怎么处理的问题，现在来看看，读取过程中，正常返回和遇到可以恢复的错误时该如何处理。</p>
<p>假设，我们有一台消息服务器，每个用户都通过 websocket 连接到该服务器来接收和发送消息，该过程就涉及到 socket 文件的读写，那么此时，如果一个用户的读写发生了错误，显然不能直接panic，否则服务器会直接崩溃，所有用户都会断开连接，因此我们需要一种更温和的错误处理方式：<code>Result&lt;T,E&gt;</code>。</p>
<p>之前章节有提到过，<code>Result&lt;T,E&gt;</code> 是一个枚举类型，定义如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>泛型参数 <code>T</code> 代表成功时存入的正确值的类型，存放方式是 <code>Ok(T)</code>，<code>E</code> 代表错误是存入的错误值，存放方式是 <code>Err(E)</code>，枯燥的讲解永远不及代码生动准确，因此先来看下打开文件的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p>以上 <code>File::open</code> 返回一个 <code>Result</code> 类型，那么问题来了：</p>
<blockquote>
<h4 id="如何获知变量类型或者函数的返回类型"><a class="header" href="#如何获知变量类型或者函数的返回类型">如何获知变量类型或者函数的返回类型</a></h4>
<p>有几种常用的方式，此处更推荐第二种方法：</p>
<ul>
<li>第一种是查询标准库或者三方库文档，搜索 <code>File</code>，然后找到它的 <code>open</code> 方法</li>
<li>在<a href="basic/result-error/../../first-try/editor.html">Rust IDE</a>章节，我们推荐了 <code>VSCode</code> IED和 <code>rust-analyzer</code> 插件，如果你成功安装的话，那么就可以在 <code>VScode</code> 中很方便的通过代码跳转的方式查看代码，同时 <code>rust-analyzer</code> 插件还会对代码中的类型进行标注，非常方便好用！</li>
<li>你还可以尝试故意标记一个错误的类型，然后让编译器告诉你：</li>
</ul>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f: u32 = File::open(&quot;hello.txt&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>错误提示如下：</p>
<pre><code class="language-console">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
             found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
</code></pre>
<p>上面代码，故意将 <code>f</code> 类型标记成整形，编译器立刻不乐意了，你是在忽悠我吗？打开文件操作返回一个整形？来，大哥来告诉你返回什么：<code>std::result::Result&lt;std::fs::File, std::io::Error&gt;</code>，我的天呐，怎么这么长的类型！</p>
<p>别慌，其实很简单，首先 <code>Result</code> 本身是定义在 <code>std::result</code> 中的，但是因为 <code>Result</code> 很常用，所以就被包含在了<a href="basic/result-error/../../appendix/prelude.html"><code>prelude</code></a>中(将常用的东东提前引入到当前作用域内），因此无需手动引入 <code>std::result::Result</code>，那么返回类型可以简化为 <code>Result&lt;std::fs::File,std::io::Error&gt;</code>，你看看是不是很像标准的 <code>Result&lt;T,E&gt;</code> 枚举定义？只不过 <code>T</code> 被替换成了具体的类型 <code>std::fs::File</code>，是一个文件句柄类型，<code>E</code> 被替换成 <code>std::io::Error</code>，是一个 IO 错误类型.</p>
<p>这个返回值类型说明 <code>File::open</code> 调用如果成功则返回一个可以进行读写的文件句柄，如果失败，则返回一个 IO 错误：文件不存在或者没有访问文件的权限等。总之 <code>File::open</code> 需要一个方式告知调用者是成功还是失败，并同时返回具体的文件句柄(成功)或错误信息(失败)，万幸的是，这些信息通可以通过 <code>Result</code> 枚举提供：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&quot;Problem opening the file: {:?}&quot;, error)
        },
    };
}
</code></pre></pre>
<p>代码很清晰，对打开文件后的 <code>Result&lt;T,E&gt;</code> 类型进行匹配取值，如果是成功，则将 <code>Ok(file)</code> 中存放的的文件句柄 <code>file</code> 赋值给 <code>f</code>，如果失败，则将 <code>Err(error)</code> 中存放的错误信息 <code>error</code> 使用 <code>panic</code> 抛出来，进而结束程序，这非常符合上文提到过的 <code>panic</code> 使用场景。</p>
<p>好吧，也没有那么合理 :)</p>
<h2 id="对返回的错误进行处理"><a class="header" href="#对返回的错误进行处理">对返回的错误进行处理</a></h2>
<p>直接 <code>panic</code> 还是过于粗暴，因为实际上 IO 的错误有很多种，我们需要对部分错误进行特殊处理，而不是所有错误都直接崩溃：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Problem creating the file: {:?}&quot;, e),
            },
            other_error =&gt; panic!(&quot;Problem opening the file: {:?}&quot;, other_error),
        },
    };
}
</code></pre></pre>
<p>上面代码在匹配出 <code>error</code> 后，又对 <code>error</code> 进行了详细的匹配解析，最终结果：</p>
<ul>
<li>如果是文件不存在错误 <code>ErrorKind::NotFound</code>，就创建文件，这里创建文件<code>File::create</code> 也是返回 <code>Result</code>，因此继续用 <code>match</code> 对其结果进行处理：创建成功，将新的文件句柄赋值给 <code>f</code>，如果失败，则 <code>panic</code></li>
<li>剩下的错误，一律 <code>panic</code></li>
</ul>
<p>虽然很清晰，但是代码还是有些啰嗦，我们会在<a href="basic/result-error/../../errors/simplify.html">简化错误处理</a>一章重点讲述如何写出更优雅的错误。</p>
<h2 id="失败就-panic-unwrap-和-expect"><a class="header" href="#失败就-panic-unwrap-和-expect">失败就 panic: unwrap 和 expect</a></h2>
<p>上一节中，已经看到过这两兄弟的简单介绍，这里再来回顾下。</p>
<p>在不需要处理错误的场景，例如写原型、示例时，我们不想使用 <code>match</code> 去匹配 <code>Result&lt;T,E&gt; </code>以获取其中的 <code>T</code> 值，因为 <code>match</code> 的穷尽匹配特性，你总要去处理下 <code>Err</code> 分支。那么有没有办法简化这个过程？有，答案就是 <code>unwrap</code> 和 <code>expect</code>。</p>
<p>它们的作用就是，如果返回成功，就将 <code>Ok(T)</code> 中的值取出来，如果失败，就直接 <code>panic</code>，真的勇士绝不多BB，直接崩溃。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p>如果调用这段代码时 <em>hello.txt</em> 文件不存在，那么 <code>unwrap</code> 就将直接 <code>panic</code>：</p>
<pre><code class="language-console">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:4:37
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p><code>expect</code> 跟 <code>unwrap</code> 很像，只不过它允许指定 <code>panic!</code> 时的报错信息：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
}
</code></pre></pre>
<p>报错如下：</p>
<pre><code class="language-console">thread 'main' panicked at 'Failed to open hello.txt: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:4:37
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>可以看出，<code>expect</code> 相比 <code>unwrap</code> 能提供更精确的错误信息，在有些场景也会更加实用。</p>
<h2 id="传播错误"><a class="header" href="#传播错误">传播错误</a></h2>
<p>咱们的程序几乎不太可能只有 <code>A-&gt;B</code> 形式的函数调用，一个设计良好的程序，一个功能涉及十几层的函数调用都有可能。而错误处理也往往不是哪里调用出错，就在哪里处理，实际应用中，大概率会把错误层层上传然后交给调用链的上游函数进行处理，、错误传播将极为常见。</p>
<p>例如以下函数从文件中读取用户名，然后将结果进行返回：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    // 打开文件，f是`Result&lt;文件句柄,io::Error&gt;`
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        // 打开文件成功，将file句柄赋值给f
        Ok(file) =&gt; file,
        // 打开文件失败，将错误返回(向上传播)
        Err(e) =&gt; return Err(e),
    };
    // 创建动态字符串s
    let mut s = String::new();
    // 从f文件句柄读取数据并写入s中
    match f.read_to_string(&amp;mut s) {
        // 读取成功，返回Ok封装的字符串
        Ok(_) =&gt; Ok(s),
        // 将错误向上传播
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>有几点值得注意：</p>
<ul>
<li>该函数返回一个 <code>Result&lt;String, io::Error&gt;</code> 类型，当读取用户名成功时，返回 <code>Ok(String)</code>，失败时，返回 <code>Err(io:Error)</code></li>
<li><code>File::open</code> 和 <code>f.read_to_string</code> 返回的 <code>Result&lt;T,E&gt;</code> 中的 <code>E</code> 就是 <code>io::Error</code></li>
</ul>
<p>由此可见，该函数将 <code>io::Error</code> 的错误往上进行传播，该函数的调用者最终会对 <code>Result&lt;String,io::Error&gt;</code> 进行再处理，至于怎么处理就是调用者的事，如果是错误，它可以选择继续向上传播错误，也可以直接 <code>panic</code>，亦或将具体的错误原因包装后写入 socket 中呈现给终端用户。</p>
<p>但是上面的代码也有自己的问题，那就是太长了(优秀的程序员身上的优点极多，其中最大的优点就是<em>懒</em>)，我自认为也有那么一点点优秀，因此见不到这么啰嗦的代码，下面咱们来讲讲如何简化它。</p>
<h3 id="传播界的大明星-"><a class="header" href="#传播界的大明星-">传播界的大明星: ?</a></h3>
<p>大明星出场，必需得有排面，来看看 <code>?</code> 的排面：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p>看到没，这就是排面，相比前面的 <code>match</code> 处理错误的函数，代码直接减少了一半不止，但是，一山更比一山难，看不懂啊！</p>
<p>其实 <code>?</code> 就是一个宏，它的作用跟上面的 <code>match</code> 几乎一模一样：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut f = match f {
    // 打开文件成功，将file句柄赋值给f
    Ok(file) =&gt; file,
    // 打开文件失败，将错误返回(向上传播)
    Err(e) =&gt; return Err(e),
};
<span class="boring">}
</span></code></pre></pre>
<p>如果结果是 <code>Ok(T)</code>，则把 <code>T</code> 赋值给 <code>f</code>，如果结果是 <code>Err(E)</code>，则返回该错误，所以 <code>?</code> 特别适合用来传播错误。</p>
<p>虽然 <code>?</code> 和 <code>match</code> 功能一致，但是事实上 <code>?</code> 会更胜一筹。何解？</p>
<p>想象一下，一个设计良好的系统中，肯定有自定义的错误特征，错误之间很可能会存在上下级关系，例如标准库中的 <code>std::io::Error </code>和 <code>std::error::Error</code>，前者是io相关的错误结构体，后者是一个最最通用的标准错误特征，同时前者实现了后者，因此 <code>std::io::Error</code> 可以转换为 <code>std:error::Error</code>。</p>
<p>明白了以上的错误转换，<code>?</code> 的更胜一筹就很好理解了，它可以自动进行类型提升（转换）：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn open_file() -&gt; Result&lt;File, Box&lt;dyn std::error::Error&gt;&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    Ok(f)
}
<span class="boring">}
</span></code></pre></pre>
<p>上面代码中 <code>File::open</code> 报错时返回的错误是 <code>std::io::Error</code> 类型，但是 <code>open_file</code> 函数返回的错误类型是 <code>std::error::Error</code> 的特征对象，可以看到一个错误类型通过 <code>?</code> 返回后，变成了另一个错误类型，这就是 <code>?</code> 的神奇之处。</p>
<p>根本原因是在于标准库中定义的 <code>From</code> 特征，该特征有一个方法 <code>from</code>，用于把一个类型转成另外一个类型，<code>?</code> 可以自动调用该方法，然后进行隐式类型转换。因此只要函数返回的错误 <code>ReturnError</code> 实现了 <code>From&lt;OtherError&gt;</code> 特征，那么 <code>?</code> 就会自动把 <code>OtherError</code> 转换为 <code>ReturnError</code>。</p>
<p>这种转换非常好用，意味着你可以用一个大而全的 <code>ReturnError</code> 来覆盖所有错误类型，只需要为各种子错误类型实现这种转换即可。</p>
<p>强中自有强中手，一码更比一码短：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p>瞧见没？ <code>?</code> 还能实现链式调用，<code>File::open</code> 遇到错误就返回，没有错误就将 <code>Ok</code> 中的值取出来用于下一个方法调用，简直太精妙了，从 Go 语言过来的我，内心狂喜(其实学 Rust 的苦和痛我才不会告诉你们)。</p>
<p>不仅有更强，还要有最强，我不信还有人比我更短(不要误解)：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    // read_to_string是定义在std::io中的方法，因此需要在上面进行引用
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p>从文件读取数据到字符串中，是比较常见的操作，因此 Rust 标准库为我们提供了 <code>fs::read_to_string</code> 函数，该函数内部会打开一个文件、创建 <code>String</code>、读取文件内容最后写入字符串并返回，因为该函数其实与本章讲的内容关系不大，因此放在最后来讲，其实只是我想震你们一下 :)</p>
<h4 id="-用于option的返回"><a class="header" href="#-用于option的返回">? 用于Option的返回</a></h4>
<p><code>?</code> 不仅仅可以用于 <code>Result</code> 的传播，还能用于 <code>Option</code> 的传播，再来回忆下 <code>Option</code> 的定义：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Option&lt;T&gt; {
    Some(T),
    None
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Result</code> 通过 <code>?</code> 返回错误，那么 <code>Option</code> 就通过 <code>?</code> 返回 <code>None</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first(arr: &amp;[i32]) -&gt; Option&lt;&amp;i32&gt; {
   let v = arr.get(0)?;
   Some(v)
}
<span class="boring">}
</span></code></pre></pre>
<p>上面的函数中，<code>arr.get</code> 返回一个 <code>Option&lt;&amp;i32&gt;</code> 类型，因为 <code>?</code> 的使用，如果 <code>get</code> 的结果是 <code>None</code>，则直接返回 <code>None</code>，如果是 <code>Some(&amp;i32)</code>，则把里面的值赋给 <code>v</code>。</p>
<p>其实这个函数有些画蛇添足，我们完全可以写出更简单的版本：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first(arr: &amp;[i32]) -&gt; Option&lt;&amp;i32&gt; {
   arr.get(0)
}
<span class="boring">}
</span></code></pre></pre>
<p>有一句话怎么说？没有需求，制造需求也要上。。。大家别跟我学习，这是软件开发大忌。只能用代码洗洗眼了：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">}
</span></code></pre></pre>
<p>上面代码展示了在链式调用中使用 <code>?</code> 提前返回 <code>None</code> 的用法， <code>.next</code> 方法返回的是 <code>Option</code> 类型：如果返回 <code>Some(&amp;str)</code>，那么继续调用 <code>chars</code> 方法,如果返回 <code>None</code>，则直接从整个函数中返回 <code>None</code>，不再继续进行链式调用。</p>
<h4 id="新手用--常会犯的错误"><a class="header" href="#新手用--常会犯的错误">新手用 ? 常会犯的错误</a></h4>
<p>初学者在用 <code>?</code> 时，老是会犯错，例如写出这样的代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first(arr: &amp;[i32]) -&gt; Option&lt;&amp;i32&gt; {
   arr.get(0)?
}
<span class="boring">}
</span></code></pre></pre>
<p>这段代码无法通过编译，切记：<code>?</code> 操作符需要一个变量来承载正确的值，这个函数只会返回 <code>Some(&amp;i32)</code> 或者 <code>None</code>，只有错误值能直接返回，正确的值不行，所以如果数组中存在 0 号元素，那么函数第二行使用 <code>?</code> 后的返回类型为 <code>&amp;i32</code> 而不是 <code>Some(&amp;i32)</code>。因此 <code>?</code> 只能用于以下形式：</p>
<ul>
<li><code>let v = xxx()?;</code></li>
<li><code>xxx()?.yyy()?;</code></li>
</ul>
<h4 id="带返回值的main函数"><a class="header" href="#带返回值的main函数">带返回值的main函数</a></h4>
<p>因为刚才讲的 <code>?</code> 使用限制，这段代码你很容易看出它无法编译：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre></pre>
<p>因为 <code>?</code> 要求 <code>Result&lt;T,E&gt;</code> 形式的返回值，而 <code>main</code> 函数的返回是 <code>()</code>，因此无法满足，那是不是就无解了呢？</p>
<p>实际上 Rust 还支持另外一种形式的 <code>main</code> 函数：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let f = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}
</code></pre></pre>
<p>这样就能使用 <code>?</code> 提前返回了，同时我们又一次看到了<code>Box&lt;dyn Error&gt;</code> 特征对象，因为 <code>std::error:Error</code> 是 Rust 中抽象层次最高的错误，其它标准库中的错误都实现了该特征，因此我们可以用该特征对象代表一切错误，就算 <code>main</code> 函数中调用任何标准库函数发生错误，都可以通过 <code>Box&lt;dyn Error&gt;</code> 这个特征对象进行返回.</p>
<p>至于 <code>main</code> 函数可以有多种返回值，那是因为实现了<a href="https://doc.rust-lang.org/std/process/trait.Termination.html">std::process::Termination</a>特征，目前为止该特征还没进入稳定版Rust中，也许未来你可以为自己的类型实现该特征！</p>
<p>至此，Rust 的基础内容学习已经全部完成，下面我们将学习 Rust 的高级进阶内容，正式开启你的高手之路。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust高级进阶"><a class="header" href="#rust高级进阶">Rust高级进阶</a></h1>
<p>恭喜你，学会Rust基础后，金丹大道已在向你招手，大部分 Rust 代码对你来说都是家常便饭，简单得很。可是，对于一门难度传言在外的语言，怎么可能如此简单的就被征服，最难的生命周期，咱还没见过长啥样呢。</p>
<p>从本章开始，我们将进入Rust的进阶学习环节，与基础环节不同的是，由于你已经对 Rust 有了一定的认识，因此我们<strong>不会再对很多细节进行翻来覆去的详细讲解，甚至会一带而过</strong>。</p>
<p>总之，欢迎来到高级 Rust 的世界，全新的 Boss，全新的装备，你准备好了吗？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h1>
<p>既然是号称正式进入进阶学习环节，那么难度也得自然而然跟上，在之前所有权章节，其实我们遗漏了非常重要的一块儿内容，那就是生命周期。</p>
<p>因为生命周期内容比较多且复杂，因此相关内容被分成了两个章节：基础和进阶，其中进阶章节的内容较为复杂，如果觉得难以理解可以直接跳过，进入下一块内容的学习。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="认识生命周期"><a class="header" href="#认识生命周期">认识生命周期</a></h1>
<p>生命周期，简而言之就是引用的有效作用域。在大多数时候，我们无需手动的声明生命周期，因为编译器可以自动进行推导，用类型来类比下：</p>
<ul>
<li>就像编译器大部分时候可以自动推导类型 &lt;-&gt; 一样，编译器大多数时候也可以自动推导生命周期</li>
<li>在多种类型存在时，编译器往往要求我们手动标明类型 &lt;-&gt; 当多个生命周期存在，且编译器无法推导出某个引用的生命周期时，就需要我们手动标明生命周期</li>
</ul>
<p>Rust 生命周期之所以难，是因为这个概念对于我们来说是全新的，没有其它编程语言的经验可以借鉴。当你觉得难的时候，不用过于担心，这个难对于所有人都是平等的，多点付出就能早点解决此拦路虎，同时本书也会尽力帮助大家减少学习难度(生命周期很可能是Rust中最难的部分)。</p>
<h2 id="悬垂指针和生命周期"><a class="header" href="#悬垂指针和生命周期">悬垂指针和生命周期</a></h2>
<p>生命周期的主要作用是避免悬垂引用，它会导致程序引用了本不该引用的数据：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {}&quot;, r);
}
<span class="boring">}
</span></code></pre></pre>
<p>这段代码有几点值得注意:</p>
<ul>
<li><code>let r;</code> 的声明方式貌似存在使用 <code>null</code> 的风险，实际上，当我们不初始化它就使用时，编译器会给予报错</li>
<li><code>r</code> 引用了内部花括号中的 <code>x</code> 变量，但是 <code>x</code> 会在内部花括号 <code>}</code> 处被释放，因此回到外部花括号后，<code>r</code> 会引用一个无效的 <code>x</code></li>
</ul>
<p>此处 <code>r</code> 就是一个悬垂指针，它引用了提前被释放的变量 <code>x</code>，可以预料到，这段代码会报错：</p>
<pre><code class="language-console">error[E0597]: `x` does not live long enough // x活得不够久
  --&gt; src/main.rs:7:17
   |
7  |             r = &amp;x;
   |                 ^^ borrowed value does not live long enough // 被借用的x活得不够久
8  |         }
   |         - `x` dropped here while still borrowed // x在这里被丢弃，但是它依然还在被借用
9  |  
10 |         println!(&quot;r: {}&quot;, r); 
   |                           - borrow later used here // 对x的借用在此处被使用
</code></pre>
<p>在这里 <code>r</code> 拥有更大的作用域，或者说<strong>活得更久</strong>。如果 Rust 不阻止该垂悬引用的发生，那么当 <code>x</code> 被释放后，<code>r</code> 所引用的值就不再是合法的，会导致我们程序发生异常行为，且该异常行为有时候会很难被发现。</p>
<h2 id="借用检查"><a class="header" href="#借用检查">借用检查</a></h2>
<p>为了保证 Rust 的所有权和借用的正确性，Rust 使用了一个借用检查器(Borrow checker)，来检查我们程序的借用正确性：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!(&quot;r: {}&quot;, r); //          |
}  
<span class="boring">}
</span></code></pre></pre>
<p>这段代码和之前的一模一样，唯一的区别在于增加了对变量生命周期的注释。这里，<code>r</code> 变量被赋予了生命周期 <code>'a</code>，<code>x</code> 被赋予了生命周期 <code>'b</code>，从图示上可以明显看出生命周期 <code>'b</code> 比 <code>'a</code> 小很多。</p>
<p>在编译期，Rust 会比较两个变量的生命周期，结果发现 <code>r</code> 明明拥有生命周期 <code>'a</code>，但是却引用了一个小得多的生命周期 <code>'b</code>，在这种情况下，编译器会认为我们的程序存在风险，因此拒绝运行。</p>
<p>如果想要编译通过，也很简单，只要 <code>'b</code> 比 <code>'a</code> 大就好。总之，<code>x</code> 变量只要比 <code>r</code> 活得久，那么 <code>r</code> 就能随意引用 <code>x</code> 且不会存在危险：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!(&quot;r: {}&quot;, r); //   |       |
                          // --+       |
}                         // ----------+
<span class="boring">}
</span></code></pre></pre>
<p>根据之前的结论，我们重新实现了代码，现在 <code>x</code> 的生命周期 <code>'b</code> 大于 <code>r</code> 的生命周期 <code>'a</code>，因此 <code>r</code> 对 <code>x</code> 的引用是安全的。</p>
<p>通过之前的内容，我们了解了何为生命周期，也了解了 Rust 如何利用生命周期来确保引用是合法的，下面来看看函数中的生命周期。</p>
<h2 id="函数中的生命周期"><a class="header" href="#函数中的生命周期">函数中的生命周期</a></h2>
<p>先来考虑一个例子 - 返回两个字符串切片中较长的那个，该函数的参数是两个字符串切片，返回值也是字符串切片：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这段 <code>longest</code> 实现，非常标准优美，就连多余的 <code>return</code> 和分号都没有，可是现实总是给我们重重一击：</p>
<pre><code class="language-console">error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter // 参数需要一个生命周期
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is 
  borrowed from `x` or `y`
  = 帮助： 该函数的返回值是一个引用类型，但是函数签名无法说明，该引用是借用自 `x` 还是 `y`
help: consider introducing a named lifetime parameter // 考虑引入一个生命周期
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ^^^^    ^^^^^^^     ^^^^^^^     ^^^
</code></pre>
<p>喔，这真是一个复杂的提示，那感觉就好像是生命周期去非诚勿扰相亲，结果在初印象环节就23盏灯全灭。等等，先别急，如果你仔细阅读，就会发现，其实主要是编译器无法知道该函数的返回值到底引用 <code>x</code> 还是 <code>y</code> ，<strong>因为编译器需要知道这些，来确保函数调用后的引用生命周期分析</strong>。</p>
<p>不过说来尴尬，就这个函数而言，我们也不知道返回值到底引用哪个，因为一个分支返回 <code>x</code>，另一个分支返回 <code>y</code>...这可咋办？先来分析下。</p>
<p>我们在定义该函数时，首先无法知道传递给函数的具体值，因此到底是 <code>if</code> 还是 <code>else</code> 被执行，无从得知。其次，传入引用的具体生命周期也无法知道，因此也不能像之前的例子那样通过分析生命周期来确定引用是否有效。同时，编译器的借用检查也无法推导出返回值的生命周期，因为它不知道 <code>x</code> 和 <code>y</code> 的生命周期跟返回值的生命周期之间的关系是怎样的(说实话，人都搞不清，何况编译器这个大聪明)。</p>
<p>因此，这时就回到了文章开头说的内容：在存在多个引用时，编译器有时会无法自动推导生命周期，此时就需要我们手动去标注，通过为参数标注合适的生命周期来帮助编译器进行借用检查的分析。</p>
<h2 id="生命周期标注语法"><a class="header" href="#生命周期标注语法">生命周期标注语法</a></h2>
<blockquote>
<p>生命周期标注并不会改变任何引用的实际作用域 - 鲁迅</p>
</blockquote>
<p>鲁迅说过的话，总是值得重点标注，当你未来更加理解生命周期时，你才会发现这句话的精髓和重要！现在先简单记住，<strong>标记的生命周期只是为了取悦编译器，让编译器不要难为我们</strong>，记住了吗？没记住，再回头看一遍，这对未来你遇到生命周期问题时会有很大的帮助！</p>
<p>在很多时候编译器是很聪明的，但是总有些时候，它会化身大聪明，自以为什么都很懂，然后去拒绝我们代码的执行，此时，就需要我们通过生命周期标注来告诉这个大聪明：别自作聪明了，听我的就好。</p>
<p>例如一个变量，只能活一个花括号，那么就算你给它标注一个活全局的生命周期，它还是会在前面的花括号结束处被释放掉，并不会真的全局存活。</p>
<p>生命周期的语法也颇为与众不同，以 <code>'</code> 开头，名称往往是一个单独的小写字母，大多数人都用 <code>'a</code> 来作为生命周期的名称。 如果是引用类型的参数，那么生命周期会位于引用符号 <code>&amp;</code> 之后，并用一个空格来将生命周期和引用参数分隔开:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&amp;i32        // 一个引用
&amp;'a i32     // 具有显式生命周期的引用
&amp;'a mut i32 // 具有显式生命周期的可变引用
<span class="boring">}
</span></code></pre></pre>
<p>一个生命周期标注，它自身并不具有什么意义，因为生命周期的作用就是告诉编译器多个引用之间的关系。例如，有一个函数，它的第一个参数 <code>first</code> 是一个指向 <code>i32</code> 类型的引用，具有生命周期 <code>'a</code>，该函数还有另一个参数 <code>second</code>，它也是指向 <code>i32</code> 类型的引用，并且同样具有生命周期 <code>'a</code>。此处生命周期标注仅仅说明，<strong>这两个参数 <code>first</code> 和 <code>second</code> 至少活得和'a一样久，至于到底活多久或者哪个活得更久，抱歉我们都无法得知</strong>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn useless&lt;'a&gt;(first: &amp;'a i32, second: &amp;'a i32) {}
<span class="boring">}
</span></code></pre></pre>
<h4 id="函数签名中的生命周期标注"><a class="header" href="#函数签名中的生命周期标注">函数签名中的生命周期标注</a></h4>
<p>继续之前的 <code>longest</code> 函数，从两个字符串切片中返回较长的那个：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>需要注意的点如下：</p>
<ul>
<li>和泛型一样，使用生命周期参数，需要先声明 <code>&lt;'a&gt;</code></li>
<li><code>x</code>、<code>y</code> 和返回值至少活得和 <code>'a</code> 一样久(因为返回值要么是 <code>x</code>，要么是 <code>y</code>)</li>
</ul>
<p>该函数签名表明对于某些生命周期 <code>'a</code>，函数的两个参数都至少跟 <code>'a</code> 活得一样久，同时函数的返回引用也至少跟 <code>'a</code> 活得一样久。实际上，这意味着返回值的生命周期与参数生命周期中的较小值一致：虽然两个参数的生命周期都是标注了 <code>'a</code>，但是实际上这两个参数的真实生命周期可能是不一样的(生命周期 <code>'a</code> 不代表生命周期等于 <code>'a</code>，而是大于等于 <code>'a</code>)。</p>
<p>回忆下“鲁迅”说的话，再参考上面的内容，可以得出：<strong>在通过函数签名指定生命周期参数时，我们并没有改变传入引用或者返回引用的真实生命周期，而是告诉编译器当不满足此约束条件时，就拒绝编译通过</strong>。</p>
<p>因此 <code>longest</code> 函数并不知道 <code>x</code> 和 <code>y</code> 具体会活多久，只要知道它们的作用域至少能持续 <code>'a</code> 这么长就行。</p>
<p>当把具体的引用传给 <code>longest</code> 时，那生命周期 <code>'a</code> 的大小就是 <code>x</code> 和 <code>y</code> 的作用域的重合部分，换句话说，<code>'a</code> 的大小将等于 <code>x</code> 和 <code>y</code> 中较小的那个。由于返回值的生命周期也被标记为 <code>'a</code>，因此返回值的生命周期也是 <code>x</code> 和 <code>y</code> 中作用域较小的那个。</p>
<p>说实话，这段文字我写的都快崩溃了，不知道你们读起来如何，实在***太绕了。。那就干脆用一个例子来解释吧：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;The longest string is {}&quot;, result);
    }
}
</code></pre></pre>
<p>在上例中，<code>string1</code> 的作用域直到 <code>main</code> 函数的结束，而 <code>string2</code> 的作用域到内部花括号的结束 <code>}</code>，那么根据之前的理论，<code>'a</code> 是两者中作用域较小的那个，也就是 <code>'a</code> 的生命周期等于 <code>string2</code> 的生命周期，同理，由于函数返回的生命周期也是 '<code>a</code>，可以得出函数返回的生命周期也等于 <code>string2</code> 的生命周期。</p>
<p>现在来验证下上面的结论：<code>result</code> 的生命周期等于参数中生命周期最小的，因此要等于 <code>string2</code> 的生命周期，也就是说，<code>result</code> 要活得和 <code>string2</code> 一样久，观察下代码的实现，可以发现这个结论是正确的！</p>
<p>因此，在这种情况下，通过生命周期标注，编译器得出了和我们肉眼观察一样的结论，而不再是一个蒙圈的大聪明。</p>
<p>再来看一个例子，该例子证明了 <code>result</code> 的生命周期必须等于两个参数中生命周期较小的那个:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre></pre>
<p>Bang，错误冒头了：</p>
<pre><code class="language-console">error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough 
7 |     }                                      
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;The longest string is {}&quot;, result);
  |                                          ------ borrow later used here
</code></pre>
<p>在上述代码中，<code>result</code> 必须要活到 <code>println!</code>处，因为 <code>result</code> 的生命周期是 <code>'a</code>，因此 <code>'a</code> 必须持续到 <code>println!</code>。</p>
<p>在 <code>longest</code> 函数中，<code>string2</code> 的生命周期也是 <code>'a</code>，由此说明 <code>string2</code> 也必须活到 <code>println!</code> 处，可是 <code>string2</code> 在代码中实际上只能活到内部语句块的花括号处 <code>}</code>，小于它应该具备的生命周期 <code>'a</code>，因此编译出错。</p>
<p>作为人类，我们可以很清晰的看出 <code>result</code> 实际上引用了 <code>string1</code>，因为 <code>string1</code> 的长度明显要比 <code>string2</code> 长，既然如此，编译器不该如此矫情才对，它应该能认识到 <code>result</code> 没有引用 <code>string2</code>，让我们这段代码通过。只能说，作为尊贵的人类，编译器的发明者，你高估了这个工具的能力，它真的做不到！而且 Rust 编译器在调教上是非常保守的：当可能出错也可能不出错时，它会选择前者，抛出编译错误。</p>
<p>总之，显式的使用生命周期，可以让编译器正确的认识到多个引用之间的关系，最终帮我们提前规避可能存在的代码风险。</p>
<p>小练习：尝试着去更改 <code>longest</code> 函数，例如修改参数、生命周期或者返回值，然后推测结果如何，最后再跟编译器的输出进行印证。</p>
<h4 id="深入思考生命周期标注"><a class="header" href="#深入思考生命周期标注">深入思考生命周期标注</a></h4>
<p>使用生命周期的方式往往取决于函数的功能，例如之前的 <code>longest</code> 函数，如果它永远只返回第一个参数 <code>x</code>，生命周期的标注该如何修改(该例子就是上面的小练习结果之一)?</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
<span class="boring">}
</span></code></pre></pre>
<p>在此例中，<code>y</code> 完全没有被使用，因此 <code>y</code> 的生命周期与 <code>x</code> 和返回值的生命周期没有任何关系，意味着我们也不必再为 <code>y</code> 标注生命周期，只需要标注 <code>x</code> 参数和返回值即可。</p>
<p><strong>函数的返回值如果是一个引用类型，那么它的生命周期只会来源于</strong>：</p>
<ul>
<li>函数参数的生命周期</li>
<li>函数体中某个新建引用的生命周期</li>
</ul>
<p>若是后者情况，就是典型的悬垂引用场景：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
<span class="boring">}
</span></code></pre></pre>
<p>上面的函数的返回值就和参数 <code>x</code>，<code>y</code> 没有任何关系，而是引用了函数体内创建的字符串，那么很显然，该函数会报错：</p>
<pre><code class="language-console">error[E0515]: cannot return value referencing local variable `result` // 返回值result引用了本地的变量
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here
</code></pre>
<p>主要问题就在于，<code>result</code> 在函数结束后就被释放，但是在函数结束后，对 <code>result</code> 的引用依然在继续。在这种情况下，没有办法指定合适的生命周期来让编译通过，因此我们也就在 Rust 中避免了悬垂引用。</p>
<p>那遇到这种情况该怎么办？最好的办法就是返回内部字符串的所有权，然后把字符串的所有权转移给调用者：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn longest&lt;'a&gt;(_x: &amp;str, _y: &amp;str) -&gt; String {
    String::from(&quot;really long string&quot;)
}

fn main() {
   let s = longest(&quot;not&quot;, &quot;important&quot;);
}
</code></pre></pre>
<p>至此，可以对生命周期进行下总结：生命周期语法用来将函数的多个引用参数和返回值的作用域关联到一起，一旦关联到一起后，Rust就拥有充分的信息来确保我们的操作是内存安全的。</p>
<h2 id="结构体中的生命周期"><a class="header" href="#结构体中的生命周期">结构体中的生命周期</a></h2>
<p>不仅仅函数具有生命周期，结构体其实也有这个概念，只不过我们之前对结构体的使用都停留在非引用类型字段上。细心的同学应该能回想起来，之前为什么不在结构体中使用字符串字面量或者字符串切片，而是统一使用 <code>String</code> 类型？原因很简单，后者在结构体初始化时，只要转移所有权即可，而前者，抱歉，它们是引用，它们不能为所欲为。</p>
<p>既然之前已经理解了生命周期，那么意味着在结构体中使用引用也变得可能：只要为结构体中的<strong>每一个引用标注上生命周期</strong>即可：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
</code></pre></pre>
<p><code>ImportantExcerpt</code> 结构体中有一个引用类型的字段 <code>part</code>，因此需要为它标注上生命周期。结构体的生命周期标注语法跟泛型参数语法很像，需要对生命周期参数进行声明 <code>&lt;'a&gt;</code>。该生命周期标注说明，<strong>结构体 <code>ImportantExcerpt</code> 所引用的字符串 <code>str</code> 必须比该结构体活得更久</strong>。</p>
<p>从 <code>main</code> 函数实现来看，<code>ImportantExcerpt</code> 的生命周期从第4行开始，到 <code>main</code> 函数末尾结束，而该结构体引用的字符串从第一行开始，也是到 <code>main</code> 函数末尾结束，可以得出结论<strong>结构体引用的字符串活得比结构体久</strong>，这符合了编译器对生命周期的要求，因此编译通过。</p>
<p>与之相反，下面的代码就无法通过编译：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let i;
    {
        let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
        let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
        i = ImportantExcerpt {
            part: first_sentence,
        };
    }
    println!(&quot;{:?}&quot;,i);
}
</code></pre></pre>
<p>观察代码，<strong>可以看出结构体比它引用的字符串活得更久</strong>，引用字符串在内部语句块末尾 <code>}</code> 被释放后，<code>println!</code> 依然在外面使用了该结构体，因此会导致无效的引用，不出所料，编译报错：</p>
<pre><code class="language-console">error[E0597]: `novel` does not live long enough
  --&gt; src/main.rs:10:30
   |
10 |         let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
   |                              ^^^^^^^^^^^^^^^^ borrowed value does not live long enough
...
14 |     }
   |     - `novel` dropped here while still borrowed
15 |     println!(&quot;{:?}&quot;,i);
   |                     - borrow later used here
</code></pre>
<h2 id="生命周期消除"><a class="header" href="#生命周期消除">生命周期消除</a></h2>
<p>实际上，对于编译器来说，每一个引用类型都有一个生命周期，那么为什么我们在使用过程中，很多时候无需标注生命周期？例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">}
</span></code></pre></pre>
<p>该函数的参数和返回值都是引用类型，尽管我们没有显式的为其标注生命周期，编译依然可以通过。其实原因不复杂，<strong>编译器为了简化用户的使用，运用了生命周期消除大法</strong>。</p>
<p>对于 <code>first_word</code> 函数，它的返回值是一个引用类型，那么该引用只有两种情况：</p>
<ul>
<li>从参数获取</li>
<li>从函数体内部新创建的变量获取</li>
</ul>
<p>如果是后者，就会出现悬垂引用，最终被编译器拒绝，因此只剩一种情况：返回值的引用是获取自参数，这就意味着参数和返回值的生命周期是一样的。道理很简单，我们能看出来，编译器自然也能看出来，因此，就算我们不标注生命周期，也不会产生歧义。</p>
<p>实际上，在 Rust 1.0 版本之前，这种代码果断不给通过，因为 Rust 要求必须显式的为所有引用标注生命周期：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
<span class="boring">}
</span></code></pre></pre>
<p>在写了大量的类似代码后，Rust社区抱怨声四起，包括开发者自己都忍不了了，最终揭锅而起，这才有了我们今日的幸福。</p>
<p>生命周期消除的规则不是一蹴而就，而是伴随着 <code>总结-改善</code> 流程的周而复始，一步一步走到今天，这也意味着，该规则以后可能也会进一步增加，我们需要手动标注生命周期的时候也会越来越少，hooray!</p>
<p>在开始之前有几点需要注意：</p>
<ul>
<li>消除规则不是万能的，若编译器不能确定某件事是正确时，会直接判为不正确，那么你还是需要手动标注生命周期</li>
<li><strong>函数或者方法中，参数的生命周期被称为 <code>输入生命周期</code>，返回值的生命周期被称为 <code>输出生命周期</code></strong></li>
</ul>
<h4 id="三条消除规则"><a class="header" href="#三条消除规则">三条消除规则</a></h4>
<p>编译器使用三条消除规则来确定哪些场景不需要显式地去标注生命周期。其中第一条规则应用在输入生命周期上，第二、三条应用在输出生命周期上。若编译器发现三条规则都不适用时，就会报错，提示你需要手动标注生命周期。</p>
<ol>
<li>
<p><strong>每一个引用参数都会获得独自的生命周期</strong></p>
<p>例如一个引用参数的函数就有一个生命周期标注: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>，两个引用参数的有两个生命周期标注:<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>, 依此类推。</p>
</li>
<li>
<p><strong>若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期</strong>，也就是所有返回值的生命周期都等于该输入生命周期</p>
<p>例如函数 <code>fn foo(x: &amp;i32) -&gt; &amp;i32</code>，<code>x</code> 参数的生命周期会被自动赋给返回值 <code>&amp;i32</code>，因此该函数等同于 <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code></p>
</li>
<li>
<p><strong>若存在多个输入生命周期，且其中一个是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，则 <code>&amp;self</code> 的生命周期被赋给所有的输出生命周期</strong></p>
<p>拥有 <code>&amp;self</code> 形式的参数，说明该函数是一个 <code>方法</code>，该规则让方法的使用便利度大幅提升。</p>
</li>
</ol>
<p>规则其实很好理解，但是，爱思考的读者肯定要发问了，例如第三条规则，若一个方法，它的返回值的生命周期就是跟参数 <code>&amp;self</code> 的不一样怎么办？总不能强迫我返回的值总是和 <code>&amp;self</code> 活得一样久吧？! 问得好，答案很简单：手动标注生命周期，因为这些规则只是编译器发现你没有标注生命周期时默认去使用的，当你标注生命周期后，编译器自然会乖乖听你的话。</p>
<p>让我们假装自己是编译器，然后看下以下的函数该如何应用这些规则：</p>
<p><strong>例子1</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word(s: &amp;str) -&gt; &amp;str { // 实际项目中的手写代码
<span class="boring">}
</span></code></pre></pre>
<p>首先，我们手写的代码如上所示时，编译器会先应用第一条规则，为每个参数标注一个生命周期：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str { // 编译器自动为参数添加生命周期
<span class="boring">}
</span></code></pre></pre>
<p>此时，第二条规则就可以进行应用，因为函数只有一个输入生命周期，因此该生命周期会被赋予所有的输出生命周期：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str { // 编译器自动为返回值添加生命周期
<span class="boring">}
</span></code></pre></pre>
<p>此时，编译器为函数签名中的所有引用都自动添加了具体的生命周期，因此编译通过，且用户无需手动去标注生命周期，只要按照 <code>fn first_word(s: &amp;str) -&gt; &amp;str { </code> 的形式写代码即可。</p>
<p><strong>例子2</strong>
再来看一个例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str { // 实际项目中的手写代码
<span class="boring">}
</span></code></pre></pre>
<p>首先，编译器会应用第一条规则，为每个参数都标注生命周期：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
<span class="boring">}
</span></code></pre></pre>
<p>但是此时，第二条规则却无法被使用，因为输入生命周期有两个，第三条规则也不符合，因为它是函数，不是方法，因此没有 <code>&amp;self</code> 参数。在套用所有规则后，编译器依然无法为返回值标注合适的生命周期，因此，编译器就会报错，提示我们需要手动标注生命周期：</p>
<pre><code class="language-console">error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:1:47
  |
1 | fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
  |                       -------     -------     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
note: these named lifetimes are available to use
 --&gt; src/main.rs:1:12
  |
1 | fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
  |            ^^  ^^
help: consider using one of the available lifetimes here
  |
1 | fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'lifetime str {
  |                                                +++++++++
</code></pre>
<p>不得不说，Rust 编译器真的很强大，还贴心的给我们提示了该如何修改，虽然。。。好像。。。。它的提示貌似不太准确。这里我们更希望参数和返回值都是 <code>'a</code> 命周期。</p>
<h2 id="方法中的生命周期"><a class="header" href="#方法中的生命周期">方法中的生命周期</a></h2>
<p>先来回忆下泛型的语法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>实际上，为具有生命周期的结构体实现方法时，我们使用的语法跟泛型参数语法很相似：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>其中有几点需要注意的：</p>
<ul>
<li><code>impl</code> 中必须使用结构体的完整名称，包括 <code>&lt;'a&gt;</code>，因为<em>生命周期标注也是结构体类型的一部分</em>！</li>
<li>方法签名中，往往不需要标注生命周期，得益于生命周期消除的第一和第三规则</li>
</ul>
<p>下面的例子展示了第三规则应用的场景：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>首先，编译器应用第一规则，给予每个输入参数一个生命周期:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part&lt;'b&gt;(&amp;'a self, announcement: &amp;'b str) -&gt; &amp;str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>需要注意的是，编译器不知道 <code>announcement</code> 的生命周期到底多长，因此它无法简单的给予它生命周期 <code>'a</code>，而是重新声明了一个全新的生命周期 <code>'b</code>。 </p>
<p>接着，编译器应用第三规则，将 <code>&amp;self</code> 的生命周期赋给返回值 <code>&amp;str</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part&lt;'b&gt;(&amp;'a self, announcement: &amp;'b str) -&gt; &amp;'a str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Bingo，最开始的代码，尽管我们没有给方法标注生命周期，但是在第一和第三规则的配合下，编译器依然完美的为我们亮起了绿灯。</p>
<p>在结束这块儿内容之前，再来做一个有趣的修改，将方法返回的生命周期改为<code>'b</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part&lt;'b&gt;(&amp;'a self, announcement: &amp;'b str) -&gt; &amp;'b str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>此时，编译器会报错，因为编译器无法知道 <code>'a</code> 和 <code>'b</code> 的关系。 <code>&amp;self</code> 生命周期是 <code>'a</code>，那么 <code>self.part</code> 的生命周期也是 <code>'a</code>，但是好巧不巧的是，我们手动为返回值 <code>self.part</code> 标注了生命周期 <code>'b</code>，因此编译器需要知道 <code>'a</code> 和 <code>'b</code> 的关系。</p>
<p>有一点很容易推理出来：由于 <code>&amp;'a self</code> 是被引用的一方，因此引用它的 <code>&amp;'b str</code> 必须要活得比它短，否则会出现悬垂引用。因此说明生命周期 <code>'b</code> 必须要比 <code>'a</code> 小，只要满足了这一点，编译器就不会再报错：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a: 'b, 'b&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;'a self, announcement: &amp;'b str) -&gt; &amp;'b str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Bang，一个复杂的玩意儿被甩到了你面前，就问怕不怕？</p>
<p>就关键点稍微解释下：</p>
<ul>
<li><code>'a: 'b</code>，是生命周期约束语法，跟泛型约束非常相似，用于说明<code>'a</code>必须比<code>'b</code>活得久</li>
<li>为了实现这一点，必须把<code>'a</code>和<code>'b</code>都在同一个地方声明，你不能把<code>'a</code>在<code>impl</code>后面声明，而把<code>'b</code>在方法中声明</li>
</ul>
<p>总之，实现方法比想象中简单：加一个约束，就能暗示编译器，尽管引用吧，反正我想引用的内容比我活得久，爱咋咋地，我怎么都不会引用到无效的内容！</p>
<h2 id="静态生命周期"><a class="header" href="#静态生命周期">静态生命周期</a></h2>
<p>在Rust中有一个非常特殊的生命周期，那就是 <code>'static</code>，该生命周期意味着被它标注的引用<strong>在编译器看来</strong>可以和整个程序活得一样久(强烈建议再看看这句<a href="advance/lifetime/basic.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8%E8%AF%AD%E6%B3%95">名言</a>！)。</p>
<p>在之前我们学过字符串字面量，提到过它是被硬编码进 Rust 的二进制文件中，因此这些字符串变量全部具有 <code>'static</code> 的生命周期：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;我没啥优点，就是活得久，嘿嘿&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>这时候，有些聪明的小脑瓜就开始开动了：当生命周期不知道怎么标时，标一个 <code>'static</code> 是不是很爽？这样我和编译器再也不用操心它到底活多久了。</p>
<p>嗯，只能说，这个想法是对的，在不少情况下，标注为 <code>'static</code> 确实可以解决生命周期编译不通过的问题，但是问题来了：本来该引用没有活那么久，但是你非要说它活那么久，万一引入了潜在的BUG怎么办？</p>
<p>因此，遇到因为生命周期导致的编译不通过问题，首先想的应该是：是否是我们试图创建一个悬垂引用，或者是试图匹配不一致的生命周期，而不是简单粗暴的用 <code>'static</code> 来解决问题。</p>
<p>但是，话说回来，存在即合理，有时候，<code>'static</code> 确实可以帮助我们解决非常复杂的生命周期问题甚至是无法被手动解决的生命周期问题，那么此时就应该放心大胆的用，只要你确定：<strong>你的所有引用的生命周期都是正确的，只是编译器太笨不懂罢了</strong>。</p>
<p>总结下：</p>
<ul>
<li>字符串字面量的生命周期都是 <code>'static</code></li>
<li>当你要为某个引用标注 <code>'static</code> 时，请确保它真的活得那么久</li>
<li>实在遇到解决不了的生命周期标注问题，可以尝试 <code>'static</code>，有时候它会给你奇迹</li>
</ul>
<h2 id="一个复杂例子-泛型特征约束"><a class="header" href="#一个复杂例子-泛型特征约束">一个复杂例子: 泛型、特征约束</a></h2>
<p>手指已经疲软无力，我好想停止，但是华丽的开场都要有与之匹配的谢幕，那我们就用一个稍微复杂点的例子来结束：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>依然是熟悉的配方 <code>longest</code>，但是多了一段废话： <code>ann</code>，因为要用格式化 <code>{}</code> 来输出 <code>ann</code>，因此需要它实现 <code>Display</code> 特征。</p>
<h2 id="总结-4"><a class="header" href="#总结-4">总结</a></h2>
<p>我不知道支撑我一口气写完的勇气是什么，也许是不做完不爽夫斯基，也许是一些读者对本书的期待，不管如何，这章足足写了17000字，可惜不是写小说，不然肯定可以获取很多月票 :) </p>
<p>从本章开始，最大的收获就是可以在结构体中使用引用类型了，说实话，为了引入这个特性，我已经憋了足足30章节。。</p>
<p>但是，还没完，是的，就算是将近2万字，生命周期的旅程依然没有完结，下一节将介绍一些关于生命周期的高级特性，这些特性你在其它中文书中目前还看不到的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="深入生命周期"><a class="header" href="#深入生命周期">深入生命周期</a></h1>
<p>其实关于生命周期的常用特性，在上一节中，我们已经概括得差不多了，本章主要讲解生命周期的一些高级或者不为人知的特性。对于新手，完全可以跳过本节内容，进行下一章节的学习。</p>
<h2 id="不太聪明的生命周期检查"><a class="header" href="#不太聪明的生命周期检查">不太聪明的生命周期检查</a></h2>
<p>在 Rust 语言学习中，一个很重要的部分就是阅读一些你可能不经常遇到，但是一旦遇到就难以理解的代码，这些代码往往最令人头疼的就是生命周期，这里我们就来看看一些本以为可以编译，但是却因为生命周期系统不够聪明导致编译失败的代码。</p>
<h4 id="例子1"><a class="header" href="#例子1">例子1</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Foo;

impl Foo {
    fn mutate_and_share(&amp;mut self) -&gt; &amp;Self {
        &amp;*self 
    }
    fn share(&amp;self) {}
}

fn main() {
    let mut foo = Foo;
    let loan = foo.mutate_and_share();
    foo.share();
    println!(&quot;{:?}&quot;, loan);
}
</code></pre></pre>
<p>上面的代码中，<code>foo.mutate_and_share()</code> 虽然借用了 <code>&amp;mut self</code>，但是它最终返回的是一个 <code>&amp;self</code>，然后赋值给 <code>loan</code>，因此理论上来说它最终是进行了不可变借用，同时 <code>foo.share</code> 也进行了不可变借用，那么根据 Rust 的借用规则：多个不可变借用可以同时存在，因此该代码应该编译通过。</p>
<p>事实上，运行代码后，你将看到一个错误：</p>
<pre><code class="language-console">error[E0502]: cannot borrow `foo` as immutable because it is also borrowed as mutable
  --&gt; src/main.rs:12:5
   |
11 |     let loan = foo.mutate_and_share();
   |                ---------------------- mutable borrow occurs here
12 |     foo.share();
   |     ^^^^^^^^^^^ immutable borrow occurs here
13 |     println!(&quot;{:?}&quot;, loan);
   |                      ---- mutable borrow later used here
</code></pre>
<p>编译器的提示在这里其实有些难以理解，因为可变借用仅在 <code>mutate_and_share</code> 方法内部有效，出了该方法后，就只有返回的不可变借用，因此，按理来说可变借用不应该在 <code>main</code> 的作用范围内存在。</p>
<p>对于这个反直觉的事情，让我们用生命周期来解释下，可能你就很好理解了：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Foo;

impl Foo {
    fn mutate_and_share&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a Self {
        &amp;'a *self 
    }
    fn share&lt;'a&gt;(&amp;'a self) {}
}

fn main() {
    'b: {
        let mut foo: Foo = Foo;
        'c: {
            let loan: &amp;'c Foo = Foo::mutate_and_share::&lt;'c&gt;(&amp;'c mut foo);
            'd: {
                Foo::share::&lt;'d&gt;(&amp;'d foo);
            }
            println!(&quot;{:?}&quot;, loan);
        }
    }
}
</code></pre></pre>
<p>以上是模拟了编译器的生命周期标注后的代码，可以注意到 <code>&amp;mut foo</code> 和 <code>loan</code> 的生命周期都是 <code>'c</code>。</p>
<p>还记得生命周期消除规则中的第三条吗？因为该规则，导致了 <code>mutate_and_share</code> 方法中，参数 <code>&amp;mut self</code> 和返回值 <code>&amp;self</code> 的生命周期是相同的，因此，若返回值的生命周期在 <code>main</code> 函数有效，那 <code>&amp;mut self</code> 的借用也是在 <code>main</code> 函数有效。</p>
<p>这就解释了可变借用为啥会在 <code>main</code> 函数作用域内有效，最终导致 <code>foo.share()</code> 无法再进行不可变借用。</p>
<p>上述代码实际上完全是正确的，但是因为生命周期系统的“粗糙实现”，导致了编译错误，目前来说，遇到这种生命周期系统不够聪明导致的编译错误，我们也没有太好的办法，只能修改代码去满足它的需求，并期待以后它会更聪明。</p>
<h4 id="例子2"><a class="header" href="#例子2">例子2</a></h4>
<p>再来看一个例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![allow(unused)]
fn main() {
    use std::collections::HashMap;
    use std::hash::Hash;
    fn get_default&lt;'m, K, V&gt;(map: &amp;'m mut HashMap&lt;K, V&gt;, key: K) -&gt; &amp;'m mut V
    where
        K: Clone + Eq + Hash,
        V: Default,
    {
        match map.get_mut(&amp;key) {
            Some(value) =&gt; value,
            None =&gt; {
                map.insert(key.clone(), V::default());
                map.get_mut(&amp;key).unwrap()
            }
        }
    }
}

</code></pre></pre>
<p>这段代码不能通过编译的原因是编译器未能精确地判断出某个可变借用不再需要，反而谨慎的给该借用安排了一个很大的作用域，结果导致后续的借用失败：</p>
<pre><code class="language-console">error[E0499]: cannot borrow `*map` as mutable more than once at a time
  --&gt; src/main.rs:13:17
   |
5  |       fn get_default&lt;'m, K, V&gt;(map: &amp;'m mut HashMap&lt;K, V&gt;, key: K) -&gt; &amp;'m mut V
   |                      -- lifetime `'m` defined here
...
10 |           match map.get_mut(&amp;key) {
   |           -     ----------------- first mutable borrow occurs here
   |  _________|
   | |
11 | |             Some(value) =&gt; value,
12 | |             None =&gt; {
13 | |                 map.insert(key.clone(), V::default());
   | |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ second mutable borrow occurs here
14 | |                 map.get_mut(&amp;key).unwrap()
15 | |             }
16 | |         }
   | |_________- returning this value requires that `*map` is borrowed for `'m`
</code></pre>
<p>分析代码可知在 <code>match map.get_mut(&amp;key)</code> 方法调用完成后，对 <code>map</code> 的可变借用就可以结束了。但从报错看来，编译器不太聪明，它认为该借用会持续到整个 <code>match</code> 语句块的结束(第16行处)，这便造成了后续借用的失败。</p>
<p>类似的例子还有很多，由于篇幅有限，就不在这里一一列举，如果大家想要阅读更多的类似代码，可以看看<a href="https://github.com/sunface/rust-codes">&lt;&lt;Rust代码鉴赏&gt;&gt;</a>一书。</p>
<h2 id="无界生命周期"><a class="header" href="#无界生命周期">无界生命周期</a></h2>
<p>不安全代码(<code>unsafe</code>)经常会凭空产生引用或生命周期，这些生命周期被称为是 <strong>无界(unbound)</strong> 的。</p>
<p>无界生命周期往往是在解引用一个原生指针(裸指针raw pointer)时产生的，换句话说，它是凭空产生的，因为输入参数根本就没有这个生命周期：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'a, T&gt;(x: *const T) -&gt; &amp;'a T {
    unsafe {
        &amp;*x
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上述代码中，参数 <code>x</code> 是一个裸指针，它并没有任何生命周期，然后通过 <code>unsafe</code> 操作后，它被进行了解引用，变成了一个 Rust 的标准引用类型，该类型必须要有生命周期，也就是 <code>'a</code>。</p>
<p>可以看出 <code>'a</code> 是凭空产生的，因此它是无界生命周期。这种生命周期由于没有受到任何约束，因此它想要多大就多大，这实际上比 <code>'static</code> 要强大。例如 <code>&amp;'static &amp;'a T</code> 是无效类型，但是无界生命周期 <code>&amp;'unbounded &amp;'a T</code> 会被视为 <code>&amp;'a &amp;'a T</code> 从而通过编译检查，因为它可大可小，就像孙猴子的金箍棒一般。</p>
<p>我们在实际应用中，要尽量避免这种无界生命周期。最简单的避免无界生命周期的方式就是在函数声明中运用生命周期消除规则。<strong>若一个输出生命周期被消除了，那么必定因为有一个输入生命周期与之对应</strong>。</p>
<h2 id="生命周期约束-hrtb"><a class="header" href="#生命周期约束-hrtb">生命周期约束 HRTB</a></h2>
<p>生命周期约束跟特征约束类似，都是通过形如 <code>'a: 'b</code> 的语法，来说明两个生命周期的长短关系。</p>
<h4 id="a-b"><a class="header" href="#a-b">'a: 'b</a></h4>
<p>假设有两个引用 <code>&amp;'a i32</code> 和 <code>&amp;'b i32</code>，它们的生命周期分别是 <code>'a</code> 和 <code>'b</code>，若 <code>'a</code> &gt;= <code>'b</code>，则可以定义 <code>'a:'b</code>，表示 <code>'a</code> 至少要活得跟 <code>'b</code> 一样久。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DoubleRef&lt;'a,'b:'a, T&gt; {
    r: &amp;'a T,
    s: &amp;'b T
}
<span class="boring">}
</span></code></pre></pre>
<p>例如上述代码定义一个结构体，它拥有两个引用字段，类型都是泛型 <code>T</code>，每个引用都拥有自己的生命周期，由于我们使用了生命周期约束 <code>'b: 'a</code>，因此 <code>'b</code> 必须活得比 <code>'a</code> 久，也就是结构体中的 <code>r</code> 字段引用的值必须要比 <code>s</code> 字段引用的值活得要久。</p>
<h4 id="t-a"><a class="header" href="#t-a">T: 'a</a></h4>
<p>表示类型 <code>T</code> 必须比 <code>'a</code> 活得要久：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ref&lt;'a, T: 'a&gt; {
    r: &amp;'a T
}
<span class="boring">}
</span></code></pre></pre>
<p>因为结构体字段 <code>r</code> 引用了 <code>T</code>，因此 <code>r</code> 的生命周期 <code>'a</code> 必须要比 <code>T</code> 的生命周期更短(被引用者的生命周期必须要比引用长)。</p>
<p>在 Rust 1.30 版本之前，该写法是必须的，但是从 1.31 版本开始，编译器可以自动推导 <code>T: 'a</code> 类型的约束，因此我们只需这样写即可：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ref&lt;'a, T&gt; {
    r: &amp;'a T
}
<span class="boring">}
</span></code></pre></pre>
<p>来看一个使用了生命周期约束的综合例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

impl&lt;'a: 'b, 'b&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;'a self, announcement: &amp;'b str) -&gt; &amp;'b str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面的例子中必须添加约束 <code>'a: 'b</code> 后，才能成功编译，因为 <code>self.part</code> 的生命周期与 <code>self</code>的生命周期一致，将 <code>&amp;'a</code> 类型的生命周期强行转换为 <code>&amp;'b</code> 类型，会报错，只有在 <code>'a</code> &gt;= <code>'b</code> 的情况下，<code>'a</code> 才能转换成 <code>'b</code>。</p>
<h2 id="闭包函数的消除规则"><a class="header" href="#闭包函数的消除规则">闭包函数的消除规则</a></h2>
<p>先来看一段简单的代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fn_elision(x: &amp;i32) -&gt; &amp;i32 { x } 
let closure_slision = |x: &amp;i32| -&gt; &amp;i32 { x };
<span class="boring">}
</span></code></pre></pre>
<p>乍一看，这段代码比古天乐还平平无奇，能有什么问题呢？来，拄拐走两圈试试：</p>
<pre><code class="language-console">error: lifetime may not live long enough 
  --&gt; src/main.rs:39:39
   |
39 |     let closure = |x: &amp;i32| -&gt; &amp;i32 { x }; // fails
   |                       -        -      ^ returning this value requires that `'1` must outlive `'2`
   |                       |        |
   |                       |        let's call the lifetime of this reference `'2`
   |                       let's call the lifetime of this reference `'1`
</code></pre>
<p>咦？竟然报错了，明明两个一模一样功能的函数，一个正常编译，一个却报错，错误原因是编译器无法推测返回的引用和传入的引用谁活得更久！</p>
<p>真的是非常奇怪的错误，学过上一节的读者应该都记得这样一条生命周期消除规则：<strong>如果函数参数中只有一个引用类型，那该引用的生命周期会被自动分配给所有的返回引用</strong>。我们当前的情况完美符合， <code>function</code> 函数的顺利编译通过，就充分说明了问题。</p>
<p>首先给出一个结论：<strong>这个问题，可能很难被解决，建议大家遇到后，还是老老实实用正常的函数，不要秀闭包了</strong>。</p>
<p>对于函数的生命周期而言，它的消除规则之所以能生效是因为它的生命周期完全体现在签名的引用类型上，在函数体中无需任何体现：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fn_elision(x: &amp;i32) -&gt; &amp;i32 {..}
<span class="boring">}
</span></code></pre></pre>
<p>因此编译器可以做各种编译优化，也很容易根据参数和返回值进行生命周期的分析，最终得出消除规则。</p>
<p>可是闭包，并没有函数那么简单，它的生命周期分散在参数和闭包函数体中(主要是它没有确切的返回值签名)：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let closure_slision = |x: &amp;i32| -&gt; &amp;i32 { x };
<span class="boring">}
</span></code></pre></pre>
<p>编译器就必须深入到闭包函数体中，去分析和推测生命周期，复杂度因此极具提升：试想一下，编译器该如何从复杂的上下文中分析出参数引用的生命周期和闭包体中生命周期的关系？</p>
<p>由于上述原因(当然，实际情况复杂的多)，Rust 语言开发者目前其实是有意针对函数和闭包实现了两种不同的生命周期消除规则。</p>
<h2 id="nll-non-lexical-lifetime"><a class="header" href="#nll-non-lexical-lifetime">NLL (Non-Lexical Lifetime)</a></h2>
<p>之前我们在<a href="advance/lifetime/../../basic/ownership/borrowing.html#NLL">引用与借用</a>那一章其实有讲到过这个概念，简单来说就是：<strong>引用的生命周期正常来说应该从借用开始一直持续到作用域结束</strong>，但是这种规则会让多引用共存的情况变得更复杂：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; 
    let r2 = &amp;s; 
    println!(&quot;{} and {}&quot;, r1, r2);
    // 新编译器中，r1,r2作用域在这里结束

    let r3 = &amp;mut s; 
    println!(&quot;{}&quot;, r3);
}
</code></pre></pre>
<p>按照上述规则，这段代码将会报错，因为 <code>r1</code> 和 <code>r2</code> 的不可变引用将持续到 <code>main</code> 函数结束，而在此范围内，我们又借用了 <code>r3</code> 的可变引用，这违反了借用的规则：要么多个不可变借用，要么一个可变借用。 </p>
<p>好在，该规则从 1.31 版本引入 <code>NLL</code> 后，就变成了：<strong>引用的生命周期从借用处开始，一直持续到最后一次使用的地方</strong>。</p>
<p>按照最新的规则，我们再来分析一下上面的代码。<code>r1</code> 和 <code>r2</code> 不可变借用在 <code>println!</code> 后就不再使用，因此生命周期也随之结束，那么 <code>r3</code> 的借用就不再违反借用的规则，皆大欢喜。</p>
<p>再来看一段关于 <code>NLL</code> 的代码解释：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut u = 0i32;
let mut v = 1i32;
let mut w = 2i32;

// lifetime of `a` = α ∪ β ∪ γ
let mut a = &amp;mut u;     // --+ α. lifetime of `&amp;mut u`  --+ lexical &quot;lifetime&quot; of `&amp;mut u`,`&amp;mut u`, `&amp;mut w` and `a`
use(a);                 //   |                            |
*a = 3; // &lt;-----------------+                            |
...                     //                                |
a = &amp;mut v;             // --+ β. lifetime of `&amp;mut v`    |
use(a);                 //   |                            |
*a = 4; // &lt;-----------------+                            |
...                     //                                |
a = &amp;mut w;             // --+ γ. lifetime of `&amp;mut w`    |
use(a);                 //   |                            |
*a = 5; // &lt;-----------------+ &lt;--------------------------+
<span class="boring">}
</span></code></pre></pre>
<p>这段代码一目了然，<code>a</code> 有三段生命周期：<code>α</code>，<code>β</code>，<code>γ</code>，每一段生命周期都随着当前值的最后一次使用而结束。</p>
<p>在实际项目中，<code>NLL</code> 规则可以大幅减少引用冲突的情况，极大的便利了用户，因此广受欢迎，最终该规则甚至演化成一个独立的项目，未来可能会进一步简化我们的使用，<code>Polonius</code>：</p>
<ul>
<li><a href="https://github.com/rust-lang/polonius">项目地址</a> </li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2018/04/27/an-alias-based-formulation-of-the-borrow-checker/">具体介绍</a></li>
</ul>
<h1 id="reborrow-再借用"><a class="header" href="#reborrow-再借用">Reborrow 再借用</a></h1>
<p>学完 <code>NLL</code> 后，我们就有了一定的基础，可以继续学习关于借用和生命周期的一个高级内容：<strong>再借用</strong>。</p>
<p>先来看一段代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn move_to(&amp;mut self, x: i32, y: i32) {
        self.x = x;
        self.y = y;
    }
}

fn main() {
    let mut p = Point { x: 0, y: 0 };
    let r = &amp;mut p;
    let rr: &amp;Point = &amp;*r;

    println!(&quot;{:?}&quot;, rr);
    r.move_to(10, 10);
    println!(&quot;{:?}&quot;, r);
}
</code></pre></pre>
<p>以上代码，大家可能会觉得可变引用 <code>r</code> 和不可变引用 <code>rr</code> 同时存在会报错吧？但是事实上并不会，原因在于 <code>rr</code> 是对 <code>r</code> 的再借用。</p>
<p>对于再借用而言，<code>rr</code> 再借用时不会破坏借用规则，但是你不能在它的生命周期内再使用原来的借用 <code>r</code>，来看看对上段代码的分析：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut p = Point { x: 0, y: 0 };
    let r = &amp;mut p;
    // reborrow! 此时对`r`的再借用不会导致跟上面的借用冲突
    let rr: &amp;Point = &amp;*r;
    
    // 再借用`rr`最后一次使用发生在这里，在它的生命周期中，我们并没有使用原来的借用`r`，因此不会报错
    println!(&quot;{:?}&quot;, rr);

    // 再借用结束后，才去使用原来的借用`r`
    r.move_to(10, 10);
    println!(&quot;{:?}&quot;, r);
}
</code></pre></pre>
<p>再来看一个例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::vec::Vec;
fn read_length(strings: &amp;mut Vec&lt;String&gt;) -&gt; usize {
   strings.len()
}
<span class="boring">}
</span></code></pre></pre>
<p>如上所示，函数体内对参数的二次借用也是典型的 <code>Reborrow</code> 场景。</p>
<p>那么下面让我们来做件坏事，破坏这条规则，使其报错：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut p = Point { x: 0, y: 0 };
    let r = &amp;mut p;
    let rr: &amp;Point = &amp;*r; 

    r.move_to(10, 10);
    
    println!(&quot;{:?}&quot;, rr);

    println!(&quot;{:?}&quot;, r);
}
</code></pre></pre>
<p>果然，破坏永远比重建简单 :) 只需要在 <code>rr</code> 再借用的生命周期内使用一次原来的借用 <code>r</code> 即可！</p>
<h2 id="生命周期消除规则补充"><a class="header" href="#生命周期消除规则补充">生命周期消除规则补充</a></h2>
<p>在上一节中，我们介绍了三大基础生命周期消除规则，实际上，随着 Rust 的版本进化，该规则也在不断演进，这里再介绍几个常见的消除规则：</p>
<h4 id="impl块消除"><a class="header" href="#impl块消除">impl块消除</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; Reader for BufReader&lt;'a&gt; {
    // methods go here
    // impl内部实际上没有用到'a
}
<span class="boring">}
</span></code></pre></pre>
<p>如果你以前写的<code>impl</code>块长上面这样，同时在 <code>impl</code> 内部的方法中，根本就没有用到 <code>'a</code>，那就可以写成下面的代码形式。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Reader for BufReader&lt;'_&gt; {
    // methods go here
}
<span class="boring">}
</span></code></pre></pre>
<p><code>'_</code> 生命周期表示 <code>BufReader</code> 有一个不使用的生命周期，我们可以忽略它，无需为它创建一个名称。</p>
<p>歪个楼，有读者估计会发问：既然用不到 <code>'a</code>，为何还要写出来？如果你仔细回忆下上一节的内容，里面有一句专门用粗体标注的文字：<strong>生命周期参数也是类型的一部分</strong>，因此 <code>BufReader&lt;'a&gt;</code> 是一个完整的类型，在实现它的时候，你不能把 <code>'a</code> 给丢了！</p>
<h4 id="生命周期约束消除"><a class="header" href="#生命周期约束消除">生命周期约束消除</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 2015
struct Ref&lt;'a, T: 'a&gt; {
    field: &amp;'a T
}

// Rust 2018
struct Ref&lt;'a, T&gt; {
    field: &amp;'a T
}
<span class="boring">}
</span></code></pre></pre>
<p>在本节的生命周期约束中，也提到过，新版本 Rust 中，上面情况中的 <code>T: 'a</code> 可以被消除掉，当然，你也可以显式的声明，但是会影响代码可读性。关于类似的场景，Rust 团队计划在未来提供更多的消除规则，但是，你懂的，计划未来就等于未知。</p>
<h2 id="一个复杂的例子"><a class="header" href="#一个复杂的例子">一个复杂的例子</a></h2>
<p>下面是一个关于生命周期声明过大的例子，会较为复杂，希望大家能细细阅读，它能帮你对生命周期的理解更加深入。</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Interface&lt;'a&gt; {
    manager: &amp;'a mut Manager&lt;'a&gt;
}

impl&lt;'a&gt; Interface&lt;'a&gt; {
    pub fn noop(self) {
        println!(&quot;interface consumed&quot;);
    }
}

struct Manager&lt;'a&gt; {
    text: &amp;'a str    
}

struct List&lt;'a&gt; {
    manager: Manager&lt;'a&gt;,
}

impl&lt;'a&gt; List&lt;'a&gt; {
    pub fn get_interface(&amp;'a mut self) -&gt; Interface {
        Interface {
            manager: &amp;mut self.manager
        }
    }
} 

fn main() {
    let mut list = List {
        manager: Manager {
            text: &quot;hello&quot;
        }
    };
    
    list.get_interface().noop();
    
    println!(&quot;Interface should be dropped here and the borrow released&quot;);
    
    // 下面的调用会失败，因为同时有不可变/可变借用
    // 但是Interface在之前调用完成后就应该被释放了
    use_list(&amp;list);
}

fn use_list(list: &amp;List) {
    println!(&quot;{}&quot;, list.manager.text);
}
</code></pre></pre>
<p>运行后报错：</p>
<pre><code class="language-console">error[E0502]: cannot borrow `list` as immutable because it is also borrowed as mutable // `list`无法被借用，因为已经被可变借用
  --&gt; src/main.rs:40:14
   |
34 |     list.get_interface().noop();
   |     ---- mutable borrow occurs here // 可变借用发生在这里
...
40 |     use_list(&amp;list);
   |              ^^^^^
   |              |
   |              immutable borrow occurs here // 新的不可变借用发生在这
   |              mutable borrow later used here // 可变借用在这里结束
</code></pre>
<p>这段代码看上去并不复杂，实际上难度挺高的，首先在直觉上，<code>list.get_interface()</code> 借用的可变引用，按理来说应该在这行代码结束后，就归还了，但是为什么还能持续到 <code>use_list(&amp;list)</code> 后面呢？</p>
<p>这是因为我们在 <code>get_interface</code> 方法中声明的 <code>lifetime</code> 有问题，该方法的参数的生命周期是 <code>'a</code>，而 <code>List</code> 的生命周期也是 <code>'a</code>，说明该方法至少活得跟 <code>List</code> 一样久，再回到 <code>main</code> 函数中，<code>list</code> 可以活到 <code>main</code> 函数的结束，因此 <code>list.get_interface()</code> 借用的可变引用也会活到 <code>main</code> 函数的结束，在此期间，自然无法再进行借用了。</p>
<p>要解决这个问题，我们需要为 <code>get_interface</code> 方法的参数给予一个不同于 <code>List&lt;'a&gt;</code> 的生命周期 <code>'b</code>，最终代码如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Interface&lt;'b, 'a: 'b&gt; {
    manager: &amp;'b mut Manager&lt;'a&gt;
}

impl&lt;'b, 'a: 'b&gt; Interface&lt;'b, 'a&gt; {
    pub fn noop(self) {
        println!(&quot;interface consumed&quot;);
    }
}

struct Manager&lt;'a&gt; {
    text: &amp;'a str    
}

struct List&lt;'a&gt; {
    manager: Manager&lt;'a&gt;,
}

impl&lt;'a&gt; List&lt;'a&gt; {
    pub fn get_interface&lt;'b&gt;(&amp;'b mut self) -&gt; Interface&lt;'b, 'a&gt;
    where 'a: 'b {
        Interface {
            manager: &amp;mut self.manager
        }
    }
} 

fn main() {

    let mut list = List {
        manager: Manager {
            text: &quot;hello&quot;
        }
    };
    
    list.get_interface().noop();
    
    println!(&quot;Interface should be dropped here and the borrow released&quot;);
    
    // 下面的调用可以通过，因为Interface的生命周期不需要跟list一样长
    use_list(&amp;list);
}

fn use_list(list: &amp;List) {
    println!(&quot;{}&quot;, list.manager.text);
}
</code></pre></pre>
<p>至此，生命周期终于完结，两章超级长的内容，可以满足几乎所有对生命周期的学习目标。学完生命周期，意味着你正式入门了 Rust，只要再掌握几个常用概念，就可以上手写项目了，下面让我们看看在实际项目中极其常见的功能 - 迭代器。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数式编程"><a class="header" href="#函数式编程">函数式编程</a></h1>
<p>罗马不是一天建成的，编程语言亦是如此，每一门编程语言在借鉴前辈的同时，也会提出自己独有的特性，Rust 即是如此。当站在巨人肩膀上时，一个人所能看到的就更高更远，恰好，我们看到了函数式语言的优秀特性，例如：</p>
<ul>
<li>使用函数作为参数进行传递</li>
<li>使用函数作为函数返回值</li>
<li>将函数赋值给变量</li>
</ul>
<p>见猎心喜，我们忍不住就借鉴了过来，于是你能看到本章的内容，天下语言一大。。。跑题了。</p>
<p>关于函数式编程到底是什么的争论由来已久，本章节并不会踏足这个泥潭，因此我们在这里主要关注的是函数式特性：</p>
<ul>
<li>闭包closure</li>
<li>迭代器iterator</li>
<li>模式匹配</li>
<li>枚举</li>
</ul>
<p>其中后两个在前面章节我们已经深入学习过，因此本章的重点就是闭包和迭代器，<strong>这些函数式特性可以让代码的可读性和易写性大幅提升</strong>。对于 Rust 语言来说，掌握这两者就相当于你同时拥有了倚天剑屠龙刀，威力无穷。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="闭包closure"><a class="header" href="#闭包closure">闭包closure</a></h1>
<p>关于闭包这个词语由来已久，自上世纪60年代就由<code>Scheme</code>语言引进，之后，被广泛用于函数式编程语言中，进入21世纪后，各种现代化的编程语言也都不约而同的把闭包作为核心特性纳入到语言设计中来。那么到底何为闭包？</p>
<p>闭包是<strong>一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许捕获调用者作用域中的值</strong>，例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let x = 1;
   let sum = |y| x + y;

    assert_eq!(3, sum(2));
}
</code></pre></pre>
<p>上面的代码展示了非常简单的闭包<code>sum</code>，它拥有一个入参<code>y</code>，同时捕获了作用域中的<code>x</code>的值，因此调用<code>sum(2)</code>意味着将2(参数<code>y</code>)跟1（<code>x</code>）进行相加,最终返回它们的和:<code>3</code>。</p>
<p>可以看到<code>sum</code>非常符合闭包的定义：可以赋值给变量，允许捕获调用者作用域中的值。</p>
<h2 id="使用闭包来简化代码"><a class="header" href="#使用闭包来简化代码">使用闭包来简化代码</a></h2>
<h4 id="传统函数实现"><a class="header" href="#传统函数实现">传统函数实现</a></h4>
<p>想象一下，我们要进行健身，用代码怎么实现(写代码什么鬼，健身难道不应该去健身房嘛？答曰：健身太累了，还是虚拟健身好，点到为止)？这里是我的想法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::time::Duration;

// 开始健身，好累，我得发出声音：muuuu...
fn muuuuu(intensity: u32) -&gt; u32 {
    println!(&quot;muuuu.....&quot;);
    thread::sleep(Duration::from_secs(2));
    intensity
}

fn workout(intensity: u32, random_number: u32) {
    if intensity &lt; 25 {
        println!(
            &quot;今天活力满满, 先做 {} 个俯卧撑!&quot;,
            muuuuu(intensity)
        );
        println!(
            &quot;旁边有妹子在看，俯卧撑太low, 再来 {} 组卧推!&quot;,
            muuuuu(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;昨天练过度了，今天还是休息下吧！&quot;);
        } else {
            println!(
                &quot;昨天练过度了，今天干干有氧, 跑步 {} 分钟!&quot;,
                muuuuu(intensity)
            );
        }
    }
}

fn main() {
    // 强度
    let intensity = 10;
    // 随机值用来决定某个选择
    let random_number = 7;

    // 开始健身
    workout(intensity, random_number);
}
</code></pre></pre>
<p>可以看到，在健身时我们根据想要的强度来调整具体的动作，然后调用<code>muuuuu</code>函数来开始健身。这个程序本身很简单，没啥好说的，但是假如未来不用<code>muuuu</code>函数了，是不是得把所有<code>muuuu</code>都替换成，比如说<code>woooo</code>? 如果<code>muuuu</code>出现了几十次，那意味着我们要修改几十处地方。</p>
<h4 id="函数变量实现"><a class="header" href="#函数变量实现">函数变量实现</a></h4>
<p>一个可行的办法是，把函数赋值给一个变量，然后通过变量调用:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn workout(intensity: u32, random_number: u32) {
    let action = muuuuu;
    if intensity &lt; 25 {
        println!(
            &quot;今天活力满满, 先做 {} 个俯卧撑!&quot;,
            action(intensity)
        );
        println!(
            &quot;旁边有妹子在看，俯卧撑太low, 再来 {} 组卧推!&quot;,
            action(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;昨天练过度了，今天还是休息下吧！&quot;);
        } else {
            println!(
                &quot;昨天练过度了，今天干干有氧, 跑步 {} 分钟!&quot;,
                action(intensity)
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>经过上面修改后，所有的调用都通过<code>action</code>来完成，若未来声(动)音(作)变了，只要修改为<code>let action = woooo</code>即可。</p>
<p>但是问题又来了,若<code>intensity</code>也变了怎么办？例如变成<code>action(intensity + 1)</code>，那你又得哐哐哐修改几十处调用。</p>
<p>该怎么办？没太好的办法了，只能祭出大杀器：闭包。</p>
<h4 id="闭包实现"><a class="header" href="#闭包实现">闭包实现</a></h4>
<p>上面提到<code>intensity</code>要是变化怎么办，简单，使用闭包来捕获它，这是我们的拿手好戏:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn workout(intensity: u32, random_number: u32) {
    let action = || {
        println!(&quot;muuuu.....&quot;);
        thread::sleep(Duration::from_secs(2));
        intensity
    };

    if intensity &lt; 25 {
        println!(
            &quot;今天活力满满, 先做 {} 个俯卧撑!&quot;,
            action()
        );
        println!(
            &quot;旁边有妹子在看，俯卧撑太low, 再来 {} 组卧推!&quot;,
            action()
        );
    } else {
        if random_number == 3 {
            println!(&quot;昨天练过度了，今天还是休息下吧！&quot;);
        } else {
            println!(
                &quot;昨天练过度了，今天干干有氧, 跑步 {} 分钟!&quot;,
                action()
            );
        }
    }
}

fn main() {
    // 动作次数
    let intensity = 10;
    // 随机值用来决定某个选择
    let random_number = 7;

    // 开始健身
    workout(intensity, random_number);
}
</code></pre></pre>
<p>在上面代码中，无论你要修改什么，只要修改闭包<code>action</code>的实现即可，其它地方只负责调用，完美解决了我们的问题！</p>
<p>Rust闭包在形式上借鉴了<code>Smalltalk</code>和<code>Ruby</code>语言，与函数最大的不同就是它的参数是通过<code>|parm1|</code>的形式进行声明，如果是多个参数就<code>|param1, param2,...|</code>, 下面给出闭包的形式定义：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|param1, param2,...| {
    语句1;
    语句2;
    返回表达式
}
<span class="boring">}
</span></code></pre></pre>
<p>如果只有一个返回表达式的话，定义可以简化为：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|param1| 返回表达式
<span class="boring">}
</span></code></pre></pre>
<p>上例中还有两点值得注意:</p>
<ul>
<li><strong>闭包中最后一行表达式返回的值，就是闭包执行后的返回值</strong>，因此<code>action()</code>调用返回了<code>intensity</code>的值<code>10</code></li>
<li><code>let action = ||...</code>只是把闭包赋值给变量<code>action</code>，并不是把闭包执行后的结果赋值给<code>action</code>，因此这里<code>action</code>就相当于闭包函数，可以跟函数一样进行调用：<code>action()</code></li>
</ul>
<h2 id="闭包的类型推导"><a class="header" href="#闭包的类型推导">闭包的类型推导</a></h2>
<p>Rust是静态语言，因此所有的变量都具有类型，但是得益于编译器的强大类型推导能力，在很多时候我们并不需要显式的去声明类型，但是显然函数并不在此列，必须手动为函数的所有参数和返回值指定类型，原因在于函数往往会作为API提供给你的用户，因此你的用户必须在使用时知道传入参数的类型和返回值类型。</p>
<p>与函数相反，闭包并不会作为API对外提供，因此它可以享受编译器的类型推导能力，无需标注参数和返回值的类型。</p>
<p>为了增加代码可读性，有时候我们会显式的给类型进行标注，出于同样的目的，也可以给闭包标注类型：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sum = |x: i32, y: i32| -&gt; i32 {
    x + y
}
<span class="boring">}
</span></code></pre></pre>
<p>与之相比，不标注类型的闭包声明会更简洁些: <code>let sum = |x, y| x + y</code>, 需要注意的是，针对<code>sum</code>闭包，如果你不在后续代码中使用它，编译器会提示你为<code>x,y</code>添加类型标注，因为它缺乏必要的上下文：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sum  = |x, y| x + y;
let v = sum(1,2);
<span class="boring">}
</span></code></pre></pre>
<p>这里我们使用了<code>sum</code>，同时把<code>1</code>传给了<code>x</code>，<code>2</code>传给了<code>y</code>，因此编译器才可以推导出<code>x,y</code>的类型为<code>i32</code>。</p>
<p>下面展示了同一个功能的函数和闭包实现形式:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
<span class="boring">}
</span></code></pre></pre>
<p>可以看出第一行的函数和后面的闭包其实在形式上是非常接近的，同时三种不同的闭包也展示了三种不同的使用方式：省略参数、返回值和花括号对。</p>
<p>虽然类型推导很好用，但是它不是泛型，<strong>当编译器推导出一种类型后，它就会一直使用该类型</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let example_closure = |x| x;

let s = example_closure(String::from(&quot;hello&quot;));
let n = example_closure(5);
<span class="boring">}
</span></code></pre></pre>
<p>首先，在<code>s</code>中，编译器为<code>x</code>推导出类型<code>String</code>，但是紧接着<code>n</code>试图用<code>5</code>这个整型去调用闭包，跟编译器之前推导的<code>String</code>类型不符，因此报错：</p>
<pre><code class="language-console">error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |                             ^
  |                             |
  |                             expected struct `String`, found integer // 期待String类型，却发现一个整数
  |                             help: try using a conversion method: `5.to_string()`
</code></pre>
<h2 id="结构体中的闭包"><a class="header" href="#结构体中的闭包">结构体中的闭包</a></h2>
<p>假设我们要实现一个简易缓存，功能是获取一个值，然后将其缓存起来，那么可以这样设计：</p>
<ul>
<li>一个闭包用于获取值</li>
<li>一个变量，用于存储该值</li>
</ul>
<p>可以使用结构体来代表缓存对象，最终设计如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    query: T,
    value: Option&lt;u32&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>等等，我都跟着这本教程学完Rust基础了，为何还有我不认识的东东？<code>Fn(u32) -&gt; u32</code>是什么鬼？别急，先回答你第一个问题：骚年，too young too naive，你以为Rust的语法特性就基础入门那一些嘛？太年轻了！如果是长征，你才刚到赤水河.</p>
<p>其实，可以看的出这一长串是<code>T</code>的特征约束，再结合之前的已知信息：<code>query</code>是一个闭包，大概可以推测出，<code>Fn(u32) -&gt; u32</code>是一个特征，用来表示<code>T</code>是一个闭包类型？Bingo，恭喜你，答对了！</p>
<p>那为什么不用具体的类型来标注<code>query</code>呢？原因很简单，每一个闭包实例都有独属于自己的类型，甚至于两个签名一模一样的闭包，它们的类型都是不同的，因此你无法用一个统一的类型来标注<code>query</code>闭包。</p>
<p>而标准库提供的<code>Fn</code>系列特征，再结合特征约束，就很好的解决了这个问题. <code>T: Fn(u32) -&gt; u32</code>意味着<code>query</code>的类型是<code>T</code>，该类型必须实现了相应的闭包特征<code>Fn(u32) -&gt; u32</code>。从特征的角度来看它长得非常反直觉，但是如果从闭包的角度来看又极其符合直觉，不得不佩服Rust团队的鬼才设计。。。</p>
<p>特征<code>Fn(u32) -&gt; u32</code>从表面来看，就对闭包形式进行了显而易见的限制：<strong>该闭包拥有一个<code>u32</code>类型的参数，同时返回一个<code>u32</code>类型的值</strong>.</p>
<blockquote>
<p>需要注意的是，其实Fn特征不仅仅适用于闭包，还适用于函数，因此上面的<code>query</code>字段除了使用闭包作为值外，还能使用一个具名的函数来作为它的值</p>
</blockquote>
<p>接着，为缓存实现方法:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    fn new(query: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            query,
            value: None,
        }
    }

    // 先查询缓存值`self.value`，若不存在，则调用`query`加载
    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.query)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面的缓存有一个很大的问题：只支持<code>u32</code>类型的值，若我们想要缓存<code>String</code>类型，显然就行不通了，因此需要将<code>u32</code>替换成泛型<code>E</code>，该练习就留给读者自己完成，具体代码可以参考<a href="https://github.com/sunface/rust-course/blob/main/book/solutions/closure.md">这里</a></p>
<h2 id="捕获作用域中的值"><a class="header" href="#捕获作用域中的值">捕获作用域中的值</a></h2>
<p>在之前代码中，我们一直在用闭包的匿名函数特性(赋值给变量)，然而闭包还拥有一项函数所不具备的特性: 捕获作用域中的值。</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p>上面代码中，<code>x</code>并不是闭包<code>equal_to_x</code>的参数，但是它依然可以去使用<code>x</code>，因为<code>equal_to_x</code>在<code>x</code>的作用域范围内。</p>
<p>对于函数来说，就算你把函数定义在<code>main</code>函数体中，它也不能访问<code>x</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -&gt; bool {
        z == x
    }

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p>报错如下：</p>
<pre><code class="language-console">error[E0434]: can't capture dynamic environment in a fn item // 在函数中无法捕获动态的环境
 --&gt; src/main.rs:5:14
  |
5 |         z == x
  |              ^
  |
  = help: use the `|| { ... }` closure form instead // 使用闭包替代
</code></pre>
<p>如上所示，编译器准确的告诉了我们错误，同时甚至给出了提示：使用闭包来替代函数，这种聪明令我有些无所适从，总感觉会显得我很笨。</p>
<h4 id="闭包对内存的影响"><a class="header" href="#闭包对内存的影响">闭包对内存的影响</a></h4>
<p>当闭包从环境中捕获一个值时，会分配内存去存储这些值。对于有些场景来说，这种额外的内存分配会成为一种负担。与之相比，函数就不会去捕获这些环境值，因此定义和使用函数不会拥有这种内存负担。</p>
<h4 id="三种fn特征"><a class="header" href="#三种fn特征">三种Fn特征</a></h4>
<p>闭包捕获变量有三种途径，恰好对应函数参数的三种传入方式：转移所有权、可变借用、不可变借用，因此相应的Fn特征也有三种:</p>
<ol>
<li><code>FnOnce</code>, 该类型的闭包会拿走被捕获变量的所有权。<code>Once</code>顾名思义，说明该闭包只能运行一次：</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">fn fn_once&lt;F&gt;(func: F)
where
    F: FnOnce(usize) -&gt; bool,
{
    println!(&quot;{}&quot;, func(3));
    println!(&quot;{}&quot;, func(4));
}

fn main() {
    let x = vec![1, 2, 3];
    fn_once(|z|{z == x.len()})
}
</code></pre></pre>
<p><strong>仅</strong>实现 <code>FnOnce</code> 特征的闭包在调用时会转移所有权，所以显然不能对已失去所有权的闭包变量进行二次调用：</p>
<pre><code class="language-console">error[E0382]: use of moved value: `func`
 --&gt; src\main.rs:6:20
  |
1 | fn fn_once&lt;F&gt;(func: F)
  |               ---- move occurs because `func` has type `F`, which does not implement the `Copy` trait
                  // 因为`func`的类型是没有实现`Copy`特性的 `F`，所以发生了所有权的转移
...
5 |     println!(&quot;{}&quot;, func(3));
  |                    ------- `func` moved due to this call // 转移在这
6 |     println!(&quot;{}&quot;, func(4));
  |                    ^^^^ value used here after move // 转移后再次用
  |
</code></pre>
<p>这里面有一个很重要的提示，因为<code>F</code>没有实现<code>Copy</code>特征，所以会报错，那么我们添加一个约束，试试实现了<code>Copy</code>的闭包：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn fn_once&lt;F&gt;(func: F)
where
    F: FnOnce(usize) -&gt; bool + Copy,// 改动在这里
{
    println!(&quot;{}&quot;, func(3));
    println!(&quot;{}&quot;, func(4));
}

fn main() {
    let x = vec![1, 2, 3];
    fn_once(|z|{z == x.len()})
}
</code></pre></pre>
<p>上面代码中，<code>func</code>的类型<code>F</code>实现了<code>Copy</code>特征，调用时使用的将是它的拷贝，所以并没有发生所有权的转移。</p>
<pre><code class="language-console">true 
false
</code></pre>
<p>如果你想强制闭包取得捕获变量的所有权，可以在参数列表前添加<code>move</code>关键字，这种用法通常用于闭包的生命周期大于捕获变量的生命周期时，例如将闭包返回或移入其他线程。</p>
<ol start="2">
<li><code>FnMut</code>, 它以可变借用的方式捕获了环境中的值，因此可以修改该值：</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut s = String::new();

    let update_string =  |str| s.push_str(str);
    update_string(&quot;hello&quot;);
    
    println!(&quot;{:?}&quot;,s);
}
</code></pre></pre>
<p>在闭包中，我们调用<code>s.push_str</code>去改变外部<code>s</code>的字符串值，因此这里捕获了它的可变借用，运行下试试：</p>
<pre><code class="language-console">error[E0596]: cannot borrow `update_string` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:5:5  
  |
4 |     let update_string =  |str| s.push_str(str);
  |         -------------          - calling `update_string` requires mutable binding due to mutable borrow of `s`
  |         |
  |         help: consider changing this to be mutable: `mut update_string`
5 |     update_string(&quot;hello&quot;);
  |     ^^^^^^^^^^^^^ cannot borrow as mutable
</code></pre>
<p>虽然报错了，但是编译器给出了非常清晰的提示，想要在闭包内部捕获可变借用，需要把该闭包声明为可变类型，也就是<code>update_string</code>要修改为<code>mut update_string</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut s = String::new();

    let mut update_string =  |str| s.push_str(str);
    update_string(&quot;hello&quot;);
    
    println!(&quot;{:?}&quot;,s);
}
</code></pre></pre>
<p>这种写法有点反直觉，相比起来前面的<code>move</code>更符合使用和阅读习惯。但是如果你忽略<code>update_string</code>的类型，仅仅把它当成一个普通变量，那么这种声明就比较合理了。</p>
<p>再来看一个复杂点的：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut s = String::new();

    let update_string =  |str| s.push_str(str);
   
    exec(update_string);
    
    println!(&quot;{:?}&quot;,s);
}

fn exec&lt;'a, F: FnMut(&amp;'a str)&gt;(mut f: F)  {
    f(&quot;hello&quot;)
}
</code></pre></pre>
<p>这段代码非常清晰的说明了<code>update_string</code>实现了<code>FnMut</code>特征</p>
<ol start="3">
<li><code>Fn</code>特征，它以不可变借用的方式捕获环境中的值
让我们把上面的代码中<code>exec</code>的<code>F</code>泛型参数类型修改为<code>Fn(&amp;'a str)</code>，然后运行看看结果:</li>
</ol>
<pre><code class="language-console">error[E0525]: expected a closure that implements the `Fn` trait, but this closure only implements `FnMut`
 --&gt; src/main.rs:4:26  // 期望闭包实现的是`Fn`特征，但是它只实现了`FnMut`特征
  |
4 |     let update_string =  |str| s.push_str(str);
  |                          ^^^^^^-^^^^^^^^^^^^^^
  |                          |     |
  |                          |     closure is `FnMut` because it mutates the variable `s` here
  |                          this closure implements `FnMut`, not `Fn` //闭包实现的是FnMut，而不是Fn
5 |    
6 |     exec(update_string);
  |     ---- the requirement to implement `Fn` derives from here
</code></pre>
<p>从报错中很清晰的看出，我们的闭包实现的是<code>FnMut</code>特征，但是在<code>exec</code>中却给它标注了<code>Fn</code>特征，因此产生了不匹配，再来看看正确的不可变借用方式：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = &quot;hello, &quot;.to_string();

    let update_string =  |str| println!(&quot;{},{}&quot;,s,str);
   
    exec(update_string);
    
    println!(&quot;{:?}&quot;,s);
}

fn exec&lt;'a, F: Fn(String) -&gt; ()&gt;(f: F)  {
    f(&quot;world&quot;.to_string())
}
</code></pre></pre>
<p>在这里，因为无需改变<code>s</code>，因此闭包中只对<code>s</code>进行了不可变借用，那么在<code>exec</code>中，将其标记为<code>Fn</code>特征就完全正确。</p>
<h5 id="move和fn"><a class="header" href="#move和fn">move和Fn</a></h5>
<p>在上面，我们讲到了<code>move</code>关键字对于<code>FnOnce</code>特征的重要性，但是实际上使用了<code>move</code>的闭包依然可能实现了<code>Fn</code>或<code>FnMut</code>特征。</p>
<p>因为，<strong>一个闭包实现了哪种Fn特征取决于该闭包如何使用被捕获的变量，而不是取决于闭包如何捕获它们</strong>。<code>move</code>本身强调的就是后者：闭包如何捕获变量:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = String::new();

    let update_string =  move || println!(&quot;{}&quot;,s);
   
    exec(update_string);
}

fn exec&lt;F: Fn()&gt;(f: F)  {
    f()
}
</code></pre></pre>
<p>我们在上面的闭包中使用了<code>move</code>关键字，因此我们的闭包捕获了它，但是由于闭包对<code>s</code>的使用仅仅是不可变借用，因为该闭包实际上<strong>还</strong>实现了<code>Fn</code>特征，如<code>exec</code>函数所示。</p>
<p>细心的读者肯定发现我在上段中使用了一个<code>还</code>字，这是什么意思呢？因为该闭包不仅仅实现了<code>Fn</code>特征，还实现了<code>FnOnce</code>特征，因此将代码修改成下面这样，依然可以编译：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = String::new();

    let update_string =  move || println!(&quot;{}&quot;,s);
   
    exec(update_string);
}

fn exec&lt;F: FnOnce()&gt;(f: F)  {
    f()
}
</code></pre></pre>
<h5 id="三种fn的关系"><a class="header" href="#三种fn的关系">三种Fn的关系</a></h5>
<p>实际上，一个闭包并不仅仅实现某一种Fn特征，规则如下：</p>
<ul>
<li>所有的闭包都实现了<code>FnOnce</code>特征，因此任何一个闭包都至少可以被调用一次</li>
<li>没有移出所捕获变量的所有权的闭包实现了<code>FnMut</code>特征</li>
<li>不需要对捕获变量进行改变的闭包实现了<code>Fn</code>特征</li>
</ul>
<p>用一段代码来简单诠释上述规则:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = String::new();

    let update_string =  || println!(&quot;{}&quot;,s);
   
    exec(update_string);
    exec1(update_string);
    exec2(update_string);
}

fn exec&lt;F: FnOnce()&gt;(f: F)  {
    f()
}

fn exec1&lt;F: FnMut()&gt;(mut f: F)  {
    f()
}

fn exec2&lt;F: Fn()&gt;(f: F)  {
    f()
}
</code></pre></pre>
<p>虽然，闭包只是对<code>s</code>进行了不可变借用，实际上，它可以适用于任何一种<code>Fn</code>特征：三个<code>exec</code>函数说明了一切。强烈建议读者亲自动手试试各种情况下使用的<code>Fn</code>特征，更有助于加深这方面的理解。</p>
<p>关于第二条规则，有如下示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut s = String::new();

    let update_string = |str| -&gt; String {s.push_str(str); s };

    exec(update_string);
}

fn exec&lt;'a, F: FnMut(&amp;'a str) -&gt; String&gt;(mut f: F) {
    f(&quot;hello&quot;);
}
</code></pre></pre>
<pre><code class="language-console">5 |     let update_string = |str| -&gt; String {s.push_str(str); s };
  |                         ^^^^^^^^^^^^^^^                   - closure is `FnOnce` because it moves the variable `s` out of its environment
  |                                                           // 闭包实现了`FnOnce`，因为它从捕获环境中移出了变量`s`
  |                         |
  |                         this closure implements `FnOnce`, not `FnMut`
</code></pre>
<p>此例中，闭包从捕获环境中移出了变量<code>s</code>的所有权，因此这个闭包仅实现了<code>FnOnce</code>，未实现<code>FnMut</code>和<code>Fn</code>。再次印证之前讲的<strong>一个闭包实现了哪种Fn特征取决于该闭包如何使用被捕获的变量，而不是取决于闭包如何捕获它们</strong>，跟是否使用<code>move</code>没有必然联系。</p>
<p>如果还是有疑惑？没关系，我们来看看这三个特征的简化版源码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Fn&lt;Args&gt; : FnMut&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
}

pub trait FnMut&lt;Args&gt; : FnOnce&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
}

pub trait FnOnce&lt;Args&gt; {
    type Output;

    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>看到没？从特征约束能看出来<code>Fn</code>的前提是实现<code>FnMut</code>，<code>FnMut</code>的前提是实现<code>FnOne</code>，因此要实现<code>Fn</code>就要同时实现<code>FnMut</code>和<code>FnOnce</code>，这段源码从侧面印证了之前规则的正确性。</p>
<p>从源码中还能看出一点：<code>Fn</code>获取<code>&amp;self</code>，<code>FnMut</code>获取<code>&amp;mut self</code>，而<code>FnOnce</code>获取<code>self</code>.
在实际项目中，<strong>建议先使用<code>Fn</code>特征</strong>，然后编译器会告诉你正误以及该如何选择。</p>
<h2 id="闭包作为函数返回值"><a class="header" href="#闭包作为函数返回值">闭包作为函数返回值</a></h2>
<p>看到这里，相信大家对于如何使用闭包作为函数参数，已经很熟悉了，但是如果要使用闭包作为函数返回值，该如何做？</p>
<p>先来看一段代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn factory() -&gt; Fn(i32) -&gt; i32 {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
<span class="boring">}
</span></code></pre></pre>
<p>上面这段代码看起来还是蛮正常的，用<code>Fn(i32) -&gt; i32</code>特征来代表<code>|x| x + num</code>，非常合理嘛，肯定可以编译通过, 可惜理想总是难以照进现实，编译器给我们报了一大堆错误，先挑几个重点来看看：</p>
<pre><code class="language-console">fn factory&lt;T&gt;() -&gt; Fn(i32) -&gt; i32 {
  |                    ^^^^^^^^^^^^^^ doesn't have a size known at compile-time // 该类型在编译器没有固定的大小
</code></pre>
<p>Rust要求函数的参数和返回类型，必须有固定的内存大小，例如<code>i32</code>就是4个字节，引用类型是8个字节，总之，绝大部分类型都有固定的大小，但是不包括特征，因为特征类似接口，对于编译器来说，无法知道它后面藏的真实类型是什么，因为也无法得知具体的大小。</p>
<p>但是我们又无法知道闭包的具体类型，该怎么办呢？再看看报错提示:</p>
<pre><code class="language-console">help: use `impl Fn(i32) -&gt; i32` as the return type, as all return paths are of type `[closure@src/main.rs:11:5: 11:21]`, which implements `Fn(i32) -&gt; i32`
  |
8 | fn factory&lt;T&gt;() -&gt; impl Fn(i32) -&gt; i32 {
</code></pre>
<p>嗯，编译器提示我们加一个<code>impl</code>关键字，哦，这样一说，读者可能就想起来了，<code>impl Trait</code>可以用来返回一个实现了指定特征的类型，那么这里<code>impl Fn(i32) -&gt; i32</code>的返回值形式，说明我们要返回一个闭包类型，它实现了<code>Fn(i32) -&gt; i32</code>特征。</p>
<p>完美解决，但是，在<a href="advance/functional-programing/../../basic/trait/trait.html">特征</a>那一章，我们提到过，<code>impl Trait</code>的返回方式有一个非常大的局限，就是你只能返回同样的类型，例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn factory(x:i32) -&gt; impl Fn(i32) -&gt; i32 {

    let num = 5;

    if x &gt; 1{
        move |x| x + num
    } else {
        move |x| x - num
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>运行后，编译器报错:</p>
<pre><code class="language-console">error[E0308]: `if` and `else` have incompatible types
  --&gt; src/main.rs:15:9
   |
12 | /     if x &gt; 1{
13 | |         move |x| x + num
   | |         ---------------- expected because of this
14 | |     } else {
15 | |         move |x| x - num
   | |         ^^^^^^^^^^^^^^^^ expected closure, found a different closure
16 | |     }
   | |_____- `if` and `else` have incompatible types
   |
</code></pre>
<p>嗯，提示很清晰：<code>if</code>和<code>else</code>分支中返回了不同的闭包类型，这就很奇怪了，明明这两个闭包长的一样的，好在细心的读者应该回想起来，本章节前面咱们有提到：就算签名一样的闭包，类型也是不同的，因此在这种情况下，就无法再使用<code>impl Trait</code>的方式去返回闭包。</p>
<p>怎么办？再看看编译器提示，里面有这样一行小字:</p>
<pre><code class="language-console">= help: consider boxing your closure and/or using it as a trait object
</code></pre>
<p>哦，相信你已经恍然大悟，可以用特征对象！只需要用<code>Box</code>的方式即可实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn factory(x:i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    let num = 5;

    if x &gt; 1{
        Box::new(move |x| x + num)
    } else {
        Box::new(move |x| x - num)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>至此，闭包作为函数返回值就已完美解决，若以后你再遇到报错时，一定要仔细阅读编译器的提示，很多时候，转角都能遇到爱。</p>
<h2 id="闭包的生命周期"><a class="header" href="#闭包的生命周期">闭包的生命周期</a></h2>
<p>这块儿内容在进阶生命周期章节中有讲，这里就不再赘述，读者可移步<a href="https://course.rs/advance/lifetime/advance.html#%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E7%9A%84%E6%B6%88%E9%99%A4%E8%A7%84%E5%88%99">此处</a>进行回顾。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="迭代器iterator"><a class="header" href="#迭代器iterator">迭代器Iterator</a></h1>
<p>如果你询问一个Rust资深开发：写Rust项目最需要掌握什么？相信迭代器往往就是答案之一。无论你是编程新手亦或是高手，实际上大概率都用过迭代器，虽然自己可能并没有意识到这一点:)</p>
<p>迭代器允许我们迭代一个连续的集合，例如数组、动态数组Vec、<code>HashMap</code>等，在此过程中，只需关心集合中的元素如何处理，而无需去关心如何开始、如何结束、按照什么样的索引去访问等问题。</p>
<h2 id="for循环与迭代器"><a class="header" href="#for循环与迭代器">For循环与迭代器</a></h2>
<p>从用途来看，迭代器跟<code>for</code>循环颇为相似，都是去遍历一个集合，但是实际上它们存在不小的差别，其中最主要的差别就是：<strong>是否通过索引来访问集合</strong>。</p>
<p>例如以下的JS代码就是一个循环:</p>
<pre><code class="language-javascript">let arr = [1, 2, 3];
for (let i = 0; i &lt; arr.length; i++) {
    console.log(arr[i]);
}
</code></pre>
<p>在上面代码中，我们设置索引的开始点和结束点，然后再通过索引去访问元素<code>arr[i]</code>，这就是典型的循环，来对比下Rust中的<code>for</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr = [1, 2, 3];
for v in arr {
    println!(&quot;{}&quot;,v);
}
<span class="boring">}
</span></code></pre></pre>
<p>首先，不得不说这两语法还挺像！与JS循环不同，<code>Rust</code>中没有使用索引，它把<code>arr</code>数组当成一个迭代器，直接去遍历其中的元素，从哪里开始，从哪里结束，都无需操心。因此严格来说，Rust中的<code>for</code>循环是编译器提供的语法糖，最终还是对迭代器中的元素进行遍历。</p>
<p>那又有同学要发问了，在Rust中数组是迭代器吗？因为在之前的代码中直接对数组<code>arr</code>进行了迭代，答案是<code>No</code>。那既然数组不是迭代器，为啥咱可以对它的元素进行迭代呢？</p>
<p>简而言之就是数组实现了<code>IntoIterator</code>特征，Rust通过<code>for</code>语法糖，自动把实现了该特征的数组类型转换为迭代器(你也可以为自己的集合类型实现此特征)，最终让我们可以直接对一个数组进行迭代，类似的还有：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 1..10 {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<p>直接对数值序列进行迭代，也是很常见的使用方式。</p>
<p><code>IntoIterator</code>特征拥有一个<code>into_iter</code>方法，因此我们还可以显式的把数组转换成迭代器：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr = [1, 2, 3];
for v in arr.into_iter() {
    println!(&quot;{}&quot;, v);
}
<span class="boring">}
</span></code></pre></pre>
<p>迭代器是函数语言的核心特性，它赋予了Rust远超于循环的强大表达能力，我们也将在本章中一一为大家进行展现。</p>
<h2 id="惰性初始化"><a class="header" href="#惰性初始化">惰性初始化</a></h2>
<p>在Rust中，迭代器是惰性的，意味着如果你不使用它，那么它将不会发生任何事：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!(&quot;{}&quot;, val);
}
<span class="boring">}
</span></code></pre></pre>
<p>在<code>for</code>循环之前，我们只是简单的创建了一个迭代器<code>v1_iter</code>，此时不会发生任何迭代行为，只有在<code>for</code>循环开始后，迭代器才会开始迭代其中的元素，最后打印出来。</p>
<p>这种惰性初始化的方式确保了创建迭代器不会有任何额外的性能损耗，其中的元素也不会被消耗，只有到使用该迭代器的时候，一切才开始。</p>
<h2 id="next方法"><a class="header" href="#next方法">next方法</a></h2>
<p>对于<code>for</code>如何遍历迭代器，还有一个问题，它如何取出迭代器中的元素？</p>
<p>先来看一个特征:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // 省略其余有默认实现的方法
}
<span class="boring">}
</span></code></pre></pre>
<p>呦，该特征竟然和迭代器iterator同名，难不成。。。没错，它们就是有一腿。<strong>迭代器之所以成为迭代器，就是因为实现了<code>Iterator</code>特征</strong>，要实现该特征，最主要的就是实现其中的<code>next</code>方法，该方法控制如何从集合中取值，最终返回值的类型是<a href="https://course.rs/basic/trait/advance-trait#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B">关联类型</a><code>Item</code>.</p>
<p>因此，之前问题的答案已经很明显：<code>for</code>循环通过不停调用迭代器上的<code>next</code>方法，来获取迭代器中的元素。</p>
<p>既然<code>for</code>可以调用<code>next</code>方法，是不是意味着我们也可以？来试试:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let arr = [1, 2, 3];
    let mut arr_iter = arr.into_iter();

    assert_eq!(arr_iter.next(), Some(1));
    assert_eq!(arr_iter.next(), Some(2));
    assert_eq!(arr_iter.next(), Some(3));
    assert_eq!(arr_iter.next(), None);
}
</code></pre></pre>
<p>果不其然，将<code>arr</code>转换成迭代器后，通过调用其上的<code>next</code>方法，我们获取了<code>arr</code>中的元素, 有两点需要注意:</p>
<ul>
<li><code>next</code>方法返回的是<code>Option</code>类型，当有值时返回<code>Some(i32)</code>,无值时返回<code>None</code></li>
<li>遍历是按照迭代器中元素的排列顺序依次进行的，因此我们严格按照数组中元素的顺序取出了<code>Some(1)</code>,<code>Some(2)</code>,<code>Some(3)</code></li>
<li>手动迭代必须将迭代器声明为<code>mut</code>可变，因为调用<code>next</code>会改变迭代器其中的状态数据(当前遍历的位置等)，而<code>for</code>循环去迭代则无需标注<code>mut</code>，因为它会帮我们自动完成</li>
</ul>
<p>总之，<code>next</code>方法对<strong>迭代器的遍历是消耗性的</strong>，每次消耗它一个元素，最终迭代器中将没有任何元素, 只能返回<code>None</code>.</p>
<h4 id="例子模拟实现for循环"><a class="header" href="#例子模拟实现for循环">例子：模拟实现for循环</a></h4>
<p>因为for循环是迭代器的语法糖，因此我们完全可以通过迭代器来模拟实现它：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let values = vec![1, 2, 3];

{
    let result = match IntoIterator::into_iter(values) {
        mut iter =&gt; loop {
            match iter.next() {
                Some(x) =&gt; { println!(&quot;{}&quot;, x); },
                None =&gt; break,
            }
        },
    };
    result
}
<span class="boring">}
</span></code></pre></pre>
<p><code>IntoIterator::into_iter</code>是使用<a href="https://course.rs/basic/trait/advance-trait.html#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95">完全限定</a>的方式去调用<code>into_iter</code>方法，这种调用方式跟<code>values.into_iter()</code>是等价的。</p>
<p>同时我们使用了<code>loop</code>循环配合<code>next</code>方法来遍历迭代器中的元素，当迭代器返回<code>None</code>时，跳出循环。</p>
<h2 id="intoiterator特征"><a class="header" href="#intoiterator特征">IntoIterator特征</a></h2>
<p>其实有一个细节，由于<code>Vec</code>动态数组实现了<code>IntoIterator</code>特征，因此可以通过<code>into_iter</code>将其转换为迭代器，那如果本身就是一个迭代器，该怎么办？实际上，迭代器自身也实现了<code>IntoIterator</code>，标准库早就帮我们考虑好了:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;I: Iterator&gt; IntoIterator for I {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>最终你完全可以写出这样的奇怪代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let values = vec![1, 2, 3];

    for v in values.into_iter().into_iter().into_iter() {
        println!(&quot;{}&quot;,v)
    }
}
</code></pre></pre>
<h4 id="into_iter-iter-iter_mut"><a class="header" href="#into_iter-iter-iter_mut">into_iter, iter, iter_mut</a></h4>
<p>在之前的代码中，我们统一使用了<code>into_iter</code>的方式将数组转化为迭代器，除此之外，还有<code>iter</code>和<code>iter_mut</code>，聪明的读者应该大概能猜到这三者的区别：</p>
<ul>
<li><code>into_iter</code>会夺走所有权</li>
<li><code>iter</code>是借用</li>
<li><code>iter_mut</code>是可变借用</li>
</ul>
<p>其实如果以后见多识广了，你会发现这种问题一眼就能看穿，<code>into_</code>之类的，都是拿走所有权，<code>_mut</code>之类的都是可变借用，剩下的就是不可变借用。</p>
<p>使用一段代码来解释下:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let values = vec![1, 2, 3];

    for v in values.into_iter() {
        println!(&quot;{}&quot;, v)
    }

    // 下面的代码将报错，因为values的所有权在上面`for`循环中已经被转移走
    // println!(&quot;{:?}&quot;,values);

    let values = vec![1, 2, 3];
    let _values_iter = values.iter();

    // 不会报错，因为values_iter是借用了values中的元素
    println!(&quot;{:?}&quot;, values);

    let mut values = vec![1, 2, 3];
    // 对values中的元素进行可变借用
    let mut values_iter_mut = values.iter_mut();

    // 取出第一个元素，并修改为0
    if let Some(v) = values_iter_mut.next() {
        *v = 0;
    }

    // 输出[0, 2, 3]
    println!(&quot;{:?}&quot;, values);
}
</code></pre></pre>
<p>具体解释在代码注释中，就不再赘述,不过有两点需要注意的是：</p>
<ul>
<li><code>.iter()</code>方法实现的迭代器，调用<code>next</code>方法返回的类型是<code>Some(&amp;T)</code></li>
<li><code>.iter_mut()</code>方法实现的迭代器，调用<code>next</code>方法返回的类型是<code>Some(&amp;mut T)</code>, 因此在<code>if let Some(v) = values_iter_mut.next()</code>中，<code>v</code>的类型是<code>&amp;mut i32</code>，最终我们可以通过<code>*v = 0</code>的方式修改其值</li>
</ul>
<h4 id="iterator和intoiterator的区别"><a class="header" href="#iterator和intoiterator的区别">Iterator和IntoIterator的区别</a></h4>
<p>这两个其实还蛮容易搞混的，但我们只需要记住，<code>Iterator</code>就是迭代器特征，只有实现了它才能称为迭代器，才能调用<code>next</code>。</p>
<p>而<code>IntoIterator</code>强调的是某一个类型如果实现了该特征，它可以通过<code>into_iter</code>，<code>iter</code>等方法变成一个迭代器.</p>
<h2 id="消费者与适配器"><a class="header" href="#消费者与适配器">消费者与适配器</a></h2>
<p>消费者是迭代器上的方法，它会消费掉迭代器中的元素，然后返回其它类型的值，这些消费者都有一个共同的特点：在它们的定义中，都依赖<code>next</code>方法来消费元素，因此这也是为什么迭代器要实现<code>Iterator</code>特征，而该特征必须要实现<code>next</code>方法的原因。</p>
<h4 id="消费者适配器"><a class="header" href="#消费者适配器">消费者适配器</a></h4>
<p>只要迭代器上的某个方法<code>A</code>在其内部调用了<code>next</code>方法，那么<code>A</code>就被称为<strong>消费性适配器</strong>: 因为<code>next</code>方法会消耗掉迭代器上的元素，可以推出方法<code>A</code>的调用也会消耗掉迭代器上的元素。</p>
<p>其中一个例子是<code>sum</code>方法，它会拿走迭代器的所有权，然后通过不断调用<code>next</code>方法对里面的元素进行求和:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
    
    // v1_iter是借用了v1，因此v1可以照常使用
    println!(&quot;{:?}&quot;,v1);

    // 以下代码会报错，因为`sum`拿到了迭代器`v1_iter`的所有权
    // println!(&quot;{:?}&quot;,v1_iter);
}
</code></pre></pre>
<p>如代码注释中所说明的：在使用<code>sum</code>方法后，我们将无法再使用<code>v1_iter</code>，因为<code>sum</code>拿走了该迭代器的所有权:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum&lt;S&gt;(self) -&gt; S
    where
        Self: Sized,
        S: Sum&lt;Self::Item&gt;,
    {
        Sum::sum(self)
    }

<span class="boring">}
</span></code></pre></pre>
<p>从<code>sum</code>源码中也可以清晰看出，<code>self</code>类型的方法参数拿走了所有权。</p>
<h4 id="迭代器适配器"><a class="header" href="#迭代器适配器">迭代器适配器</a></h4>
<p>既然消费者适配器是消费掉迭代器，然后返回一个值。那么迭代器适配器，顾名思义，会返回一个新的迭代器，这是实现链式方法调用的关键:<code>v.iter().map().filter()...</code>。</p>
<p>与消费者适配器不同，迭代器适配器是惰性的，意味着你<strong>需要一个消费者适配器来收尾，最终将迭代器转换成一个具体的值</strong>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
<span class="boring">}
</span></code></pre></pre>
<p>运行后输出:</p>
<pre><code class="language-console">warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed // 迭代器map是惰性的，这里不产生任何效果
</code></pre>
<p>如上述中文注释所说，这里的<code>map</code>方法是一个迭代者适配器，它是惰性的，不产生任何行为，因此我们还需要一个消费者适配器进行收尾:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}
</span></code></pre></pre>
<h4 id="collect"><a class="header" href="#collect">collect</a></h4>
<p>上面代码中，使用了<code>collect</code>方法，该方法就是一个消费者适配器，使用它可以将一个迭代器中的元素收集到指定类型中，这里我们为<code>v2</code>标注了<code>Vec&lt;_&gt;</code>类型，就是为了告诉<code>collect</code>：请把迭代器中的元素消费掉，然后把值收集成<code>Vec&lt;_&gt;</code>类型，至于为何使用<code>_</code>，因为编译器会帮我们自动推导。</p>
<p>为何<code>collect</code>在消费时要指定类型？是因为该方法其实很强大，可以收集成多种不同的集合类型，<code>Vec&lt;T&gt;</code>仅仅是其中之一，因此我们必须显式的告诉编译器我们想要收集成的集合类型。</p>
<p>还有一点值得注意,<code>map</code>会对迭代器中的每一个值进行一系列操作，然后把该值转换成另外一个新值， 该操作是通过闭包<code>|x| x + 1</code>来完成: 最终迭代器中的每个值都增加了<code>1</code>，从<code>[1, 2, 3]</code>变为<code>[2, 3, 4]</code>.</p>
<p>再来看看如何使用<code>collect</code>收集成<code>HashMap</code>集合：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::HashMap;
fn main() {
    let names = [&quot;sunface&quot;, &quot;sunfei&quot;];
    let ages = [18, 18];
    let folks: HashMap&lt;_, _&gt; = names.into_iter().zip(ages.into_iter()).collect();

    println!(&quot;{:?}&quot;,folks);
}
</code></pre></pre>
<p><code>zip</code>是一个迭代器适配器，它的作用就是将两个迭代器的内容压缩到一起，形成<code>Iterator&lt;Item=(ValueFromA, ValueFromB)&gt;</code> 这样的新的迭代器,在此处就是形如<code>[(name1, age1), (name2, age2)]</code>的迭代器。</p>
<p>然后再通过<code>collect</code>将新迭代器中<code>(K, V)</code>形式的值收集成<code>HashMap&lt;K, V&gt;</code>，同样的，这里必须显式声明类型，然后<code>HashMap</code>内部的<code>KV</code>类型可以交给编译器去推导，最终编译器会推导出<code>HashMap&lt;&amp;str, i32&gt;</code>，完全正确！</p>
<h4 id="闭包作为适配器参数"><a class="header" href="#闭包作为适配器参数">闭包作为适配器参数</a></h4>
<p>之前的<code>map</code>方法中，我们使用闭包来作为迭代器适配器的参数，它最大的好处不仅在于就地实现迭代器中元素的处理，还在于可以捕获环境值:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}
<span class="boring">}
</span></code></pre></pre>
<p><code>filter</code>是迭代器适配器，用于对迭代器中的每个值进行过滤。 它使用闭包作为参数，该闭包的参数<code>s</code>是来自迭代器中的值，然后使用<code>s</code>跟外部环境中的<code>shoe_size</code>进行比较，若相等，则在迭代器中保留<code>s</code>值，若不相等，则从迭代器中剔除<code>s</code>值，最终通过<code>collect</code>收集为<code>Vec&lt;Shoe&gt;</code>类型.</p>
<h2 id="实现iterator特征"><a class="header" href="#实现iterator特征">实现Iterator特征</a></h2>
<p>之前的内容我们一直基于数组来创建迭代器，实际上，不仅仅是数组，基于其它集合类型一样可以创建迭代器，例如<code>HashMap</code>。 你也可以创建自己的迭代器 - 只要为自定义类型实现<code>Iterator</code>特征即可。</p>
<p>首先，创建一个计数器：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们为计数器<code>Counter</code>实现了一个关联函数<code>new</code>，用于创建新的计数器实例。下面们继续为计数器实现<code>Iterator</code>特征：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.count &lt; 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>首先，将该特征的关联类型设置为<code>u32</code>，由于我们的计数器保存的<code>count</code>字段就是<code>u32</code>类型， 因此在<code>next</code>方法中，最后返回的是实际上是<code>Option&lt;u32&gt;</code>类型.</p>
<p>每次调用<code>next</code>方法，都会让计数器的值加一，然后返回最新的计数值，一旦计数大于5，就返回<code>None</code>。</p>
<p>最后，使用我们新建的<code>Counter</code>进行迭代：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let mut counter = Counter::new();

assert_eq!(counter.next(), Some(1));
assert_eq!(counter.next(), Some(2));
assert_eq!(counter.next(), Some(3));
assert_eq!(counter.next(), Some(4));
assert_eq!(counter.next(), Some(5));
assert_eq!(counter.next(), None);
<span class="boring">}
</span></code></pre></pre>
<h4 id="实现iterator特征的其它方法"><a class="header" href="#实现iterator特征的其它方法">实现Iterator特征的其它方法</a></h4>
<p>可以看出，实现自己的迭代器非常简单，但是<code>Iterator</code>特征中，不仅仅是只有<code>next</code>一个方法，那为什么我们只需要实现它呢？因为其它方法都具有<a href="https://course.rs/basic/trait/trait.html#%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0">默认实现</a>，无需像<code>next</code>这样手动去实现，而且这些默认实现的方法其实都是基于<code>next</code>方法实现的。</p>
<p>下面的代码演示了部分方法的使用：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sum: u32 = Counter::new()
    .zip(Counter::new().skip(1))
    .map(|(a, b)| a * b)
    .filter(|x| x % 3 == 0)
    .sum();
assert_eq!(18, sum);
<span class="boring">}
</span></code></pre></pre>
<p>其中<code>zip</code>, <code>map</code>, <code>filter</code>是迭代器适配器：</p>
<ul>
<li><code>zip</code>把两个迭代器合并成一个迭代器，新迭代器中，每个元素都是一个元组，由之前两个迭代器的元素组成。例如将<strong>形如</strong><code>[1, 2, 3]</code>和<code>[4, 5, 6]</code>的迭代器合并后，新的迭代器形如<code>[(1, 4),(2, 5),(3, 6)]</code></li>
<li><code>map</code>是将迭代器中的值经过映射后，转换成新的值</li>
<li><code>filter</code>对迭代器中的元素进行过滤，若闭包返回<code>true</code>则保留元素，反之剔除</li>
</ul>
<p>而<code>sum</code>是消费者适配器，对迭代器中的所有元素求和，最终返回一个<code>u32</code>值<code>18</code>。</p>
<h5 id="enumerate"><a class="header" href="#enumerate">enumerate</a></h5>
<p>在之前的流程控制章节，针对<code>for</code>循环，我们提供了一种方法可以获取迭代时的索引:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1u64, 2, 3, 4, 5, 6];
for (i,v) in v.iter().enumerate() {
    println!(&quot;第{}个值是{}&quot;,i,v)
}
<span class="boring">}
</span></code></pre></pre>
<p>相信当时，很多读者还是很迷茫的，不知道为什么要这么复杂才能获取到索引，学习本章节后，相信你有了全新的理解，首先<code>v.iter()</code>创建迭代器，其次
调用<code>Iterator</code>特征上的方法<code>enumerate</code>，该方法产生一个新的迭代器，其中每个元素均是元组<code>(索引，值)</code>。</p>
<p>因为<code>enumerate</code>是迭代器适配器，因此我们可以对它返回的迭代器调用其它<code>Iterator</code>特征方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1u64, 2, 3, 4, 5, 6];
let val = v.iter()
    .enumerate()
    // 每两个元素剔除一个
    // [1, 3, 5]
    .filter(|&amp;(idx, _)| idx % 2 == 0)
    .map(|(idx, val)| val)
    // 累加 1+3+5 = 9
    .fold(0u64, |sum, acm| sum + acm);

println!(&quot;{}&quot;, val);
<span class="boring">}
</span></code></pre></pre>
<h2 id="迭代器的性能"><a class="header" href="#迭代器的性能">迭代器的性能</a></h2>
<p>前面提到，要完成集合遍历，既可以使用for循环也可以使用迭代器，那么二者之间该怎么选择呢，性能有多大差距呢？</p>
<p>理论分析不会有结果，直接测试最为靠谱：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span>#![feature(test)]

<span class="boring">fn main() {
</span>extern crate rand;
extern crate test;

fn sum_for(x: &amp;[f64]) -&gt; f64 {
    let mut result: f64 = 0.0;
    for i in 0..x.len() {
        result += x[i];
    }
    result
}

fn sum_iter(x: &amp;[f64]) -&gt; f64 {
    x.iter().sum::&lt;f64&gt;()
}

#[cfg(test)]
mod bench {
    use test::Bencher;
    use rand::{Rng,thread_rng};
    use super::*;

    const LEN: usize = 1024*1024;

    fn rand_array(cnt: u32) -&gt; Vec&lt;f64&gt; {
        let mut rng = thread_rng();
        (0..cnt).map(|_| rng.gen::&lt;f64&gt;()).collect()
    }

    #[bench]
    fn bench_for(b: &amp;mut Bencher) {
        let samples = rand_array(LEN as u32);
        b.iter(|| {
            sum_for(&amp;samples)
        })
    }

    #[bench]
    fn bench_iter(b: &amp;mut Bencher) {
        let samples = rand_array(LEN as u32);
        b.iter(|| {
            sum_iter(&amp;samples)
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面的代码对比了for循环和迭代器iterator完成同样的求和任务的性能对比，可以看到迭代器还要更快一点。</p>
<pre><code class="language-console">test bench::bench_for  ... bench:     998,331 ns/iter (+/- 36,250)
test bench::bench_iter ... bench:     983,858 ns/iter (+/- 44,673)
</code></pre>
<p>迭代器是 Rust 的 <strong>零成本抽象</strong>（zero-cost abstractions）之一，意味着抽象并不会引入运行时开销，这与 <code>Bjarne Stroustrup</code>（C++ 的设计和实现者）在 <code>Foundations of C++（2012）</code> 中所定义的 <strong>零开销</strong>（zero-overhead）如出一辙：</p>
<pre><code>In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for.
And further: What you do use, you couldn’t hand code any better.

一般来说，C++的实现遵循零开销原则：没有使用时，你不必为其买单。
更进一步说，需要使用时，你也无法写出更优的代码了。
（翻译一下：用就完事了）
</code></pre>
<p>总之，迭代器是 Rust 受函数式语言启发而提供的高级语言特性，可以写出更加简洁、逻辑清晰的代码。编译器还可以通过循环展开（Unrolling）、向量化、消除边界检查等优化手段，使得迭代器和for循环都有极为高效的执行效率。</p>
<p>所以请放心大胆的使用迭代器，在获得更高的表达力的同时，也不会导致运行时的损失，何乐而不为呢！</p>
<h2 id="学习其它方法"><a class="header" href="#学习其它方法">学习其它方法</a></h2>
<p>迭代器用的好不好，就在于你是否掌握了它的常用方法，且能活学活用，因此多多看看<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">标准库</a>是有好处的，只有知道有什么方法，在需要的时候你才能知道该用什么，就和算法学习一样。</p>
<p>同时，本书在后续章节还提供了对迭代器常用方法的<a href="https://course.rs/std/iterator">深入讲解</a>，方便大家学习和查阅。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包和模块"><a class="header" href="#包和模块">包和模块</a></h1>
<p>当工程规模变大时，把代码写到一个甚至几个文件中，都是不太聪明的做法，可能存在以下问题：</p>
<ol>
<li>单个文件过大，导致打开、翻页速度大幅变慢</li>
<li>查询和定位效率大幅降低，类比下，你会把所有知识内容放在一个几十万字的文档中吗？</li>
<li>只有一个代码层次：函数，难以维护和协作，想象一下你的操作系统只有一个根目录，剩下的都是单层子目录会如何: <code>disaster</code></li>
<li>容易滋生Bug</li>
</ol>
<p>同时，将大的代码文件拆分成包和模块，还允许我们实现代码抽象和复用：将你的代码封装好后提供给用户，那么用户只需要调用公共接口即可，无需知道内部该如何实现。</p>
<p>因此，跟其它语言一样，Rust也提供了相应概念用于代码的组织管理:</p>
<ul>
<li>Packages: 一个<code>Cargo</code>提供的feature，可以用来构建、测试和分享包</li>
<li>包Crate: 一个由多个模块组成的树形结构，可以作为三方库进行分发，也可以生成可执行文件进行运行</li>
<li>模块：可以一个文件多个模块，也可以一个文件一个模块，模块可以被认为是真实项目中的代码组织单元</li>
</ul>
<p>下面，让我们一一来学习这些概念以及如何在实践中运用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包和package"><a class="header" href="#包和package">包和Package</a></h1>
<p>当读者按照章节顺序读到本章时，意味着你已经几乎具备了参与真实项目开发的能力。但是真实项目远比我们之前的<code>cargo new</code>的默认目录结构要复杂，好在，Rust为我们提供了强大的包管理工具：</p>
<ul>
<li><strong>Package</strong>: 可以用来构建、测试和分享包</li>
<li><strong>工作空间workspace</strong>: 对于大型项目，可以进一步将多个包联合在一起，组织成工作空间</li>
<li><strong>包Crate</strong>: 一个由多个模块组成的树形结构，可以作为三方库进行分发，也可以生成可执行文件进行运行</li>
<li><strong>模块Module</strong>：可以一个文件多个模块，也可以一个文件一个模块，模块可以被认为是真实项目中的代码组织单元</li>
</ul>
<h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<p>其实<code>Package</code>和包很容易被搞混，甚至在很多书中，这两者都是不分的，但是由于官方对此做了明确的区分，因此我们会在本章节中试图(挣扎着)理清这个概念.</p>
<h4 id="包crate"><a class="header" href="#包crate">包crate</a></h4>
<p>对于Rust而言，包是一个独立的可编译单元，它编译后会生成一个可执行文件或者一个库。</p>
<p>一个包会将相关联的功能打包在一起，使得该功能可以很方便的在多个项目中分享。例如标准库中没有提供但是在三方库中提供的<code>rand</code>包，它提供了随机数生成的功能，我们只需要将该包通过<code>use rand;</code>引入到当前项目的作用域中，就可以在项目中使用<code>rand</code>的功能: <code>rand::XXX</code>。</p>
<p>同一个包中不能有同名的类型，但是在不同包中就可以。例如，虽然<code>rand</code>包中，有一个<code>Rng</code>特征，可是我们依然可以在自己的项目中定义一个<code>Rng</code>，前者通过<code>rand::Rng</code>访问，后者通过<code>Rng</code>访问，对于编译器而言，这两者的边界非常清晰，不会存在引用歧义。</p>
<h2 id="package"><a class="header" href="#package">Package</a></h2>
<p>鉴于Rust团队标新立异的起名传统，以及包的名称被<code>crate</code>占用，库的名称被<code>library</code>占用，因此导致我不知道该如何准确的翻译<code>Package</code>，遂决定，不翻译，但是大家可以把它理解为一个项目工程，或者一个微服务工程。</p>
<p>由于<code>Package</code>就是一个项目，因此它包含有独立的<code>Cargo.toml</code>文件, 以及因为功能性被组织在一起的一个或多个包。一个<code>package</code>只能包含<strong>一个</strong>库(library)类型的包, 但是可以包含<strong>多个</strong>二进制可执行类型的包。</p>
<h4 id="二进制package"><a class="header" href="#二进制package">二进制package</a></h4>
<p>让我们来创建一个二进制<code>package</code>:</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>这里，Cargo为我们创建了一个名称是<code>my-project</code>的<code>package</code>, 同时在其中创建了<code>Cargo.toml</code>文件，可以看一下该文件，里面并没有提到<code>src/main.rs</code>作为程序的入口, 原因是Cargo有一个惯例：<strong>src/main.rs是二进制包的根文件，该二进制包的包名跟所属package相同，在这里都是my-project</strong>, 所有的代码执行都从该文件中的<code>fn main()</code>函数开始。</p>
<p>使用<code>cargo run</code>可以运行该项目，输出:<code>Hello, world!</code>.</p>
<h4 id="库package"><a class="header" href="#库package">库package</a></h4>
<p>再来创建一个库类型的<code>package</code>:</p>
<pre><code class="language-console">$ cargo new my-test --lib
     Created library `my-lib` package
$ ls my-lib
Cargo.toml
src
$ ls my-lib/src
lib.rs
</code></pre>
<p>首先，如果你试图运行<code>my-test</code>，会报错：</p>
<pre><code class="language-console">$ cargo run
error: a bin target must be available for `cargo run`
</code></pre>
<p>原因是库类型的<code>package</code>只能作为三方库被其它项目引用，而不能独立运行，只有之前的二进制<code>package</code>才可以运行。</p>
<p>与<code>src/main.rs</code>一样，Cargo知道，如果一个<code>package</code>包含有<code>src/lib.rs</code>，意味它包含有一个库类型的同名包<code>my-lib</code>，该包的根文件是<code>src/lib.rs</code></p>
<h4 id="易混淆的package和包"><a class="header" href="#易混淆的package和包">易混淆的package和包</a></h4>
<p>看完上面，相信大家看出来为何<code>package</code>和包容易被混淆了吧？因为你用<code>cargo new</code>创建的<code>package</code>和它其中包含的包是同名的！</p>
<p>不过，只要你牢记<code>package</code>是一个项目工程，而包只是一个编译单元，基本上也就不会混淆这个两个概念了: <code>src/main.rs</code>和<code>src/lib.rs</code>都是编译单元，因此它们都是包。</p>
<h4 id="典型的package结构"><a class="header" href="#典型的package结构">典型的<code>package</code>结构</a></h4>
<p>上面创建的<code>package</code>中仅包含<code>src/main.rs</code>文件，意味着它仅包含一个二进制同名包<code>my-project</code>。如果一个<code>package</code>同时拥有<code>src/main.rs</code>和<code>src/lib.rs</code>，那就意味着它包含两个包：库包和二进制包，这两个包名也都是<code>my-project</code> —— 都与<code>package</code>同名。</p>
<p>一个真实项目中典型的<code>package</code>，会包含多个二进制包，这些包文件被放在<code>src/bin</code>目录下，每一个文件都是独立的二进制包，同时也会包含一个库包，该包只能存在一个<code>src/lib.rs</code>：</p>
<pre><code class="language-css">.
├── Cargo.toml
├── Cargo.lock
├── src
│   ├── main.rs
│   ├── lib.rs
│   └── bin
│       └── main1.rs
│       └── main2.rs
├── tests
│   └── some_integration_tests.rs
├── benches
│   └── simple_bench.rs
└── examples
    └── simple_example.rs
</code></pre>
<ul>
<li>唯一库包, <code>src/lib.rs</code></li>
<li>默认二进制包， <code>src/main.rs</code>，编译后生成的可执行文件与<code>package</code>同名</li>
<li>其余二进制包，<code>src/bin/main1.rs</code>和<code>src/bin/main2.rs</code>，它们会分别生成一个文件同名的二进制可执行文件</li>
<li>集成测试文件：<code>tests</code>目录下</li>
<li>性能测试benchmark文件: <code>benches</code>目录下</li>
<li>项目示例: <code>examples</code>目录下</li>
</ul>
<p>这种目录结构基本上是Rust的标准目录结构，在<code>github</code>的大多数项目上，你都将看到它的身影。</p>
<p>理解了包的概念，我们再来看看构成包的基本单元：模块。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块module"><a class="header" href="#模块module">模块Module</a></h1>
<p>在本章节，我们将深入讲讲Rust的代码构成单元：模块。使用模块可以将包中的代码按照功能性进行重组，最终实现更好的可读性及易用性。同时，我们还能非常灵活地去控制代码的可见性，进一步强化了Rust的安全性。</p>
<h2 id="创建嵌套模块"><a class="header" href="#创建嵌套模块">创建嵌套模块</a></h2>
<p>小旅馆，sorry，是小餐馆，相信大家都挺熟悉的，学校外的估计也没少去，那么咱就用小餐馆为例，看看Rust的模块该如何使用。</p>
<p>使用<code>cargo new --lib restaurant</code>创建一个小餐馆，注意，这里创建的是一个库类型的<code>package</code>, 然后将以下代码放入<code>src/lib.rs</code>中：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 餐厅前厅，用于吃饭
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>以上的代码创建了三个模块，有几点需要注意的：</p>
<ul>
<li>使用<code>mod</code>关键字来创建新模块，后面紧跟着模块名称</li>
<li>模块可以嵌套，这里嵌套的原因是招待客人和服务都发生在前厅，因此我们的代码模拟了真实场景</li>
<li>模块中可以定义各种Rust类型，例如函数、结构体、枚举、特征等</li>
<li>所有模块均定义在同一个文件中</li>
</ul>
<p>类似上述代码中所做的，使用模块，我们就能将功能相关的代码组织到一起，然后通过一个模块名称来说明这些代码为何被组织在一起。这样其它程序员在使用你的模块时，就可以更快的理解和上手。</p>
<h2 id="模块树"><a class="header" href="#模块树">模块树</a></h2>
<p>在<a href="advance/crate-module/./crate.html">上一节</a>中，我们提到过<code>src/main.rs</code>和<code>src/lib.rs</code>被称为包根(crate root)，这个奇葩名称的来源(我不想承认是自己翻译水平太烂- , -)是由于这两个文件的内容形成了一个模块<code>crate</code>，该模块位于包的树形结构(由模块组成的树形结构)的根部:</p>
<pre><code class="language-console">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p>这颗树展示了模块之间<strong>彼此的嵌套</strong>关系，因此被称为<strong>模块树</strong>。其中<code>crate</code>包根是<code>src/lib.rs</code>文件，包根文件中的三个模块分别形成了模块树的剩余部分。</p>
<h4 id="父子模块"><a class="header" href="#父子模块">父子模块</a></h4>
<p>如果模块<code>A</code>包含模块<code>B</code>，那么<code>A</code>是<code>B</code>的父模块，<code>B</code>是<code>A</code>的子模块。在上例中，<code>front_of_house</code>是<code>hosting</code>和<code>serving</code>的父模块，反之，后两者是前者的子模块。</p>
<p>聪明的读者，应该能联想到，模块树跟计算机上文件系统目录树的相似之处。不仅仅是组织结构上的相似，就连使用方式都很相似：每个文件都有自己的路径，用户可以通过这些路径使用它们，在Rust中，我们也通过路径的方式来引用模块。</p>
<h2 id="用路径引用模块"><a class="header" href="#用路径引用模块">用路径引用模块</a></h2>
<p>想要调用一个函数，就需要知道它的路径，在Rust中，这种路径有两种形式：</p>
<ul>
<li><strong>绝对路径</strong>, 从包根开始，路径名以包名或者<code>crate</code>作为开头</li>
<li><strong>相对路径</strong>, 从当前模块开始，以<code>self</code>,<code>super</code>或当前模块的标识符作为开头</li>
</ul>
<p>让我们继续经营那个惨淡的小餐馆，这次为它实现一个小功能:
<span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // 绝对路径
    crate::front_of_house::hosting::add_to_waitlist();

    // 相对路径
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p>上面的代码为了简化实现，省去了其余模块和函数，这样可以把关注点放在函数调用上。<code>eat_at_restaurant</code>是一个定义在包根中的函数,在该函数中使用了两种方式对<code>add_to_waitlist</code>进行调用。</p>
<h4 id="绝对路径引用"><a class="header" href="#绝对路径引用">绝对路径引用</a></h4>
<p>因为<code>eat_at_restaurant</code>和<code>add_to_waitlist</code>都定义在一个包中，因此在绝对路径引用时，可以直接以<code>crate</code>开头，然后逐层引用，每一层之间使用<code>::</code>分隔:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>crate::front_of_house::hosting::add_to_waitlist();
<span class="boring">}
</span></code></pre></pre>
<p>对比下之前的模块树：</p>
<pre><code class="language-console">crate
 └── eat_at_restaurant
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p>可以看出，绝对路径的调用，完全符合了模块树的层级递进，非常符合直觉，如果类比文件系统，就跟使用绝对路径调用可执行程序差不多：<code>/front_of_house/hosting/add_to_waitlist</code>, 使用<code>crate</code>作为开始就和使用<code>/</code>作为开始一样。</p>
<h4 id="相对路径引用"><a class="header" href="#相对路径引用">相对路径引用</a></h4>
<p>再回到模块树中，因为<code>eat_at_restaurant</code>和<code>front_of_house</code>都处于包根<code>crate</code>中，因此相对路径可以使用<code>front_of_house</code>作为开头:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>front_of_house::hosting::add_to_waitlist();
<span class="boring">}
</span></code></pre></pre>
<p>如果类比文件系统，那么它类似于调用同一个目录下的程序，你可以这么做: <code>front_of_house/hosting/add_to_waitlist</code>, 嗯也很符合直觉。</p>
<h4 id="绝对还是相对"><a class="header" href="#绝对还是相对">绝对还是相对?</a></h4>
<p>如果只是为了引用到指定模块中的对象，那么两种都可以，但是在实际使用时，需要遵循一个原则：<strong>当代码被挪动位置时，尽量减少引用路径的修改</strong>，相信大家都遇到过，修改了某处代码，导致所有路径都要挨个替换，这显然不是好的路径选择。</p>
<p>回到之前的例子， 如果我们把<code>front_of_house</code>模块和<code>eat_at_restaurant</code>移动到一个模块中<code>customer_experience</code>, 那么绝对路径的引用方式就必须进行修改:<code>crate::customer_experience::front_of_house ...</code>, 但是假设我们使用的相对路径，那么该路径就无需修改，因为它们两的相对位置其实没有变：</p>
<pre><code class="language-console">crate
 └── customer_experience
    └── eat_at_restaurant
    └── front_of_house
        ├── hosting
        │   ├── add_to_waitlist
        │   └── seat_at_table
</code></pre>
<p>从新的模块树中可以很清晰的看出这一点。</p>
<p>再比如，其它的都不动，把<code>eat_at_restaurant</code>移动到模块<code>dining</code>中，如果使用相对路径，你需要修改该路径，但如果使用的是绝对路径，就无需修改：</p>
<pre><code class="language-console">crate
 └── dining
     └── eat_at_restaurant
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
</code></pre>
<p>不过，如果不确定哪个好，你可以考虑优先使用绝对路径，因为调用的地方和定义的地方往往是分离的，而定义的地方较少会变动。</p>
<h2 id="代码可见性"><a class="header" href="#代码可见性">代码可见性</a></h2>
<p>让我们运行下面(之前)的代码:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // 绝对路径
    crate::front_of_house::hosting::add_to_waitlist();

    // 相对路径
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p>意料之外的报错了，毕竟看上去确实很简单且没有任何问题:</p>
<pre><code class="language-console">error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ private module
</code></pre>
<p>错误信息很清晰：<code>hosting</code>模块是私有的，无法在包根进行访问，那么为何<code>front_of_house</code>模块就可以访问？因为它和<code>eat_at_restaurant</code>同属于一个包根作用域内，同一个模块内的代码自然不存在私有化问题(所以我们之前章节的代码都没有报过这个错误!)。</p>
<p>模块不仅仅对于组织代码很有用，它还能定义代码的私有化边界：在这个边界内，什么内容能让外界看到，什么内容不能，都有很明确的定义。因此，如果希望让函数或者结构体等类型变成私有化的，可以使用模块。</p>
<p>Rust出于安全的考虑，默认情况下，所有的类型都是私有化的，包括函数、方法、结构体、枚举、常量，是的，就连模块本身也是私有化的。在中国，父亲往往不希望孩子拥有小秘密，但是在Rust中，<strong>父模块完全无法访问子模块中的私有项，但是子模块却可以访问父模块、父父..模块的私有项</strong>。</p>
<h4 id="pub关键字"><a class="header" href="#pub关键字">pub关键字</a></h4>
<p>类似其它语言的<code>public</code>或者Go语言中的首字母大写，Rust提供了<code>pub</code>关键字，通过它你可以控制模块和模块中指定项的可见性。</p>
<p>由于之前的解释，我们知道了只需要将<code>hosting</code>模块标记为对外可见即可:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

/*--- snip ----*/
<span class="boring">}
</span></code></pre></pre>
<p>但是不幸的是，又报错了：</p>
<pre><code class="language-console">error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
</code></pre>
<p>哦？ 难道模块可见还不够，还需要将函数<code>add_to_waitlist</code>标记为可见的吗？ 是的，没错，模块可见性不代表模块内部项的可见性，模块的可见性仅仅是允许其它模块去引用它，但是想要引用它内部的项，还得继续将对应的项标记为<code>pub</code>。 </p>
<p>在实际项目中，一个模块需要对外暴露的数据和API往往就寥寥数个，如果将模块标记为可见代表着内部项也全部对外可见，那你是不是还得把那些不可见的，一个一个标记为<code>private</code>? 反而更是麻烦的多。</p>
<p>既然知道了如何解决，那么我们为函数也标记上<code>pub</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

/*--- snip ----*/
<span class="boring">}
</span></code></pre></pre>
<p>Bang, 顺利通过编译，感觉自己又变强了。</p>
<h2 id="使用super引用模块"><a class="header" href="#使用super引用模块">使用<code>super</code>引用模块</a></h2>
<p>在<a href="advance/crate-module/module.html#%E7%94%A8%E8%B7%AF%E5%BE%84%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97">用路径引用模块</a>中，我们提到了相对路径有三种方式开始：<code>self</code>、<code>super</code>和<code>crate</code>或者模块名，其中第三种在前面已经讲到过，现在来看看通过<code>super</code>的方式引用模块项。</p>
<p><code>super</code>代表的是父模块为开始的引用方式，非常类似于文件系统中的<code>..</code>语法: <code>../a/b</code>：
<span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn serve_order() {}

// 厨房模块
mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
<span class="boring">}
</span></code></pre></pre>
<p>嗯，我们的小餐馆又完善了，终于有厨房了! 看来第一个客人也快可以有了。。。在厨房模块中，使用<code>super::serve_order</code>语法，调用了父模块(包根)中的<code>serve_order</code>函数。</p>
<p>那么你可能会问，为何不使用<code>crate::serve_order</code>的方式？额，其实也可以，不过如果你确定未来这种层级关系不会改变，那么<code>super::serve_order</code>的方式会更稳定，未来就算它们都不在包根了，依然无需修改引用路径。所以路径的选用，往往还是取决于场景，以及未来代码的可能走向。</p>
<h2 id="使用self引用模块"><a class="header" href="#使用self引用模块">使用<code>self</code>引用模块</a></h2>
<p><code>self</code>其实就是引用自身模块中的项，也就是说和我们之前章节的代码类似，都调用同一模块中的内容，区别在于之间章节中直接通过名称调用即可，而<code>self</code>，你得多此一举：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn serve_order() {
    self::back_of_house
}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        crate::serve_order();
    }

    fn cook_order() {}
}
<span class="boring">}
</span></code></pre></pre>
<p>是的，多此一举，因为完全可以直接调用<code>back_of_house</code>，但是<code>self</code>还有一个大用处，在下一节中我们会讲。</p>
<h2 id="结构体和枚举的可见性"><a class="header" href="#结构体和枚举的可见性">结构体和枚举的可见性</a></h2>
<p>为何要把结构体和枚举的可见性单独拎出来讲呢？因为这两个家伙的成员字段拥有完全不同的可见性：</p>
<ul>
<li>将结构体设置为<code>pub</code>，但它的所有字段依然是私有的</li>
<li>将枚举设置为<code>pub</code>，它的所有字段也将对外可见</li>
</ul>
<p>原因在于，枚举和结构体的使用方式不一样。如果枚举的成员对外不可见，那该枚举将一点用都没有，因此枚举成员的可见性自动跟枚举可见性保持一致，这样可以简化用户的使用。</p>
<p>而结构体的应用场景比较复杂，其中的字段也往往部分在A处被使用，部分在B处被使用，因此无法确定成员的可见性，那索性就设置为全部不可见，将选择权交给程序员。</p>
<h2 id="模块与文件分离"><a class="header" href="#模块与文件分离">模块与文件分离</a></h2>
<p>在之前的例子中，我们所有的模块都定义在<code>src/lib.rs</code>中，但是当模块变多或者变大时，需要将模块放入一个单独的文件中，让代码更好维护。</p>
<p>现在，把<code>front_of_house</code>前厅分离出来，放入一个单独的文件中<code>src/front_of_house.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod hosting {
    pub fn add_to_waitlist() {}
}
<span class="boring">}
</span></code></pre></pre>
<p>然后，将以下代码留在<code>src/lib.rs</code>中：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p>so easy! 其实跟之前在同一个文件中也米有太大的不同，但是有几点值得注意：</p>
<ul>
<li><code>mod front_of_house;</code>告诉Rust从另一个和模块<code>front_of_house</code>同名的文件中加载该模块的内容</li>
<li>使用绝对路径的方式来引用<code>hosting</code>模块: <code>crate::front_of_house::hosting;</code></li>
</ul>
<p>需要注意的是，和之前代码中<code>mod front_of_house{..}</code>的完整模块不同，现在的代码中，模块的声明和实现是分离的，实现是在单独的<code>front_of_house.rs</code>文件中，然后通过<code>mod front_of_house;</code>这条声明语句从该文件中把模块内容加载进来。因此我们可以认为，模块<code>front_of_house</code>的定义还是在<code>src/lib.rs</code>中，只不过模块的具体内容被移动到了<code>src/front_of_house.rs</code>文件中。</p>
<p>在这里出现了一个新的关键字<code>use</code>，联想到其它章节我们见过的标准库引入<code>use std::fmt;</code>， 可以大致猜测，该关键字用来将外部模块中的项引入到当前作用域中来，这样无需冗长的父模块前缀即可调用: <code>hosting::add_to_waitlist();</code>，在下节中，我们将对<code>use</code>进行详细的讲解。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用use及受限可见性"><a class="header" href="#使用use及受限可见性">使用use及受限可见性</a></h1>
<p>如果代码中，通篇都是<code>crate::front_of_house::hosting::add_to_waitlist</code>这样的函数调用形式，我不知道有谁会喜欢，也许靠代码行数赚工资的人会很喜欢，反正强迫症肯定受不了，而且悲伤的是程序员大多都有强迫症。。。</p>
<p>因此我们需要一个办法来简化这种使用方式，在Rust中，可以使用<code>use</code>关键字把路径提前引入到当前作用域中，随后的调用就可以省略该路径，极大的简化了代码。</p>
<h2 id="基本引入方式"><a class="header" href="#基本引入方式">基本引入方式</a></h2>
<p>在Rust中，引入模块中的项有两种方式：<a href="advance/crate-module/./module.html#%E7%94%A8%E8%B7%AF%E5%BE%84%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97">绝对路径和相对路径</a>,这两者在前面章节都有讲过，就不再赘述，先来看看使用绝对路径的引入方式。</p>
<h4 id="绝对路径引入模块"><a class="header" href="#绝对路径引入模块">绝对路径引入模块</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p>这里，我们使用<code>use</code>和绝对路径的方式，将<code>hosting</code>模块引入到当前作用域中，然后只需通过<code>hosting::add_to_waitlist</code>的方式，即可调用目标模块中的函数，相比<code>crate::front_of_house::hosting::add_to_waitlist()</code>的方式要简单的多，那么还能更简单吗？</p>
<h4 id="相对路径引入模块中的函数"><a class="header" href="#相对路径引入模块中的函数">相对路径引入模块中的函数</a></h4>
<p>在下面代码中，我们不仅要使用相对路径进行引入，而且与上面引入<code>hosting</code>模块不同，直接引入该模块中的<code>add_to_waitlist</code>函数:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p>很明显，三兄弟又变得更短了，不过，怎么觉得这句话怪怪的。。</p>
<h4 id="引入模块还是函数"><a class="header" href="#引入模块还是函数">引入模块还是函数</a></h4>
<p>从使用简洁性来说，引入函数自然是更甚一筹，但是在某些时候，引入模块会更好：</p>
<ul>
<li>需要引入同一个模块的多个函数</li>
<li>作用域中存在同名函数</li>
</ul>
<p>在以上两种情况中, 使用<code>use front_of_house::hosting</code>引入模块要比<code>use front_of_house::hosting::add_to_waitlist;</code>引入函数更好。</p>
<p>例如，如果想使用<code>HashMap</code>，那么直接引入该结构体是比引入模块更好的选择，因为在<code>collections</code>模块中，我们只需要使用一个<code>HashMap</code>结构体：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<p>其实严格来说，对于引用方式并没有需要遵守的惯例，主要还是取决于你的喜好，不过我们建议：<strong>优先使用最细粒度(引入函数、结构体等)的引用方式，如果引起了某种麻烦(例如前面两种情况)，再使用引入模块的方式</strong>。</p>
<h2 id="避免同名引用"><a class="header" href="#避免同名引用">避免同名引用</a></h2>
<p>根据上一章节的内容，我们只要保证同一个模块中不存在同名项就行，模块之间、包之间的同名，谁管的着谁啊，话虽如此，一起看看，如果遇到同名的情况该如何处理.</p>
<h4 id="模块函数"><a class="header" href="#模块函数">模块::函数</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p>上面的例子给出了很好的解决方案，使用模块引入的方式，具体的<code>Result</code>通过<code>模块::Result</code>的方式进行调用。</p>
<p>可以看出，避免同名冲突的关键，就是使用<strong>父模块的方式来调用</strong>，除此之外，还可以给予引入的项一个新的名称。</p>
<h4 id="as别名引用"><a class="header" href="#as别名引用"><code>as</code>别名引用</a></h4>
<p>对于同名冲突问题，还可以使用<code>as</code>关键字来解决。它可以赋予引入项一个全新的名称：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p>如上所示，首先通过<code>use std::io::Result</code>将<code>Result</code>引入到作用域，然后使用<code>as</code>给予它一个全新的名称<code>IoResult</code>，这样就不会再产生冲突:</p>
<ul>
<li><code>Result</code>代表<code>std::fmt::Result</code></li>
<li><code>IoResult</code>代表<code>std:io::Result</code></li>
</ul>
<h2 id="引入项再导出"><a class="header" href="#引入项再导出">引入项再导出</a></h2>
<p>当外部的模块项<code>A</code>被引入到当前模块中时，它的可见性自动被设置为私有的，如果你允许其它外部代码引入我们模块中的<code>A</code>，那么可以对它进行再导出:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p>如上，使用<code>pub use</code>即可实现。这里<code>use</code>代表引入<code>hosting</code>模块到当前作用域，<code>pub</code>表示将该引入的内容再度设置为可见。</p>
<p>当你希望将内部的实现细节隐藏起来或者按照某个目的组织代码时，可以使用<code>pub use</code>再导出，例如统一使用一个模块来提供对外的API，那该模块就可以引入其它模块中的API，然后进行再导出，最终对于用户来说，所有的API都是由一个模块统一提供的。</p>
<h2 id="使用三方包"><a class="header" href="#使用三方包">使用三方包</a></h2>
<p>之前我们一直在引入标准库模块或者自定义模块，现在来引入下三方包中的模块，关于如何引入外部依赖，我们在<a href="advance/crate-module/../../first-try/cargo.html#package%E9%85%8D%E7%BD%AE%E6%AE%B5%E8%90%BD">Cargo入门</a>中就有讲，这里直接给出操作步骤:</p>
<ol>
<li>修改Cargo.toml文件，在<code>[dependencies]</code>区域添加一行: <code>rand = &quot;0.8.3&quot;</code></li>
<li>此时，如果你用的是<code>VSCode</code>和<code>rust-analyzer</code>插件，该插件会自动拉取该库，你可能需要等它完成后，再进行下一步(VSCODE左下角有提示)</li>
</ol>
<p>好了，此时，<code>rand</code>包已经被我们添加到依赖中，下一步就是在代码中使用：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..101);
}
</code></pre></pre>
<p>这里使用<code>use</code>引入了三方包<code>rand</code>中的<code>Rng</code>特征，因为我们需要调用的<code>gen_range</code>方法定义在该特征中。</p>
<h4 id="cratesio-librs"><a class="header" href="#cratesio-librs">crates.io, lib.rs</a></h4>
<p>Rust社区已经为我们贡献了大量高质量的三方包，你可以在<code>crates.io</code>或者<code>lib.rs</code>中检索和使用，从目前来说查找包更推荐<code>lib.rs</code>，搜索功能更强大，内容展示也更加合理, 但是下载依赖包还是得用<code>crates.io</code>。</p>
<p>你可以在网站上搜索<code>rand</code>包，看看它的文档使用方式是否和我们之前引入方式相一致: 在网上找到想要的包，然后将你想要的包和版本信息写入到<code>Cargo.toml</code>中。</p>
<h2 id="使用简化引入方式"><a class="header" href="#使用简化引入方式">使用{}简化引入方式</a></h2>
<p>对于以下一行一行的引入方式:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use std::collections::BTreeMap;
use std::collections::HashSet;

use std::cmp::Ordering;
use std::io;
<span class="boring">}
</span></code></pre></pre>
<p>可以使用<code>{}</code>来一起引入进来，在大型项目中，使用这种方式来引入，可以减少大量<code>use</code>的使用：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::{HashMap,BTreeMap,HashSet};
use std::{cmp::Ordering, io};
<span class="boring">}
</span></code></pre></pre>
<p>对于下面的同时引入模块和模块中的项：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Write;
<span class="boring">}
</span></code></pre></pre>
<p>可以使用<code>{}</code>的方式进行简化:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
<span class="boring">}
</span></code></pre></pre>
<h4 id="self"><a class="header" href="#self">self</a></h4>
<p>上面使用到了模块章节提到的<code>self</code>关键字，用来替代模块自身，结合上一节中的<code>self</code>，可以得出它在模块中的两个用途：</p>
<ul>
<li><code>use self::xxx</code>，表示加载当前模块中的<code>xxx</code>。此时<code>self</code>可省略</li>
<li><code>use xxx::{self, yyy}</code>，表示，加载当前路径下模块<code>xxx</code>本身，以及模块<code>xxx</code>下的<code>yyy</code>；</li>
</ul>
<h2 id="使用引入模块下的所有项"><a class="header" href="#使用引入模块下的所有项">使用*引入模块下的所有项</a></h2>
<p>对于之前一行一行引入<code>std::collections</code>的方式，我们还可以使用</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}
</span></code></pre></pre>
<p>以上这种方式来引入<code>std::collections</code>模块下的所有公共项，这些公共项自然包含了<code>HashMap</code>，<code>HashSet</code>等想手动引入的集合类型。</p>
<p>当使用<code>*</code>来引入的时候要格外小心，因为你很难知道到底哪些被引入到了当前作用域中，有哪些会和你自己程序中的名称相冲突:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::*;

struct HashMap;
fn main() {
   let mut v =  HashMap::new();
   v.insert(&quot;a&quot;, 1);
}
</code></pre></pre>
<p>以上代码中，<code>std::collection::HashMap</code>被<code>*</code>引入到当前作用域，但是由于存在另一个同名的结构体，因此<code>HashMap::new</code>根本不存在，因为对于编译器来说，本地同名类型的优先级更高。</p>
<p>在实际项目中，这种引用方式往往用于快速写测试代码，它可以把所有东西一次性引入到<code>tests</code>模块中。</p>
<h2 id="受限的可见性"><a class="header" href="#受限的可见性">受限的可见性</a></h2>
<p>在上一节中，我们学习了<a href="advance/crate-module/./module.html#%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%A7%81%E6%80%A7">可见性</a>这个概念，这也是模块体系中最为核心的概念，控制了模块中哪些内容可以被外部看见，但是在实际使用时，光被外面看到还不行，我们还想控制哪些人能看，这就是Rust提供的受限可见性。</p>
<p>例如，在Rust中，包是一个模块树，我们可以通过<code>pub(crate) item;</code>这种方式来实现：<code>item</code>虽然是对外可见的，但是只在当前包内可见，外部包无法引用到该<code>item</code>。</p>
<p>如果我们想要让某一项可以在整个包中都可以被使用，那么有两种办法：</p>
<ul>
<li>在包根中定义一个非<code>pub</code>类型的<code>X</code>(父模块的项对子模块都是可见的,因此包根中的项对模块树上的所有模块都可见)</li>
<li>在子模块中定义一个<code>pub</code>类型的<code>Y</code>，同时通过<code>use</code>将其引入到包根</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod a {
    pub mod b {
        pub fn c() {
            println!(&quot;{:?}&quot;,crate::X);
        }

        #[derive(Debug)]
        pub struct Y;
    }
}

#[derive(Debug)]
struct X;
use a::b::Y;
fn d() {
    println!(&quot;{:?}&quot;,Y);
}
<span class="boring">}
</span></code></pre></pre>
<p>以上代码充分说明了之前两种办法的使用方式，但是有时我们会遇到这两种方法都不太好用的时候。例如希望对于某些特定的模块可见，但是对于其他模块又不可见:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 目标: `a` 导出 `I`, `bar`, and `foo`, 其他的不导出
pub mod a {
    pub const I: i32 = 3;

    fn semisecret(x: i32) -&gt; i32  { use self::b::c::J; x + J }

    pub fn bar(z: i32) -&gt; i32 { semisecret(I) * z }
    pub fn foo(y: i32) -&gt; i32 { semisecret(I) + y }

    mod b {
        mod c {
            const J: i32 = 4;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这段代码会报错，因为与父模块中的项对子模块可见相反，子模块中的项对父模块是不可见的。这里<code>a</code>-&gt;<code>b</code>-&gt;<code>c</code>形成了父子模块链，那<code>c</code>中的<code>J</code>自然对<code>a</code>模块不可见。</p>
<p>如果使用之前的可见性方式，那么要保持<code>J</code>私有，同时让<code>a</code>继续使用<code>semisecret</code>函数的办法是将该函数移动到<code>c</code>模块中，然后用<code>pub use</code>进行再导出:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod a {
    pub const I: i32 = 3;

    use self::b::semisecret;

    pub fn bar(z: i32) -&gt; i32 { semisecret(I) * z }
    pub fn foo(y: i32) -&gt; i32 { semisecret(I) + y }

    mod b {
        pub use self::c::semisecret;
        mod c {
            const J: i32 = 4; 
            pub fn semisecret(x: i32) -&gt; i32  { x + J }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这段代码说实话问题不大，但是有些破坏了我们之前的逻辑，如果想保持代码逻辑，同时又只让<code>J</code>在<code>a</code>内可见怎么办？</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod a {
    pub const I: i32 = 3;

    fn semisecret(x: i32) -&gt; i32  { use self::b::c::J; x + J }

    pub fn bar(z: i32) -&gt; i32 { semisecret(I) * z }
    pub fn foo(y: i32) -&gt; i32 { semisecret(I) + y }

    mod b {
        pub(in crate::a) mod c {
            pub(in crate::a) const J: i32 = 4;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>通过<code>pub(in crate::a)</code>的方式，我们指定了模块<code>c</code>和常量<code>J</code>的可见范围都是<code>a</code>模块中，<code>a</code>之外的模块是完全访问不到它们的。</p>
<h4 id="限制可见性语法"><a class="header" href="#限制可见性语法">限制可见性语法</a></h4>
<p><code>pub(crate)</code>或<code>pub(in crate::a)</code>就是限制可见性语法, 前者是限制在整个包内可见，后者是通过绝对路径，限制在包内的某个模块内可见，总结一下：</p>
<ul>
<li><code>pub</code>意味着可见性无任何限制</li>
<li><code>pub(crate)</code>, 表示在当前包可见</li>
<li><code>pub(self)</code>, 在当前模块可见</li>
<li><code>pub(super)</code>,在父模块可见</li>
<li><code>pub(in &lt;path&gt;)</code>, 表示在某个路径代表的模块中可见, <code>path</code>必须是父模块或者祖先模块</li>
</ul>
<h4 id="一个综合例子"><a class="header" href="#一个综合例子">一个综合例子</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">// 一个名为 `my_mod` 的模块
mod my_mod {
    // 模块中的项默认具有私有的可见性
    fn private_function() {
        println!(&quot;called `my_mod::private_function()`&quot;);
    }

    // 使用 `pub` 修饰语来改变默认可见性。
    pub fn function() {
        println!(&quot;called `my_mod::function()`&quot;);
    }

    // 在同一模块中，项可以访问其它项，即使它是私有的。
    pub fn indirect_access() {
        print!(&quot;called `my_mod::indirect_access()`, that\n&gt; &quot;);
        private_function();
    }

    // 模块也可以嵌套
    pub mod nested {
        pub fn function() {
            println!(&quot;called `my_mod::nested::function()`&quot;);
        }

        #[allow(dead_code)]
        fn private_function() {
            println!(&quot;called `my_mod::nested::private_function()`&quot;);
        }

        // 使用 `pub(in path)` 语法定义的函数只在给定的路径中可见。
        // `path` 必须是父模块（parent module）或祖先模块（ancestor module）
        pub(in crate::my_mod) fn public_function_in_my_mod() {
            print!(&quot;called `my_mod::nested::public_function_in_my_mod()`, that\n &gt; &quot;);
            public_function_in_nested()
        }

        // 使用 `pub(self)` 语法定义的函数则只在当前模块中可见。
        pub(self) fn public_function_in_nested() {
            println!(&quot;called `my_mod::nested::public_function_in_nested&quot;);
        }

        // 使用 `pub(super)` 语法定义的函数只在父模块中可见。
        pub(super) fn public_function_in_super_mod() {
            println!(&quot;called my_mod::nested::public_function_in_super_mod&quot;);
        }
    }

    pub fn call_public_function_in_my_mod() {
        print!(&quot;called `my_mod::call_public_funcion_in_my_mod()`, that\n&gt; &quot;);
        nested::public_function_in_my_mod();
        print!(&quot;&gt; &quot;);
        nested::public_function_in_super_mod();
    }

    // `pub(crate)` 使得函数只在当前包中可见
    pub(crate) fn public_function_in_crate() {
        println!(&quot;called `my_mod::public_function_in_crate()&quot;);
    }

    // 嵌套模块的可见性遵循相同的规则
    mod private_nested {
        #[allow(dead_code)]
        pub fn function() {
            println!(&quot;called `my_mod::private_nested::function()`&quot;);
        }
    }
}

fn function() {
    println!(&quot;called `function()`&quot;);
}

fn main() {
    // 模块机制消除了相同名字的项之间的歧义。
    function();
    my_mod::function();

    // 公有项，包括嵌套模块内的，都可以在父模块外部访问。
    my_mod::indirect_access();
    my_mod::nested::function();
    my_mod::call_public_function_in_my_mod();

    // pub(crate) 项可以在同一个 crate 中的任何地方访问
    my_mod::public_function_in_crate();

    // pub(in path) 项只能在指定的模块中访问
    // 报错！函数 `public_function_in_my_mod` 是私有的
    //my_mod::nested::public_function_in_my_mod();
    // 试一试 ^ 取消该行的注释

    // 模块的私有项不能直接访问，即便它是嵌套在公有模块内部的

    // 报错！`private_function` 是私有的
    //my_mod::private_function();
    // 试一试 ^ 取消此行注释

    // 报错！`private_function` 是私有的
    //my_mod::nested::private_function();
    // 试一试 ^ 取消此行的注释

    // Error! `private_nested` is a private module
    //my_mod::private_nested::function();
    // 试一试 ^ 取消此行的注释
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="注释和文档"><a class="header" href="#注释和文档">注释和文档</a></h1>
<p>好的代码会说话，好的程序员不写注释，这些都是烂大街的&quot;编程界俚语&quot;。但是，如果你真的遇到一个不写注释的项目或程序员，那一定会对它/他&quot;刮目相看&quot;。</p>
<p>在之前的章节我们学习了包和模块如何使用，在此章节将进一步学习如何书写文档注释，以及如何使用<code>cargo doc</code>生成项目的文档，最后将以一个包、模块和文档的综合性例子，来将这些知识融会贯通。</p>
<h2 id="注释的种类"><a class="header" href="#注释的种类">注释的种类</a></h2>
<p>在Rust中，注释分为三类：</p>
<ul>
<li>代码注释，用于说明某一块代码的功能，用户往往是同一个项目的协作开发者</li>
<li>文档注释，支持<code>Markdown</code>, 对项目描述、公共API等用户关心的功能进行介绍，同时还能提供示例代码，目标用户往往是想要了解你项目的人</li>
<li>包和模块注释， 严格来说这也是文档注释中的一种，它主要用于说明当前包和模块的功能，方便用户迅速了解一个项目</li>
</ul>
<p>通过这些注释，实现了Rust极其优秀的文档化支持，甚至你还能在文档注释中写测试用例，省去了单独写测试用例的环节，我直接好家伙！</p>
<h2 id="代码注释"><a class="header" href="#代码注释">代码注释</a></h2>
<p>显然之前的刮目相看是打了引号的，想要去掉引号，该写注释的时候，就老老实实的，不过写时需要遵循八字原则：<strong>围绕目标，言简意赅</strong>，记住，洋洋洒洒那是用来形容文章的，不是形容注释！</p>
<p>代码注释方式有两种：</p>
<h4 id="行注释-"><a class="header" href="#行注释-">行注释 <code>//</code></a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // 我是Sun...
    // face
    let name = &quot;sunface&quot;; 
    let age = 18; // 今年好像是18岁
}
</code></pre></pre>
<p>如上所示，行注释可以放在某一行代码的上方，也可以放在当前代码行的后方. 如果超出一行的长度，需要在新行的开头也加上<code>//</code>。</p>
<p>当注释行数较多时，你还可以使用<strong>块注释</strong></p>
<h4 id="块注释---"><a class="header" href="#块注释---">块注释<code>/* .....  */</code></a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    /*
        我
        是
        S
        u
        n
        ... 淦，好长! 
    */
    let name = &quot;sunface&quot;; 
    let age = &quot;???&quot;; // 今年其实。。。挺大了
}
</code></pre></pre>
<p>如上所示，只需要将注释内容使用<code>/* */</code>进行包裹即可。</p>
<p>你会发现，Rust的代码注释跟其它语言并没有区别，主要区别其实在于文档注释这一块，也是本章节内容的重点。</p>
<h2 id="文档注释"><a class="header" href="#文档注释">文档注释</a></h2>
<p>当查看一个<code>crates.io</code>上的包时，往往需要通过它提供的文档来浏览相关的功能特性、使用方式，这种文档就是通过文档注释实现的。</p>
<p>Rust提供了<code>cargo doc</code>的命令，可以用于把这些文档注释转换成<code>HTML</code>网页文件，最终展示给用户浏览，这样用户就知道这个包是做什么的以及该如何使用。</p>
<h4 id="文档行注释"><a class="header" href="#文档行注释">文档行注释<code>///</code></a></h4>
<p>本书的一大特点就是废话不多，因此我们开门见山:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// `add_one`将指定值加1
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<p>以上代码有几点需要注意:</p>
<ul>
<li>文档注释需要位于<code>lib</code>类型的包中，例如<code>src/lib.rs</code>中</li>
<li>文档注释可以使用<code>markdown</code>！例如 <code># Examples</code>的标题，以及代码块高亮</li>
<li>被注释的对象需要使用<code>pub</code>对外可见, 记住：文档注释是给用户看的，<strong>内部实现细节不应该被暴露出去</strong></li>
</ul>
<p>咦？文档注释中的例子，为什看上去像是能运行的样子？竟然还是有<code>assert_eq</code>这种常用于测试目的的宏。 嗯，你的感觉没错，详细内容会在本章后面讲解，容我先卖个关子。</p>
<h4 id="文档块注释--"><a class="header" href="#文档块注释--">文档块注释<code>/** ... */</code></a></h4>
<p>与代码注释一样，文档也有块注释，当注释内容多时，可以减少<code>///</code>的使用:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/** `add_two`将指定值加2.

<span class="boring">Examples
</span>
```
let arg = 5;
let answer = my_crate::add_two(arg);

assert_eq!(7, answer);
```
*/
pub fn add_two(x: i32) -&gt; i32 {
    x + 2 
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="查看文档cargo-doc"><a class="header" href="#查看文档cargo-doc">查看文档cargo doc</a></h4>
<p>锦衣不夜行，这是中国人的传统美德。我们写了这么漂亮的文档注释，当然要看看网页中是什么效果咯。</p>
<p>很简单，运行<code>cargo doc</code>可以直接生成<code>HTML</code>文件，放入<em>target/doc</em>目录下。</p>
<p>当然，为了方便，我们使用<code>cargo doc --open</code>命令，可以在生成文档后，自动在浏览器中打开网页，最终效果如图所示:</p>
<img alt="" src="advance//img/comment-01.png" class="center"  />
<p>非常棒，而且非常简单，这就是Rust工具链的强大之处。</p>
<h4 id="常用文档标题"><a class="header" href="#常用文档标题">常用文档标题</a></h4>
<p>之前我们见到了在文档注释中该如何使用<code>markdown</code>，其中包括<code># Examples</code>标题。除了这个标题，还有一些常用的，你可以在项目中酌情使用:</p>
<ul>
<li><strong>Panics</strong>: 函数可能会出现的异常状况，这样调用函数的人就可以提前规避</li>
<li><strong>Errors</strong>: 描述可能出现的错误及什么情况会导致错误，有助于调用者针对不同的错误采取不同的处理方式</li>
<li><strong>Safety</strong>: 如果函数使用<code>unsafe</code>代码，那么调用者就需要注意一些使用条件，以确保<code>unsafe</code>代码块的正常工作</li>
</ul>
<p>话说回来，这些标题更多的是一种惯例, 如果你非要用中文标题也没问题，但是最好在团队中保持同样的风格 :)</p>
<h2 id="包和模块级别的注释"><a class="header" href="#包和模块级别的注释">包和模块级别的注释</a></h2>
<p>除了函数、结构体等Rust项的注释，你还可以给模块和包添加注释，需要注意的是，<strong>这些注释要添加到包、模块的最上方</strong>！</p>
<p>与之前的任何注释一样，包级别的注释也分为两种：行注释<code>//!</code>和块注释<code>/*! ... */</code>。</p>
<p>现在，为我们的包增加注释，在<code>src/lib.rs</code>包根的最上方，添加：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/*! lib包是world_hello二进制包的依赖包，
 里面包含了compute等有用模块 */

pub mod compute;
<span class="boring">}
</span></code></pre></pre>
<p>然后再为该包根的子模块<code>src/compute.rs</code>添加注释：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! 计算一些你口算算不出来的复杂算术题


/// `add_one`将指定值加1
///
<span class="boring">}
</span></code></pre></pre>
<p>运行<code>cargo doc --open</code>查看下效果:</p>
<img alt="" src="advance//img/comment-02.png" class="center"  />
<p>包模块注释，可以让用户从整体的角度理解包的用途，对于用户来说是非常友好的，就和一篇文章的开头一样，总是要对文章的内容进行大致的介绍，让用户在看的时候心中有数。</p>
<p>至此，关于如何注释的内容，就结束了，那么注释还能用来做什么？可以玩出花来吗？答案是<code>Yes</code>.</p>
<h2 id="文档测试doc-test"><a class="header" href="#文档测试doc-test">文档测试(Doc Test)</a></h2>
<p>相信读者之前都写过单元测试用例，其中一个很蛋疼的问题就是，随着代码的进化，单元测试用例经常会失效，过段时间后(为何是过段时间？应该这么问，有几个开发喜欢写测试用例 = , =)，你发现需要连续修改不少处代码，才能让测试重新工作起来。然而，在Rust中，大可不必。</p>
<p>在之前的<code>add_one</code>中，我们写的示例代码非常像是一个单元测试的用例，这是偶然吗？并不是。因为Rust允许我们在文档注释中写单元测试用例！方法就如同之前做的：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// `add_one`将指定值加1
///
/// # Examples11
///
/// ```
/// let arg = 5;
/// let answer = world_hello::compute::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<p>以上的注释不仅仅是文档，还可以作为单元测试的用例运行，使用<code>cargo test</code>运行测试：</p>
<pre><code class="language-console">Doc-tests world_hello

running 2 tests
test src/compute.rs - compute::add_one (line 8) ... ok
test src/compute.rs - compute::add_two (line 22) ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 1.00s
</code></pre>
<p>可以看到，文档中的测试用例被完美运行，而且输出中也明确提示了<code>Doc-tests world_hello</code>，意味着这些测试的名字叫<code>Doc test</code>文档测试.</p>
<blockquote>
<p>需要注意的是，你可能需要使用类如<code>world_hello::compute::add_one(arg)</code>的完整路径来调用函数，因为测试是在另外一个独立的线程中运行的</p>
</blockquote>
<h4 id="造成panic的文档测试"><a class="header" href="#造成panic的文档测试">造成panic的文档测试</a></h4>
<p>文档测试中的用例还可以造成<code>panic</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// # Panics
///
/// The function panics if the second argument is zero.
///
/// ```rust
/// // panics on division by zero
/// world_hello::compute::div(10, 0);
/// ```
pub fn div(a: i32, b: i32) -&gt; i32 {
    if b == 0 {
        panic!(&quot;Divide-by-zero error&quot;);
    }

    a / b
}
<span class="boring">}
</span></code></pre></pre>
<p>以上测试运行后会<code>panic</code>:</p>
<pre><code class="language-console">---- src/compute.rs - compute::div (line 38) stdout ----
Test executable failed (exit code 101).

stderr:
thread 'main' panicked at 'Divide-by-zero error', src/compute.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>如果想要通过这种测试，可以添加<code>should_panic</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// # Panics
///
/// The function panics if the second argument is zero.
///
/// ```rust,should_panic
/// // panics on division by zero
/// world_hello::compute::div(10, 0);
/// ```
<span class="boring">}
</span></code></pre></pre>
<p>通过<code>should_panic</code>，告诉Rust我们这个用例会导致<code>panic</code>，这样测试用例就能顺利通过。</p>
<h4 id="保留测试隐藏文档"><a class="header" href="#保留测试隐藏文档">保留测试,隐藏文档</a></h4>
<p>在某些时候，我们希望保留文档测试的功能，但是又要将某些测试用例的内容从文档中隐藏起来:</p>
<pre><pre class="playground"><code class="language-rust edition2021">/// ```
/// # // 使用#开头的行会在文档中被隐藏起来，但是依然会在文档测试中运行
/// # fn try_main() -&gt; Result&lt;(), String&gt; { 
/// let res = world_hello::compute::try_div(10, 0)?;
/// # Ok(()) // returning from try_main
/// # }
/// # fn main() { 
/// #    try_main().unwrap(); 
/// #                       
/// # }
/// ```
pub fn try_div(a: i32, b: i32) -&gt; Result&lt;i32, String&gt; {
    if b == 0 {
        Err(String::from(&quot;Divide-by-zero&quot;))
    } else {
        Ok(a / b)
    }
}
</code></pre></pre>
<p>以上文档注释中，我们使用<code>#</code>将不想让用户看到的内容隐藏起来，但是又不影响测试用例的运行，最终用户将只能看到那行没有隐藏的<code>let res = world_hello::compute::try_div(10, 0)?;</code> :</p>
<img alt="" src="advance//img/comment-03.png" class="center"  />
<h2 id="文档注释中的代码跳转"><a class="header" href="#文档注释中的代码跳转">文档注释中的代码跳转</a></h2>
<p>Rust在文档注释中还提供了一个非常强大的功能，那就是可以实现对外部项的链接: </p>
<h4 id="跳转到标准库"><a class="header" href="#跳转到标准库">跳转到标准库</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// `add_one`返回一个[`Option`]类型
pub fn add_one(x: i32) -&gt; Option&lt;i32&gt; {
    Some(x + 1)
}
<span class="boring">}
</span></code></pre></pre>
<p>此处的 <strong>[<code>Option</code>]</strong> 就是一个链接，指向了标准库中的<code>Option</code>枚举类型，有两种方式可以进行跳转:</p>
<ul>
<li>在IDE中，使用<code>Command + 鼠标左键</code>(mac系统下)，<code>CTRL + 鼠标左键</code>(win系统下)</li>
<li>在文档中直接点击链接</li>
</ul>
<p>再比如，还可以使用路径的方式跳转:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc::Receiver;

/// [`Receiver&lt;T&gt;`]   [`std::future`].
///
///  [`std::future::Future`] [`Self::recv()`].
pub struct AsyncReceiver&lt;T&gt; {
    sender: Receiver&lt;T&gt;,
}

impl&lt;T&gt; AsyncReceiver&lt;T&gt; {
    pub async fn recv() -&gt; T {
        unimplemented!()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="使用完整路径跳转到指定项"><a class="header" href="#使用完整路径跳转到指定项">使用完整路径跳转到指定项</a></h4>
<p>除了跳转到标准库，你还可以通过指定具体的路径跳转到自己代码或者其它库的指定项,例如在<code>lib.rs</code>中添加以下代码: </p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod a {
    /// `add_one`返回一个[`Option`]类型
    /// 跳转到[`crate::MySpecialFormatter`]
    pub fn add_one(x: i32) -&gt; Option&lt;i32&gt; {
        Some(x + 1)
    }
}

struct MySpecialFormatter;
<span class="boring">}
</span></code></pre></pre>
<p>使用<code>crate::MySpecialFormatter</code>这种路径就可以实现跳转到<code>lib.rs</code>中定义的结构体上。</p>
<h4 id="同名项的跳转"><a class="header" href="#同名项的跳转">同名项的跳转</a></h4>
<p>如果遇到同名项，可以使用标示类型的方式进行跳转：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 跳转到结构体  [`Foo`](struct@Foo)
struct Bar;

/// 跳转到同名函数 [`Foo`](fn@Foo)
struct Foo {}

/// 跳转到同名宏 [`foo!`]
fn Foo() {}

macro_rules! foo {
  () =&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="文档搜索别名"><a class="header" href="#文档搜索别名">文档搜索别名</a></h2>
<p>Rust文档支持搜索功能，我们可以为自己的类型定义几个别名，以实现更好的搜索展现，当别名命中时，搜索结果会被放在第一位:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[doc(alias = &quot;x&quot;)]
#[doc(alias = &quot;big&quot;)]
pub struct BigX;

#[doc(alias(&quot;y&quot;, &quot;big&quot;))]
pub struct BigY;
<span class="boring">}
</span></code></pre></pre>
<p>结果如下图所示:
<img alt="" src="advance//img/comment-05.png" class="center"  /></p>
<h2 id="一个综合例子-1"><a class="header" href="#一个综合例子-1">一个综合例子</a></h2>
<p>这个例子我们将重点应用几个知识点：</p>
<ul>
<li>文档注释</li>
<li>一个项目可以包含两个包：二进制可执行包和<code>lib</code>包（库包）, 它们的包根分别是<code>src/main.rs</code>和<code>src/lib.rs</code> </li>
<li>在二进制包中引用<code>lib</code>包</li>
<li>使用<code>pub use</code>再导出API，并观察文档</li>
</ul>
<p>首先，使用<code>cargo new art</code>创建一个package <code>art</code>: </p>
<pre><code class="language-console">Created binary (application) `art` package
</code></pre>
<p>系统提示我们创建了一个二进制<code>package</code>，根据<a href="advance/./crate-module/crate.html">之前章节</a>学过的内容，可以知道该<code>package</code>包含一个同名的二进制包：包名为<code>art</code>，包根为<code>src/main.go</code>，该包可以编译成二进制然后运行。</p>
<p>现在，在<code>src</code>目录下创建一个<code>lib.rs</code>文件, 同样，根据之前学习的知识，创建该文件等于又创建了一个库类型的包，包名也是<code>art</code>，包根为<code>src/lib.rs</code>，该包是是库类型的，因此往往作为依赖库被引入。</p>
<p>将以下内容添加到<code>src/lib.rs</code>中：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! # Art
//!
//!  未来的艺术建模库，现在的调色库

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    //! 定义颜色的类型
    
    /// 主色
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// 副色
    #[derive(Debug,PartialEq)]
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    //! 实用工具，目前只实现了调色板
    use crate::kinds::*;

    /// 将两种主色调成副色
    /// ```rust
    /// use art::utils::mix;
    /// use art::kinds::{PrimaryColor,SecondaryColor};
    /// assert_eq!(mix(PrimaryColor::Yellow, PrimaryColor::Blue), SecondaryColor::Green)
    /// ```
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        SecondaryColor::Green
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在库包的包根<code>src/lib.rs</code>下，我们又定义了几个子模块，同时将子模块中的三个项通过<code>pub use</code>进行了再导出。</p>
<p>接着，将下面内容添加到<code>src/main.rs</code>中:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let blue = PrimaryColor::Blue;
    let yellow = PrimaryColor::Yellow;
    println!(&quot;{:?}&quot;,mix(blue, yellow));
}
</code></pre></pre>
<p>在二进制可执行包的包根<code>src/main.rs</code>下，我们引入了库包<code>art</code>中的模块项，同时使用<code>main</code>函数作为程序的入口,该二进制包可以使用<code>cargo run</code>运行:</p>
<pre><code class="language-console">Green
</code></pre>
<p>至此，库包完美提供了用于调色的API, 二进制包引入这些API完美的实现了调色并打印输出。</p>
<p>最后，再来看看文档长啥样：</p>
<img alt="" src="advance//img/comment-04.png" class="center"  />
<h2 id="总结-5"><a class="header" href="#总结-5">总结</a></h2>
<p>在Rust中，注释分为三个主要类型：代码注释、文档注释、包和模块注释，每个注释类型都拥有两种形式：行注释和块注释，熟练掌握包模块和注释的知识，非常有助于我们创建工程性更强的项目。</p>
<p>如果读者看到这里对于包模块还是有些模糊，强烈建议回头看看相关的章节以及本章节的最后一个综合例子。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="深入rust类型"><a class="header" href="#深入rust类型">深入Rust类型</a></h1>
<p>弱弱的、不负责任的说，Rust的学习难度之恶名，可能有一半来源于Rust的类型系统，而其中一半的一半则来自于本章节的内容。在本章，我们将重点学习如何创建自定义类型，以及了解何为动态大小的类型。</p>
<h2 id="newtype"><a class="header" href="#newtype">newtype</a></h2>
<p>何为<code>newtype</code>? 简单来说，就是使用<a href="https://course.rs/basic/compound-type/struct.html#%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93tuple-struct">元组结构体</a>的方式将已有的类型包裹起来:<code>struct Meters(u32);</code>, 那么此处<code>Meters</code>就是一个<code>newtype</code>。</p>
<p>为何需要<code>newtype</code>？Rust这多如繁星的Old类型满足不了我们吗？这是因为：</p>
<ul>
<li>自定义类型可以让我们给出更有意义和可读性的类型名，例如与其使用<code>u32</code>作为距离的单位类型，我们可以使用<code>Meters</code>，它的可读性要好的多</li>
<li>对于某些场景，只有newtype可以很好的解决</li>
<li>隐藏内部类型的细节</li>
</ul>
<p>一箩筐的理由～～ 让我们先从第二点讲起。</p>
<h4 id="为外部类型实现外部特征"><a class="header" href="#为外部类型实现外部特征">为外部类型实现外部特征</a></h4>
<p>在之前的章节中，我们有讲过如果在外部类型上实现外部特征必须使用<code>newtype</code>的方式，否则你就得遵循孤儿规则：要为类型<code>A</code>实现特征<code>T</code>，那么<code>A</code>或者<code>T</code>必须至少有一个在当前的作用范围内。</p>
<p>例如, 如果想使用<code>println!(&quot;{}&quot;,v)</code>的方式去格式化输出一个动态数组<code>Vec</code>，以期给用户提供更加清晰可读的内容，那么就需要为<code>Vec</code>实现<code>Display</code>特征，但是这里有一个问题：<code>Vec</code>类型定义在标准库中，<code>Display</code>亦然， 这时就可以祭出大杀器<code>newtype</code>来解决：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<p>如上所示，使用元组结构体语法<code>struct Wrapper(Vec&lt;String&gt;)</code>创建了一个<code>newtype</code> Wrapper, 然后为它实现<code>Display</code>特征，最终实现了对<code>Vec</code>动态数组的格式化输出。</p>
<h4 id="更好的可读性及类型异化"><a class="header" href="#更好的可读性及类型异化">更好的可读性及类型异化</a></h4>
<p>首先，更好的可读性不等于更少的代码(如果你学过scala，相信会深有体会)，其次下面的例子只是一个示例，未必能体现出更好的可读性：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Add;
use std::fmt;

struct Meters(u32);
impl fmt::Display for Meters {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;目标地点距离你{}米&quot;, self.0)
    }
}

impl Add for Meters {
    type Output = Self;

    fn add(self, other: Meters) -&gt; Self {
        Self(self.0 + other.0)
    }
}
fn main() {
    let d = calculate_distance(Meters(10), Meters(20));
    println!(&quot;{}&quot;,d);
}

fn calculate_distance(d1: Meters,d2: Meters) -&gt; Meters {
    d1 + d2
}
</code></pre></pre>
<p>上面代码创建了一个<code>newtype</code> Meters，为其实现<code>Display</code>和<code>Add</code>特征，接着对两个距离进行求和计算，最终打印出该距离:</p>
<pre><code class="language-console">目标地点距离你30米
</code></pre>
<p>事实上，除了可读性外，还有一个极大的优点：如果给<code>calculate_distance</code>传一个其它的类型，例如<code>struct MilliMeters(u32);</code>,该代码将无法编译。尽管<code>Meters</code>和<code>MilliMeters</code>都是对<code>u32</code>类型的简单包装，但是<strong>它们是不同的类型</strong>！</p>
<h4 id="隐藏内部类型的细节"><a class="header" href="#隐藏内部类型的细节">隐藏内部类型的细节</a></h4>
<p>众所周知，Rust的类型有很多自定义的方法，假如我们把某个类型传给了用户，但是又不想用户调用这些方法，就可以使用<code>newtype</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Meters(u32);

fn main() {
    let i: u32 = 2;
    assert_eq!(i.pow(2),4);

    let n = Meters(i);
    // 下面的代码将报错，因为`Meters`类型上没有`pow`方法
    // assert_eq!(n.pow(2),4);
}
</code></pre></pre>
<p>不过需要偷偷告诉你的是，这种方式实际上是掩耳盗铃，因为用户依然可以通过<code>n.0.pow(2)</code>的方式来调用内部类型的方法:)</p>
<h2 id="类型别名type-alias"><a class="header" href="#类型别名type-alias">类型别名(Type Alias)</a></h2>
<p>除了使用<code>newtype</code>，我们还可以使用一个更传统的方式来创建新类型: 类型别名</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Meters = u32
<span class="boring">}
</span></code></pre></pre>
<p>嗯，不得不说，类型别名的方式看起来比<code>newtype</code>顺眼的多，而且跟其它语言的使用方式几乎一致，但是：
<strong>类型别名并不是一个独立的全新的类型，而是某一个类型的别名</strong>，因此编译器依然会把<code>Meters</code>当<code>u32</code>来使用：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Meters = i32;

let x: u32 = 5;
let y: Meters = 5;

println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<p>上面的代码将顺利编译通过，但是如果你使用<code>newtype</code>模式，该代码将无情报错，简单做个总结：</p>
<ul>
<li>类型别名仅仅是别名，只是为了让可读性更好，并不是全新的类型，<code>newtype</code>才是！</li>
<li>类型别名无法实现<em>为外部类型实现外部特征</em>等功能，而<code>newtype</code>可以</li>
</ul>
<p>类型别名除了让类型可读性更好，还能<strong>减少模版代码的使用</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
    // --snip--
}

fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p><code>f</code>是一个令人眼花缭乱的类型<code>Box&lt;dyn Fn() + Send + 'static&gt;</code>，如果仔细看，会发现其实只有一个<code>Send</code>特征不认识，<code>Send</code>是什么在这里不重要，你只需理解，<code>f</code>就是一个<code>Box&lt;dyn T&gt;</code>类型的特征对象，实现了<code>Fn()</code>和<code>Send</code>特征，同时生命周期为<code>'static</code>。</p>
<p>因为<code>f</code>的类型贼长，导致了后面我们在使用它时，到处都充斥这些不太优美的类型标注，好在类型别名可解君忧:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Thunk) {
    // --snip--
}

fn returns_long_type() -&gt; Thunk {
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p>Bang! 是不是？！立刻大幅简化了我们的使用。 喝着奶茶、哼着歌、我写起代码撩起妹，何其快哉！</p>
<p>在标准库中，类型别名应用最广的就是简化<code>Result&lt;T,E&gt;</code>枚举。</p>
<p>例如在<code>std::io</code>库中，它定义了自己的<code>Error</code>类型：<code>std::io::Error</code>，那么如果要使用该<code>Result</code>就要用这样的语法：<code>std::result::Result&lt;T, std::io::Error&gt;;</code>，想象一下代码中充斥着这样的东东是一种什么感受？颤抖吧。。。</p>
<p>由于使用<code>std::io</code>库时，它的所有错误类型都是<code>std::io::Error</code>，那么我们完全可以把该错误对用户隐藏起来，只在内部使用即可，因此就可以使用类型别名来简化实现:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Bingo, 这样一来，其它库只需要使用<code>std::io::Result&lt;T&gt;</code>即可替代冗长的<code>std::result::Result&lt;T, std::io::Error&gt;</code>类型.</p>
<p>更香的是，由于它只是别名，因此我们可以用它来调用真实类型的所有方法,甚至包括<code>?</code>符号！</p>
<h2 id="永不返回类型"><a class="header" href="#永不返回类型">!永不返回类型</a></h2>
<p>在<a href="https://course.rs/basic/base-type/function.html#%E6%B0%B8%E4%B8%8D%E8%BF%94%E5%9B%9E%E7%9A%84%E5%87%BD%E6%95%B0">函数</a>那章，曾经介绍过<code>!</code>类型：<code>!</code>用来说明一个函数永不返回任何值，当时可能体会不深，没事，在学习了更多手法后，保证你有全新的体验：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let i = 2;
    let v = match i {
       0..=3 =&gt; i,
       _ =&gt; println!(&quot;不合规定的值:{}&quot;,i) 
    };
}
</code></pre></pre>
<p>上面函数，会报出一个编译错误:</p>
<pre><code class="language-console">error[E0308]: `match` arms have incompatible types // match的分支类型不同
 --&gt; src/main.rs:5:13
  |
3 |       let v = match i {
  |  _____________-
4 | |        0..3 =&gt; i,
  | |                - this is found to be of type `{integer}` // 该分支返回整数类型
5 | |        _ =&gt; println!(&quot;不合规定的值:{}&quot;,i) 
  | |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found `()` // 该分支返回()元类型
6 | |     };
  | |_____- `match` arms have incompatible types
</code></pre>
<p>原因很简单: 要赋值给<code>v</code>，就必须保证<code>match</code>的各个分支返回的值是同一个类型，但是上面一个分支返回数值、另一个分支返回元类型<code>()</code>，自然会出错。</p>
<p>既然<code>println</code>不行，那再试试<code>panic</code></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let i = 2;
    let v = match i {
       0..=3 =&gt; i,
       _ =&gt; panic!(&quot;不合规定的值:{}&quot;,i) 
    };
}
</code></pre></pre>
<p>神奇的事发生了，此处<code>panic</code>竟然通过了编译。难道这两个宏拥有不同的返回类型？</p>
<p>你猜的没错：<code>panic</code>的返回值是<code>!</code>，代表它决不会返回任何值，既然没有任何返回值，那自然不会存在分支类型不匹配的情况。</p>
<h2 id="动态大小类型"><a class="header" href="#动态大小类型">动态大小类型</a></h2>
<p>读者大大们之前学过的几乎所有类型，都是固定大小的类型，包括集合<code>Vec</code>、<code>String</code>和<code>HashMap</code>等，而动态大小类型刚好与之相反: <strong>编译器无法在编译期得知该类型值的大小，只有到了程序运行时，才能动态获知</strong>。对于动态类型，我们使用<code>DST</code>(dynamically sized types)或者<code>unsized</code>类型来称呼它。</p>
<p>上述的这些集合虽然底层数据可动态变化，感觉像是动态大小的类型。但是实际上，这些底层数据只是保存在堆上，在栈中还存有一个引用类型，该引用包含了集合的内存地址、元素数目、分配空间信息，通过这些信息，编译器对于该集合的实际大小了若指掌，因此它们依然是固定大小的类型。</p>
<p>现在给你一个挑战：想出一个动态类型。俺厚黑的说一句，估计大部分人都想不到这样的一个类型:P 。就连我，如果不是查询着资料在写，估计也一时半会儿想不到一个。</p>
<p>考虑一下这个类型：<code>str</code>，感觉有点眼生？是的，它既不是<code>String</code>动态字符串，也不是<code>&amp;str</code>字符串切片，而是一个<code>str</code>。它是一个动态类型，同时还是<code>String</code>和<code>&amp;str</code>的底层数据类型。 由于<code>str</code>是动态类型，因此它的大小直到运行期才知道，下面的代码会因此报错：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// error
let s1: str = &quot;Hello there!&quot;;
let s2: str = &quot;How's it going?&quot;;

// ok
let s3: &amp;str = &quot;on?&quot;
<span class="boring">}
</span></code></pre></pre>
<p>Rust需要明确的知道一个特定类型的值占据了多少内存空间，同时该类型的所有值都必须使用相同大小的内存。如果Rust允许我们使用这种动态类型，那么这两个<code>str</code>值就需要占用同样大小的内存，这显然是不现实的: <code>s1</code>占用了12字节，<code>s2</code>占用了15字节，总不至于为了满足同样的内存大小，用空白字符去填补字符串吧？</p>
<p>所以，我们只有一条路走，那就是给它们一个固定大小的类型：<code>&amp;str</code>。那么为何字符串切片<code>&amp;str</code>就是固定大小呢？因为它的引用存储在栈上，具有固定大小(类似指针)，同时它指向的数据存储在堆中，也是已知的大小，再加上<code>&amp;str</code>引用中包含有堆上数据内存地址、长度等信息，因此最终可以得出字符串切片是固定大小类型的结论。</p>
<p>与<code>&amp;str</code>类似，<code>String</code>字符串也是固定大小的类型。</p>
<p>正是因为<code>&amp;str</code>的引用有了底层堆数据的明确信息，它才是固定大小类型。假设如果它没有这些信息呢？那它也将变成一个动态类型。因此，将动态数据固定化的秘诀就是<strong>使用引用指向这些动态数据，然后在引用中存储相关的内存位置、长度等信息</strong>。</p>
<p>我们之前已经见过，使用<code>Box</code>将一个没有固定大小的特征变成一个有固定大小的特征对象，那能否故技重施，将<code>str</code>封装成一个固定大小类型？留个悬念先，我们来看看<code>Sized</code>特征。</p>
<blockquote>
<p>Rust中最常见的<code>DST</code>类型: <code>str</code>, <code>[T]</code>, <code>dyn Trait</code></p>
</blockquote>
<h4 id="sized特征"><a class="header" href="#sized特征">Sized特征</a></h4>
<p>既然动态类型的问题这么大，那么在使用泛型时，Rust如何保证我们的泛型参数是固定大小的类型呢？例如以下泛型函数：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T&gt;(t: T) {
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p>该函数很简单，就一个泛型参数T，那么如果保证<code>T</code>是固定大小的类型？仔细回想下，貌似在之前的课程章节中，我们也没有做过任何事情去做相关的限制，那<code>T</code>怎么就成了固定大小的类型了？奥秘在于编译器自动帮我们加上了<code>Sized</code>特征：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p>在上面,Rust自动添加的特征约束<code>T: Sized</code>，表示泛型函数只能用于一切实现了<code>Sized</code>特征的类型上，而<strong>所有在编译时就能知道其大小的类型, 都会自动实现<code>Sized</code>特征</strong>，例如。。。。也没啥好例如的，你能想到的几乎类型都实现了<code>Sized</code>特征，除了上面那个坑坑的<code>str</code>，哦，还有特征。</p>
<p><strong>每一个特征都是一个可以通过名称来引用的动态大小类型</strong>。因此如果想把特征作为具体的类型来传递给函数，你必须将其转换成一个特征对象：诸如<code>&amp;dyn Trait</code>或者<code>Box&lt;dyn Trait&gt;</code>(还有<code>Rc&lt;dyn Trait&gt;</code>)这些引用类型。</p>
<p>现在还有一个问题：假如想在泛型函数中使用动态数据类型怎么办？可以使用<code>?Sized</code>特征(不得不说这个命名方式很Rusty，竟然有点幽默):</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p><code>?Sized</code>特征用于表明类型<code>T</code>既有可能是固定大小的类型，也可能是动态大小的类型。还有一点要注意的是，函数参数类型从<code>T</code>变成了<code>&amp;T</code>，因为<code>T</code>可能是动态大小的，因此需要用一个固定大小的指针(引用)来包裹它。</p>
<h4 id="box"><a class="header" href="#box">Box<str></a></h4>
<p>在结束前，再来看看之前遗留的问题: 使用<code>Box</code>可以将一个动态大小的特征变成一个具有固定大小的特征对象，能否故技重施，将<code>str</code>封装成一个固定大小类型？</p>
<p>先回想下，章节前面的内容介绍过该如何把一个动态大小类型转换成固定大小的类型： <strong>使用引用指向这些动态数据，然后在引用中存储相关的内存位置、长度等信息</strong>。</p>
<p>好的，根据这个，我们来一起推测。 首先，<code>Box&lt;str&gt;</code>使用了一个引用来指向<code>str</code>，嗯，满足了第一个条件。但是第二个条件呢？<code>Box</code>中有该<code>str</code>的长度信息吗？显然是<code>No</code>。那为什么特征就可以变成特征对象？其实这个还蛮复杂的，简单来说，对于特征对象，编译器无需知道它具体是什么类型，只要知道它能调用哪几个方法即可，因此编译器帮我们实现了剩下的一切。</p>
<p>来验证下我们的推测:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1: Box&lt;str&gt; = Box::new(&quot;Hello there!&quot; as str);
}
</code></pre></pre>
<p>报错如下：</p>
<pre><code>error[E0277]: the size for values of type `str` cannot be known at compilation time
 --&gt; src/main.rs:2:24
  |
2 |     let s1: Box&lt;str&gt; = Box::new(&quot;Hello there!&quot; as str);
  |                        ^^^^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: all function arguments must have a statically known size
</code></pre>
<p>提示的很清晰，不知道<code>str</code>的大小，因此无法对其使用<code>Box</code>进行封装.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="格式化输出"><a class="header" href="#格式化输出">格式化输出</a></h1>
<p>提到格式化输出，可能很多人立刻就想到<code>&quot;{}&quot;</code>，但是Rust能做到的远比这个多的多，本章节我们将深入讲解格式化输出的各个方面。</p>
<h2 id="满分初印象"><a class="header" href="#满分初印象">满分初印象</a></h2>
<p>先来一段代码，看看格式化输出的初印象：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello&quot;);                 // =&gt; &quot;Hello&quot;
println!(&quot;Hello, {}!&quot;, &quot;world&quot;);   // =&gt; &quot;Hello, world!&quot;
println!(&quot;The number is {}&quot;, 1);   // =&gt; &quot;The number is 1&quot;
println!(&quot;{:?}&quot;, (3, 4));          // =&gt; &quot;(3, 4)&quot;
println!(&quot;{value}&quot;, value=4);      // =&gt; &quot;4&quot;
println!(&quot;{} {}&quot;, 1, 2);           // =&gt; &quot;1 2&quot;
println!(&quot;{:04}&quot;, 42);             // =&gt; &quot;0042&quot; with leading zeros
<span class="boring">}
</span></code></pre></pre>
<p>可以看到<code>println!</code>宏接受的是可变参数，第一个参数是一个字符串常量，它表示最终输出字符串的格式, 包含其中形如<code>{}</code>的符号是<strong>占位符</strong>, 会被<code>println!</code>后面的参数依次替换。</p>
<h2 id="print-println-format"><a class="header" href="#print-println-format"><code>print!</code>, <code>println!</code>, <code>format!</code></a></h2>
<p>它们是Rust中用来格式化输出的三大金刚，用途如下：</p>
<ul>
<li><code>print!</code>, 将格式化文本输出到标准输出，不带换行符</li>
<li><code>println!</code>, 同上，但是在行的末尾添加换行符</li>
<li><code>format!</code>, 将格式化文本输出到<code>String</code>字符串</li>
</ul>
<p>在实际项目中，最常用的是<code>println!</code>及<code>format!</code>，前者常用来调试输出，后者用来生成格式化的字符串:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = &quot;hello&quot;;
    println!(&quot;{}, world&quot;,s);
    let s1 = format!(&quot;{}, world&quot;, s);
    print!(&quot;{}&quot;,s1);
    print!(&quot;{}\n&quot;,&quot;!&quot;);
}
</code></pre></pre>
<p>其中, <code>s1</code>是通过<code>format!</code>生成的<code>String</code>字符串，最终输出如下：</p>
<pre><code class="language-console">hello, wolrd
hello, world!
</code></pre>
<h4 id="eprint-eprintln"><a class="header" href="#eprint-eprintln"><code>eprint!</code>, <code>eprintln!</code></a></h4>
<p>除了三大金刚外，还有两大护法，使用方式跟<code>print!</code>,<code>println!</code>很像，但是它们输出到标准错误输出:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>eprintln!(&quot;Error: Could not complete task&quot;)
<span class="boring">}
</span></code></pre></pre>
<p>它们仅应该被用于输出错误信息和进度信息，其它场景都应该使用<code>print!</code>系列。</p>
<h2 id="与"><a class="header" href="#与">{}与{:?}</a></h2>
<p>与其它语言常用的<code>%d</code>,<code>%s</code>不同，Rust特立独行的选择了<code>{}</code>作为格式化占位符(说到这个，有点想吐槽下，Rust中自创的概念其实还挺多的，真不知道该夸奖还是该吐槽- , -)，事实证明，这种选择非常正确，它帮助用户减少了很多使用成本，你无需再为特定的类型选择特定的占位符，统一用<code>{}</code>来替代即可，剩下的类型推导等细节只要交给Rust去做。</p>
<p>与<code>{}</code>类似，<code>{:?}</code>也是占位符:</p>
<ul>
<li><code>{}</code>适用于实现了<code>std::fmt::Display</code>特征的类型,用来以更优雅、更友好的方式格式化文本，例如展示给用户</li>
<li><code>{:?}</code>适用于实现了<code>std::fmt::Debug</code>特征的类型，用于调试场景</li>
</ul>
<p>其实两者的选择很简单，当你在写代码需要调试时，使用<code>{:?}</code>，剩下的场景，选择<code>{}</code>。</p>
<h4 id="debug特征"><a class="header" href="#debug特征"><code>Debug</code>特征</a></h4>
<p>事实上，为了方便我们调试，大多数Rust类型都实现了<code>Debug</code>特征或者支持派生该特征:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Person {
    name: String,
    age: u8
}

fn main() {
    let i = 3.1415926;
    let s = String::from(&quot;hello&quot;);
    let v = vec![1,2,3];
    let p = Person{name: &quot;sunface&quot;.to_string(),age: 18};
    println!(&quot;{:?}, {:?}, {:?},{:?}&quot;,i,s,v,p);
}
</code></pre></pre>
<p>对于数值、字符串、数组，可以直接使用<code>{:?}</code>进行输出，但是对于结构体，需要<a href="advance/../appendix/derive.html">派生<code>Debug</code></a>特征后，才能进行输出，总之很简单.</p>
<h4 id="display特征"><a class="header" href="#display特征"><code>Display</code>特征</a></h4>
<p>与大部分类型实现了<code>Debug</code>不同，实现了<code>Display</code>特征的Rust类型并没有那么多，往往需要我们自定义想要的格式化方式:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let i = 3.1415926;
let s = String::from(&quot;hello&quot;);
let v = vec![1,2,3];
let p = Person{name: &quot;sunface&quot;.to_string(),age: 18};
println!(&quot;{}, {}, {},{}&quot;,i,s,v,p);
<span class="boring">}
</span></code></pre></pre>
<p>运行后可以看到<code>v</code>和<code>p</code>都无法通过编译，因为没有实现<code>Display</code>特征，但是你又不能像派生<code>Debug</code>一般派生<code>Display</code>，只能另寻他法:</p>
<ul>
<li>使用<code>{:?}</code>或<code>{:#?}</code></li>
<li>为自定义类型实现<code>Display</code>特征</li>
<li>使用<code>newtype</code>为外部类型实现<code>Display</code>特征</li>
</ul>
<p>下面来一一看看这三种方式。</p>
<h4 id=""><a class="header" href="#">{:#?}</a></h4>
<p><code>{:#?}</code>与<code>{:?}</code>几乎一样，唯一的区别在于它能更优美的输出内容：</p>
<pre><code class="language-console">// {:?}
[1, 2, 3],Person { name: &quot;sunface&quot;, age: 18 }

// {:#?}
[
    1,
    2,
    3,
],Person {
    name: &quot;sunface&quot;,
}
</code></pre>
<p>因此对于<code>Display</code>不支持的类型，可以考虑使用<code>{:#?}</code>进行格式化，虽然理论上它更适合进行调试输出。</p>
<h4 id="为自定义类型实现display特征"><a class="header" href="#为自定义类型实现display特征">为自定义类型实现<code>Display</code>特征</a></h4>
<p>如果你的类型是定义在当前作用域中的，那么可以为其实现<code>Display</code>特征，即可用于格式化输出:</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Person {
    name: String,
    age: u8
}

use std::fmt;
impl  fmt::Display for Person {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;大佬在上，请受我一拜，小弟姓名{}，年芳{}，家里无田又无车，生活苦哈哈&quot;,self.name,self.age)
    }
}
fn main() {
    let p = Person{name: &quot;sunface&quot;.to_string(),age: 18};
    println!(&quot;{}&quot;, p);
}
</code></pre></pre>
<p>如上所示，只要实现<code>Display</code>特征中的<code>fmt</code>方法，即可为自定义结构体<code>Person</code>添加自定义输出：</p>
<pre><code class="language-console">大佬在上，请受我一拜，小弟姓名sunface，年芳18，家里无田又无车，生活苦哈哈
</code></pre>
<h4 id="为外部类型实现display特征"><a class="header" href="#为外部类型实现display特征">为外部类型实现<code>Display</code>特征</a></h4>
<p>在Rust中，无法直接为外部类型实现外部特征，但是可以使用<a href="advance/./custom-type.html#newtype"><code>newtype</code></a>解决此问题：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Array(Vec&lt;i32&gt;);

use std::fmt;
impl  fmt::Display for Array {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;数组是：{:?}&quot;,self.0)
    }
}
fn main() {
    let arr = Array(vec![1, 2, 3]);
    println!(&quot;{}&quot;, arr);
}
</code></pre></pre>
<p><code>Array</code>就是我们的<code>newtype</code>，它将想要格式化输出的<code>Vec</code>包裹在内，最后只要为<code>Arraw</code>实现<code>Display</code>特征，即可进行格式化输出:</p>
<pre><code class="language-console">数组是：[1, 2, 3]
</code></pre>
<p>至此，关于<code>{}</code>与<code>{:?}</code>的内容已介绍完毕，下面让我们正式开始格式化输出的旅程。</p>
<h2 id="指定位置参数"><a class="header" href="#指定位置参数">指定位置参数</a></h2>
<p>除了按照依次顺序使用值去替换占位符之外，还能让指定位置的参数去替换某个占位符，例如<code>{1}</code>，表示用第二个参数替换该占位符(索引从0开始):</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!(&quot;{}{}&quot;,1,2); // =&gt;&quot;12&quot;
    println!(&quot;{1}{0}&quot;,1,2); // =&gt;&quot;21&quot;
    // =&gt; Alice, this is Bob. Bob, this is Alice
    println!(&quot;{0}, this is {1}. {1}, this is {0}&quot;, &quot;Alice&quot;, &quot;Bob&quot;);
    println!(&quot;{1}{}{0}{}&quot;,1,2); // =&gt; 2112
}
</code></pre></pre>
<h2 id="带名称的变量"><a class="header" href="#带名称的变量">带名称的变量</a></h2>
<p>除了像上面那样指定位置外，我们还可以为参数指定名称：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!(&quot;{argument}&quot;, argument = &quot;test&quot;); // =&gt; &quot;test&quot;
    println!(&quot;{name} {}&quot;, 1, name = 2); // =&gt; &quot;2 1&quot;
    println!(&quot;{a} {c} {b}&quot;, a = &quot;a&quot;, b = 'b', c = 3); // =&gt; &quot;a 3 b&quot;
}
</code></pre></pre>
<p>需要注意的是： <strong>带名称的参数必须放在不带名称参数的后面</strong>，例如下面代码将报错：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{abc} {1}&quot;, abc = &quot;def&quot;, 2);
<span class="boring">}
</span></code></pre></pre>
<h2 id="格式化参数"><a class="header" href="#格式化参数">格式化参数</a></h2>
<p>格式化输出，意味着对输出格式会有更多的要求，例如只输出浮点数的小数点后两位:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let v = 3.1415926;
    // Display =&gt; 3.14
    println!(&quot;{:.2}&quot;,v);
    // Debug =&gt; 3.14
    println!(&quot;{:.2?}&quot;,v);
}
</code></pre></pre>
<p>上面代码只输出小数点后两位。同时我们还展示了<code>{}</code>和<code>{:?}</code>的用法，后面如无特殊区别，就只针对<code>{}</code>提供格式化参数说明。</p>
<p>接下来，让我们一起来看看Rust中有哪些格式化参数。</p>
<h4 id="宽度"><a class="header" href="#宽度">宽度</a></h4>
<p>宽度用来指示输出目标的长度，如果长度不够，则进行填充和对齐:</p>
<h5 id="字符串填充"><a class="header" href="#字符串填充">字符串填充</a></h5>
<p>字符串格式化默认使用空格进行填充，并且进行左对齐.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    //-----------------------------------
    // 以下全部输出 &quot;Hello x    !&quot;
    // 为&quot;x&quot;后面填充空格，补齐宽度5
    println!(&quot;Hello {:5}!&quot;, &quot;x&quot;);
    // 使用参数5来指定宽度
    println!(&quot;Hello {:1$}!&quot;, &quot;x&quot;, 5);
    // 使用x作为占位符输出内容，同时使用5作为宽度
    println!(&quot;Hello {1:0$}!&quot;, 5, &quot;x&quot;);
    // 使用有名称的参数作为宽度
    println!(&quot;Hello {:width$}!&quot;, &quot;x&quot;, width = 5);
    //-----------------------------------

    // 使用参数5为参数x指定宽度,同时在结尾输出参数5 =&gt; Hello x    !5
    println!(&quot;Hello {:1$}!{}&quot;, &quot;x&quot;, 5);
}
</code></pre></pre>
<h5 id="数字填充符号和0"><a class="header" href="#数字填充符号和0">数字填充:符号和0</a></h5>
<p>数字格式化默认也是使用空格进行填充，但与字符串左对齐不同的是，数字是右对齐。</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // 宽度是5 =&gt; Hello     5!
    println!(&quot;Hello {:5}!&quot;, 5);
    // 显式的输出正号 =&gt; Hello +5!
    println!(&quot;Hello {:+}!&quot;, 5);
    // 宽度5，使用0进行填充 =&gt; Hello 00005!
    println!(&quot;Hello {:05}!&quot;, 5);
    // 负号也要占用一位宽度 =&gt; Hello -0005!
    println!(&quot;Hello {:05}!&quot;, -5);
}
</code></pre></pre>
<h5 id="对齐"><a class="header" href="#对齐">对齐</a></h5>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // 以下全部都会补齐5个字符的长度
    // 左对齐 =&gt; Hello x    !
    println!(&quot;Hello {:&lt;5}!&quot;,&quot;x&quot;); 
    // 右对齐 =&gt; Hello     x
    println!(&quot;Hello {:&gt;5}!&quot;,&quot;x&quot;);
    // 居中对齐 =&gt; Hello   x  !
    println!(&quot;Hello {:^5}!&quot;,&quot;x&quot;);

    // 对齐并使用指定符号填充 =&gt; Hello x&amp;&amp;&amp;&amp;!
    // 指定符号填充的前提条件是必须有对齐字符
    println!(&quot;Hello {:&amp;&lt;5}!&quot;, &quot;x&quot;);
}
</code></pre></pre>
<h4 id="精度"><a class="header" href="#精度">精度</a></h4>
<p>精度可以用于控制浮点数的精度或者字符串的长度</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let v = 3.1415926;
    // 保留小数点后两位 =&gt; 3.14
    println!(&quot;{:.2}&quot;,v);
    // 带符号保留小数点后两位 =&gt; +3.14
    println!(&quot;{:+.2}&quot;,v);
    // 不带小数 =&gt; 3
    println!(&quot;{:.0}&quot;,v);
    // 通过参数来设定精度 =&gt; 3.1416,相当于{:.4}
    println!(&quot;{:.1$}&quot;, v, 4);
    
    let s = &quot;hi我是Sunface孙飞&quot;;
    // 保留字符串前三个字符 =&gt; hi我
    println!(&quot;{:.3}&quot;, s);
    // {:.*}接收两个参数，第一个是精度，第二个是被格式化的值 =&gt; Hello abc!
    println!(&quot;Hello {:.*}!&quot;, 3, &quot;abcdefg&quot;);
}
</code></pre></pre>
<h4 id="进制"><a class="header" href="#进制">进制</a></h4>
<p>可以使用<code>#</code>号来控制数字的进制输出:</p>
<ul>
<li><code>#b</code>, 二进制</li>
<li><code>#o</code>, 八进制</li>
<li><code>#x</code>, 小写十六进制</li>
<li><code>#X</code>, 大写十六进制</li>
<li><code>x</code>, 不带前缀的小写十六进制</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // 二进制 =&gt; 0b11011!
    println!(&quot;{:#b}!&quot;, 27);
    // 八进制 =&gt; 0o33!
    println!(&quot;{:#o}!&quot;, 27);
    // 十进制 =&gt; 27!
    println!(&quot;{}!&quot;, 27);
    // 小写十六进制 =&gt; 0x1b!
    println!(&quot;{:#x}!&quot;, 27);
    // 大写十六进制 =&gt; 0x1B!
    println!(&quot;{:#X}!&quot;, 27);

    // 不带前缀的十六进制 =&gt; 1b!
    println!(&quot;{:x}!&quot;, 27);

    // 使用0填充二进制，宽度为10 =&gt; 0b00011011!
    println!(&quot;{:#010b}!&quot;, 27); 
}
</code></pre></pre>
<h4 id="指数"><a class="header" href="#指数">指数</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!(&quot;{:2e}&quot;, 1000000000); // =&gt; 1e9
    println!(&quot;{:2E}&quot;, 1000000000); // =&gt; 1E9
}
</code></pre></pre>
<h4 id="指针地址"><a class="header" href="#指针地址">指针地址</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v= vec![1,2,3];
println!(&quot;{:p}&quot;,v.as_ptr()) // =&gt; 0x600002324050
<span class="boring">}
</span></code></pre></pre>
<h4 id="转义"><a class="header" href="#转义">转义</a></h4>
<p>有时需要输出<code>{</code>和<code>}</code>，但这两个字符是特殊字符，需要进行转义: </p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // {使用{转义，}使用} =&gt; Hello {}
    println!(&quot;Hello {{}}&quot;);

    // 下面代码会报错，因为占位符{}只有一个右括号}，左括号被转义成字符串的内容
    // println!(&quot;{{ Hello }&quot;);
}
</code></pre></pre>
<h2 id="总结-6"><a class="header" href="#总结-6">总结</a></h2>
<p>把这些格式化都牢记在脑中是不太现实的，也没必要，我们要做的就是知道Rust支持相应的格式化输出，在需要之时，读者再来查阅本文即可。</p>
<p>还是那句话，<a href="https://github.com/sunface/rust-course">&lt;&lt;Rust语言圣经&gt;&gt;</a>不仅仅是Rust学习书籍，还是一本厚重的工具书！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="智能指针"><a class="header" href="#智能指针">智能指针</a></h1>
<p>在各个编程语言中，指针的概念几乎都是相同的：<strong>指针是一个包含了内存地址的变量，该内存地址引用或者指向了另外的数据</strong>。</p>
<p>在Rust中，最常见的指针类型是引用，引用通过<code>&amp;</code>符号表示。不同于其它语言，引用在Rust中被赋予了更深层次的含义那就是：借用了其它变量的值。引用本身很简单，除了指向某个值外并没有其它的功能，也不会造成性能上的额外损耗，因此是Rust中使用最多的指针类型。</p>
<p>而智能指针则不然，它虽然也号称指针，但是它是一个复杂的家伙：通过比引用更复杂的数据结构，包含比引用更多的信息，例如元数据，当前长度，最大可用长度等。总之，Rust的智能指针并不是独创，在C++或者其他语言中也存在相似的概念。</p>
<p>Rust标准库中定义的那些智能指针，虽重但强，可以提供比引用更多的功能特性，例如本章将讨论的引用计数智能指针。该智能指针允许你同时拥有同一个数据的多个所有权，它会跟踪每一个所有者并进行计数，当所有的所有者都归还后，该智能指针及指向的数据将自动被清理释放。</p>
<p>引用和智能指针的另一个不同在于前者仅仅是借用了数据，而后者往往可以拥有它们指向的数据，然后再为其它人提供服务。</p>
<p>在之前的章节中，实际上我们已经见识过多种智能指针，例如动态字符串<code>String</code>和动态数组<code>Vec</code>，它们的数据结构中不仅仅包含了指向底层数据的指针，还包含了当前长度、最大长度等信息，其中<code>String</code>智能指针还提供了一种担保信息：所有的数据都是合法的<code>UTF-8</code>格式。</p>
<p>智能指针往往是基于结构体实现，它与我们自定义的结构体最大的区别在于它实现了<code>Deref</code>和<code>Drop</code>特征：</p>
<ul>
<li><code>Deref</code>可以让智能指针像引用那样工作，这样你就就可以写出同时支持智能指针和引用的代码, 例如<code>&amp;T</code></li>
<li><code>Drop</code>允许你指定智能指针超出作用域后自动执行的代码，例如做一些数据清除等收尾工作</li>
</ul>
<p>鉴于智能指针在Rust中很常见，因此我们在本章不会全部讲解，而是挑选几个最常用、最有代表性的进行讲解：</p>
<ul>
<li><code>Box&lt;T&gt;</code>， 可以将值分配到堆上</li>
<li><code>Rc&lt;T&gt;</code>, 引用计数类型，允许多所有权存在</li>
<li><code>Ref&lt;T&gt;</code>和<code>RefMut&lt;T&gt;</code>, 允许将借用规则检查从编译期移动到运行期进行</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boxt堆对象分配"><a class="header" href="#boxt堆对象分配"><code>Box&lt;T&gt;</code>堆对象分配</a></h1>
<p>关于作者帅不帅，估计争议还挺多的，但是如果说<code>Box&lt;T&gt;</code>是不是Rust中最常见的智能指针，那估计没有任何争议。因为<code>Box&lt;T&gt;</code>允许你将一个值分配到堆上，然后在栈上保留一个智能指针指向堆上的数据。</p>
<p>之前我们在<a href="https://course.rs/basic/ownership/ownership.html#%E6%A0%88stack%E4%B8%8E%E5%A0%86heap">所有权章节</a>简单讲过堆栈的概念，这里再补充一些。</p>
<h2 id="rust中的堆栈"><a class="header" href="#rust中的堆栈">Rust中的堆栈</a></h2>
<p>高级语言Python/Java等往往会弱化堆栈的概念，但是要用好C/C++/Rust，就必须对堆栈有深入的了解，原因是两者的内存管理方式不同: 前者有GC垃圾回收机制， 因此无需你去关心内存的细节。</p>
<p>栈内存从高位地址向下增长，且栈内存是连续分配的，一般来说<strong>操作系统对栈内存的大小都有限制</strong>，因此C语言中无法创建任意长度的数组。在Rust中, <code>main</code>线程的<a href="https://course.rs/pitfalls/stack-overflow.html">栈大小是<code>8MB</code></a>，普通线程是<code>2MB</code>，在函数调用时会在其中创建一个临时栈空间，调用结束后Rust会让这个栈空间里的对象自动进入<code>Drop</code>流程，最后栈顶指针自动移动到上一个调用栈顶，无需程序员手动干预，因而栈内存申请和释放是非常高效的。</p>
<p>与栈相反，堆上内存则是从低位地址向上增长，<strong>堆内存通常只受物理内存限制</strong>，而且通常是不连续的, 因此从性能的角度看，栈往往比对堆更高。</p>
<p>相比其它语言，Rust堆上对象还有一个特殊之处，它们都拥有一个所有者，因此受所有权规则的限制：当赋值时，发生的是所有权的转移(只需浅拷贝栈上的引用或智能指针即可)， 例如以下代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let b = foo(&quot;world&quot;);
    println!(&quot;{}&quot;, b);
}

fn foo(x: &amp;str) -&gt; String {
    let a = &quot;Hello, &quot;.to_string() + x;
    a
}
</code></pre></pre>
<p>在<code>foo</code>函数中，<code>a</code>是<code>String</code>类型，它其实是一个智能指针结构体，该智能指针存储在函数栈中，指向堆上的字符串数据。当被从<code>foo</code>函数转移给<code>main</code>中的<code>b</code>变量时，栈上的智能指针被复制一份赋予给<code>b</code>，而底层数据无需发生改变，这样就完成了所有权从<code>foo</code>函数内部到<code>b</code>的转移.</p>
<h4 id="堆栈的性能"><a class="header" href="#堆栈的性能">堆栈的性能</a></h4>
<p>很多人可能会觉得栈的性能肯定比堆高，其实未必。 由于我们在后面的性能专题会专门讲解堆栈的性能问题，因此这里就大概给出结论:</p>
<ul>
<li>小型数据，在栈上的分配性能和读取性能都要比堆上高</li>
<li>中型数据，栈上分配性能高，但是读取性能和堆上并无区别，因为无法利用寄存器或CPU高速缓存，最终还是要经过一次内存寻址</li>
<li>大型数据，只建议在堆上分配和使用</li>
</ul>
<p>总之栈的分配速度肯定比堆上快，但是读取速度往往取决于你的数据能不能放入寄存器或CPU高速缓存。 因此不要仅仅因为堆上性能不如栈这个印象，就总是优先选择栈，导致代码更复杂的实现。</p>
<h2 id="box的使用场景"><a class="header" href="#box的使用场景">Box的使用场景</a></h2>
<p>由于<code>Box</code>是简单的封装，除了将值存储在堆上外，并没有其它性能上的损耗。而性能和功能往往是鱼和熊掌，因此<code>Box</code>相比其它智能指针，功能较为单一，可以在以下场景中使用它:</p>
<ul>
<li>特意的将数据分配在堆上</li>
<li>数据较大时，又不想在转移所有权时进行数据拷贝</li>
<li>类型的大小在编译期无法确定，但是我们又需要固定大小的类型时</li>
<li>特征对象，用于说明对象实现了一个特征，而不是某个特定的类型</li>
</ul>
<p>以上场景，我们在本章将一一讲解，后面车速较快，请系好安全带。</p>
<h4 id="使用boxt将数据存储在堆上"><a class="header" href="#使用boxt将数据存储在堆上">使用<code>Box&lt;T&gt;</code>将数据存储在堆上</a></h4>
<p>如果一个变量拥有一个数值<code>let a = 3</code>, 那变量<code>a</code>必然是存储在栈上的，那如果我们想要<code>a</code>的值存储在堆上就需要使用<code>Box&lt;T&gt;</code>: </p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = Box::new(3);
    println!(&quot;a = {}&quot;, a); // a = 3
    
    // 下面一行代码将报错
    // let b = a + 1; // cannot add `{integer}` to `Box&lt;{integer}&gt;`
}
</code></pre></pre>
<p>这样就可以创建一个智能指针指向了存储在堆上的<code>3</code>，并且<code>a</code>持有了该指针。在本章的引言中，我们提到了智能指针往往都实现了<code>Deref</code>和<code>Drop</code>特征，因此：</p>
<ul>
<li><code>println!</code>可以正常打印出<code>a</code>的值，是因为它隐式的调用了<code>Deref</code>对智能指针<code>a</code>进行了解引用</li>
<li>最后一行代码<code>let b = a + 1</code>报错，是因为在表达式中，我们无法自动隐式的执行<code>Deref</code>解引用操作, 你需要使用<code>*</code>操作符<code>let b = *a + 1</code>，来显式的进行解引用</li>
<li><code>a</code>持有的智能指针将在作用结束(<code>main</code>函数结束)时，被释放掉，这是因为<code>Box&lt;T&gt;</code>实现了<code>Drop</code>特征</li>
</ul>
<p>以上的例子在实际代码中其实很少会存在，因为将一个简单的值分配到堆上并没有太大的意义。将其分配在栈上，由于寄存器、CPU缓存的原因，它的性能将更好，而且代码可读性也更好。</p>
<h4 id="避免栈上数据的拷贝"><a class="header" href="#避免栈上数据的拷贝">避免栈上数据的拷贝</a></h4>
<p>当栈上数据转移所有权时，实际上是把数据拷贝了一份，最终新旧变量各自拥有不同的数据，因此所有权并未转移。</p>
<p>而堆上则不然，底层数据并不会被拷贝，转移所有权仅仅是复制一份栈中的指针，再将新的指针赋予新的变量，然后让拥有旧指针的变量失效，最终完成了所有权的转移:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // 在栈上创建一个长度为1000的数组
    let arr = [0;1000];
    // 将arr所有权转移arr1，由于`arr`分配在栈上，因此这里实际上是直接重新深拷贝了一份数据
    let arr1 = arr;

    // arr和arr1都拥有各自的栈上数组，因此不会报错
    println!(&quot;{:?}&quot;,arr.len());
    println!(&quot;{:?}&quot;,arr1.len());

    // 在堆上创建一个长度为1000的数组，然后使用一个智能指针指向它
    let arr = Box::new([0;1000]);
    // 将堆上数组的所有权转移给arr1, 由于数据在堆上，因此仅仅拷贝了智能指针的结构体，底层数据并没有被拷贝
    // 所有权顺利转移给arr1，arr不再拥有所有权
    let arr1 = arr;
    println!(&quot;{:?}&quot;,arr1.len());
    // 由于arr不再拥有底层数组的所有权，因此下面代码将报错
    // println!(&quot;{:?}&quot;,arr.len());
}
</code></pre></pre>
<p>从以上代码，可以清晰看出大块的数据为何应该放入堆中，此时<code>Box</code>就成为了我们最好的帮手.</p>
<h4 id="将动态大小类型变为sized固定大小类型"><a class="header" href="#将动态大小类型变为sized固定大小类型">将动态大小类型变为Sized固定大小类型</a></h4>
<p>Rust需要在编译时知道类型占用多少空间, 如果一种类型在编译时无法知道具体的大小，那么被称为动态大小类型DST。</p>
<p>其中一种无法在编译时知道大小的类型是<strong>递归类型</strong>：在类型定义中又使用到了自身，或者说该类型的值的一部分可以是相同类型的其它值，这种值的嵌套理论上可以无限进行下去，所以Rust不知道递归类型需要多少空间:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">}
</span></code></pre></pre>
<p>以上就是函数式语言中常见的<code>Cons List</code>，它的每个节点包含一个<code>i32</code>值，还包含了一个新的<code>List</code>，因此这种嵌套可以无限进行下去，然后Rust认为该类型是一个DST类型，并给予报错:</p>
<pre><code class="language-console">error[E0072]: recursive type `List` has infinite size //递归类型`List`拥有无限长的大小
 --&gt; src/main.rs:3:1
  |
3 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
4 |     Cons(i32, List),
  |               ---- recursive without indirection
</code></pre>
<p>此时若想解决这个问题，就可以使用我们的<code>Box&lt;T&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}
<span class="boring">}
</span></code></pre></pre>
<p>只需要将<code>List</code>存储到堆上，然后使用一个智能指针指向它，即可完成从DST到Sized类型(固定大小类型)的华丽转变.</p>
<h4 id="特征对象-1"><a class="header" href="#特征对象-1">特征对象</a></h4>
<p>在Rust中，想实现不同类型组成的数组只有两个办法：枚举和特征对象，前者限制较多，因此后者往往是最常用的解决办法。</p>
<pre><pre class="playground"><code class="language-rust edition2021">trait Draw {
    fn draw(&amp;self);
}

struct Button {
    id: u32
}
impl Draw for Button {
    fn draw(&amp;self) {
        println!(&quot;这是屏幕上第{}号按钮&quot;,self.id)
    }
}

struct Select {
    id: u32
}

impl Draw for Select {
    fn draw(&amp;self) {
        println!(&quot;这个选择框贼难用{}&quot;,self.id)
    }
}

fn main() {
    let elems: Vec&lt;Box&lt;dyn Draw&gt;&gt; = vec![
        Box::new(Button{id: 1}),
        Box::new(Select{id: 2})
    ];

    for e in elems {
        e.draw()
    }
}
</code></pre></pre>
<p>以上代码将不同类型的<code>Button</code>和<code>Select</code>包装成<code>Draw</code>特征的特征对象，放入一个数组中，<code>Box&lt;dyn Draw&gt;</code>就是特征对象。</p>
<p>其实，特征也是DST类型，而特征对象在做的也是将DST类型转换为固定大小类型。</p>
<h2 id="box内存布局"><a class="header" href="#box内存布局">Box内存布局</a></h2>
<p>先来看看<code>Vec&lt;i32&gt;</code>的内存布局:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(stack)    (heap)
┌──────┐   ┌───┐
│ vec1 │──→│ 1 │
└──────┘   ├───┤
           │ 2 │
           ├───┤
           │ 3 │
           ├───┤
           │ 4 │
           └───┘
<span class="boring">}
</span></code></pre></pre>
<p>之前提到过<code>Vec</code>和<code>String</code>都是智能指针，从上图可以看出，该智能指针存储在栈中，然后指向堆上的数组数据。</p>
<p>那如果数组中每个元素都是一个<code>Box</code>对象呢？来看看<code>Vec&lt;Box&lt;i32&gt;&gt;</code>的内存布局:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(stack)    (heap)   ┌───┐
┌──────┐   ┌───┐ ┌─→│ 1 │
│ vec2 │──→│B1 │─┘  └───┘
└──────┘   ├───┤    ┌───┐
           │B2 │───→│ 2 │
           ├───┤    └───┘
           │B3 │─┐  ┌───┐
           ├───┤ └─→│ 3 │
           │B4 │─┐  └───┘
           └───┘ │  ┌───┐
                 └─→│ 4 │
                    └───┘
<span class="boring">}
</span></code></pre></pre>
<p>上面的<code>B1</code>代表被<code>Box</code>分配到堆上的值<code>1</code>。</p>
<p>可以看出智能指针<code>vec2</code>依然是存储在栈上，然后指针指向一个堆上的数组，该数组中每个元素都是一个<code>Box</code>智能指针，最终<code>Box</code>智能指针又指向了存储在堆上的实际值。</p>
<p>因此当我们从数组中取出某个元素时，取到的是对应的智能指针<code>Box</code>，需要对该智能指针进行解引用，才能取出最终的值:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let arr = vec![Box::new(1), Box::new(2)];
    let (first,second) = (&amp;arr[0],&amp;arr[1]);
    let sum = **first + **second;
}
</code></pre></pre>
<p>以上代码有几个值得注意的点:</p>
<ul>
<li>使用<code>&amp;</code>借用数组中的元素，否则会报所有权错误</li>
<li>表达式不能隐式的解引用，因此必须使用<code>**</code>做两次解引用，第一次将<code>&amp;Box&lt;i32&gt;</code>类型转成<code>Box&lt;i32&gt;</code>，第二次将<code>Box&lt;i32&gt;</code>转成<code>i32</code></li>
</ul>
<h2 id="boxleak"><a class="header" href="#boxleak">Box::leak</a></h2>
<p><code>Box</code>中还提供了一个非常有用的关联函数：<code>Box::leak</code>，它可以消费掉<code>Box</code>并且强制目标值从内存中泄漏，读者可能会觉得，这有啥用啊？</p>
<p>其实还真有点用，例如，你可以把一个<code>String</code>类型，变成一个<code>'static</code>生命周期的<code>&amp;str</code>类型: </p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let s = gen_static_str();
   println!(&quot;{}&quot;,s);
}

fn gen_static_str() -&gt; &amp;'static str{
    let mut s = String::new();
    s.push_str(&quot;hello, world&quot;);

    Box::leak(s.into_boxed_str())
}
</code></pre></pre>
<p>在之前的代码中，如果<code>String</code>创建于函数中，那么返回它的唯一方法就是转移所有权给调用者<code>fn move_str() -&gt; String</code>，而通过<code>Box::leak</code>我们不仅返回了一个<code>&amp;str</code>字符串切片，它还是<code>'static</code>类型的！</p>
<p>要知道真正具有<code>'static</code>生命周期的往往都是编译期就创建的值，例如<code>let v = &quot;hello,world&quot;</code>, 这里<code>v</code>是直接打包到二进制可执行文件中的，因此该字符串具有<code>'static</code>生命周期，再比如<code>const</code>常量。</p>
<p>又有读者要问了，我还可以手动为变量标注<code>'static</code>啊。其实你标注的<code>'static</code>只是用来忽悠编译器的，但是超出作用域，一样被释放回收。而使用<code>Box::leak</code>就可以将一个运行期的值转为<code>'static</code>。</p>
<h4 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h4>
<p>光看上面的描述，大家可能还是云里雾里、一头雾水。</p>
<p>那么我说一个简单的场景，<strong>你需要一个在运行期初始化的值，但是可以全局有效，也就是和整个程序活得一样久</strong>, 那么久可以使用<code>Box::leak</code>，例如有一个存储配置的结构体实例，它是在运行期动态插入内容，那么就可以将其转为全局有效，虽然<code>Rc/Arc</code>也可以实现此功能，但是<code>Box::leak</code>是性能最高的。</p>
<h2 id="总结-7"><a class="header" href="#总结-7">总结</a></h2>
<p><code>Box</code>背后是调用<code>jemalloc</code>来做内存管理，所以堆上的空间无需我们的手动管理。与此类似，带GC的语言中的对象也是借助于box概念来实现的，一切皆对象 = 一切皆box， 只不过我们无需自己去box罢了。</p>
<p>其实很多时候，编译器的鞭笞可以助我们更快的成长，例如所有权规则里的借用、move、生命周期就是编译器在教我们做人，哦不是，是教我们深刻理解堆栈、内存布局、作用域等你在其它GC语言无需去关注的东西。刚开始是很痛苦，但是一旦熟悉了这套规则，写代码的效率和代码本身的质量将飞速上升，直到你用Java开发的效率写出Java代码不可企及的性能和安全性，最终Rust语言所谓的开发效率低、心智负担高，对你来说终究不是个事。</p>
<p>因此,不要怪Rust，<strong>它只是在帮我们成为那个更好的程序员，而这些苦难终究成为我们走向优秀的垫脚石</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deref解引用"><a class="header" href="#deref解引用">Deref解引用</a></h1>
<p>何为智能指针？能不让你写出&amp;&amp;&amp;&amp;&amp;&amp;s形式的解引用，我认为就是智能: )  智能指针的名称来源，主要就在于它实现了<code>Deref</code>和<code>Drop</code>特征，这两个特征可以智能地帮助我们节省使用上的负担:</p>
<ul>
<li><code>Deref</code>可以让智能指针像引用那样工作，这样你就就可以写出同时支持智能指针和引用的代码, 例如<code>&amp;T</code></li>
<li><code>Drop</code>允许你指定智能指针超出作用域后自动执行的代码，例如做一些数据清除等收尾工作</li>
</ul>
<p>下面先来看看<code>Deref</code>特征是如何工作的。</p>
<h2 id="通过获取引用背后的值"><a class="header" href="#通过获取引用背后的值">通过<code>*</code>获取引用背后的值</a></h2>
<p>在正式讲解<code>Deref</code>之前，我们先来看下常规引用的解引用。</p>
<p>常规引用是一个指针类型，包含了目标数据存储的内存地址。对常规引用使用<code>*</code>操作符，就可以通过解引用的方式获取到内存地址对应的数据值:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p>这里<code>y</code>就是一个常规引用，包含了值<code>5</code>所在的内存地址, 然后通过解引用<code>*y</code>，我们获取到了值<code>5</code>。如果你试图执行<code>assert_eq!(5, y);</code>,代码就会无情报错，因为你无法将一个引用与一个数值做比较:</p>
<pre><code class="language-console">error[E0277]: can't compare `{integer}` with `&amp;{integer}` //无法将{integer} 与&amp;{integer}进行比较
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}` 
                    // 你需要为{integer}实现用于比较的特征PartialEq&lt;&amp;{integer}&gt;
</code></pre>
<h2 id="智能指针解引用"><a class="header" href="#智能指针解引用">智能指针解引用</a></h2>
<p>上面所说的解引用方式和其它大多数语言并无区别，但是Rust中将解引用提升到了一个新高度。考虑一下智能指针，它是一个结构体类型，如果你直接对它进行<code>*myStruct</code>，显然编译器不知道该如何办，因此我们可以为智能指针结构体实现<code>Deref</code>特征。</p>
<p>实现<code>Deref</code>后的智能指针结构体，就可以像普通引用一样，通过<code>*</code>进行解引用，例如<code>Box&lt;T&gt;</code>智能指针:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = Box::new(1);
    let sum = *x + 1;
}
</code></pre></pre>
<p>智能指针<code>x</code>被<code>*</code>解引用为<code>i32</code>类型的值<code>1</code>，然后再进行求和。</p>
<h4 id="定义自己的智能指针"><a class="header" href="#定义自己的智能指针">定义自己的智能指针</a></h4>
<p>现在，让我们一起来实现一个智能指针，功能上类似<code>Box&lt;T&gt;</code>。由于<code>Box&lt;T&gt;</code>本身很简单，并没有包含类如长度、最大长度等信息，因此用一个元组结构体即可。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>跟<code>Box&lt;T&gt;</code>一样，我们的智能指针也持有一个<code>T</code>类型的值，然后使用关联函数<code>MyBox::new</code>来创建智能指针。由于还未实现<code>Deref</code>特征，此时使用<code>*</code>肯定会报错:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let y = MyBox::new(5);

    assert_eq!(5, *y);
}
</code></pre></pre>
<p>运行后，报错如下：</p>
<pre><code class="language-console">error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:12:19
   |
12 |     assert_eq!(5, *y);
   |                   ^^
</code></pre>
<h5 id="为智能指针实现deref特征"><a class="header" href="#为智能指针实现deref特征">为智能指针实现Deref特征</a></h5>
<p>现在来为<code>MyBox</code>实现<code>Deref</code>特征, 以支持<code>*</code>解引用操作符:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>很简单，当解引用<code>MyBox</code>智能指针时，返回元组结构体中的元素<code>&amp;self.0</code>, 有几点要注意的：</p>
<ul>
<li>为了可读性, 我们声明了关联类型<code>Target</code></li>
<li><code>deref</code>返回的是一个常规引用，可以被<code>*</code>进行解引用</li>
</ul>
<p>之前报错的代码此时已能顺利编译通过。当然，标准库实现的智能指针要考虑很多边边角角情况，肯定比我们的实现要复杂。</p>
<h2 id="背后的原理"><a class="header" href="#背后的原理"><code>*</code>背后的原理</a></h2>
<p>当我们对智能指针<code>Box</code>进行解引用时, 实际上Rust为我们调用了以下方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>*(y.deref())
<span class="boring">}
</span></code></pre></pre>
<p>首先调用<code>deref</code>方法返回值的常规引用，然后通过<code>*</code>对常规引用进行解引用，最终获取到目标值。</p>
<p>至于Rust为何要使用这个有点啰嗦的方式实现，原因是因为所有权系统的存在。如果<code>deref</code>方法直接返回一个值，而不是引用，那么该值的所有权将被转移给调用者，而我们不希望调用者仅仅只是<code>*T</code>一下，就拿走了智能指针中包含的值。</p>
<p>需要注意的是，<code>*</code>不会无限递归替换，从<code>*y</code>到<code>*(y.deref())</code>只会发生一次，而不会继续进行替换然后产生形如<code>*((y.deref()).deref())</code>的怪物。</p>
<h2 id="函数和方法中的隐式deref转换"><a class="header" href="#函数和方法中的隐式deref转换">函数和方法中的隐式Deref转换</a></h2>
<p>在函数和方法中，Rust提供了一个极其有用的隐式转换：<code>Deref</code>转换。简单来说，当一个实现了<code>Deref</code>特征的值被传给函数或方法时，会根据函数参数的要求，来决定使用该值原本的类型还是<code>Deref</code>后的类型，例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = String::from(&quot;hello world&quot;);
    display(&amp;s)
}

fn display(s: &amp;str) {
    println!(&quot;{}&quot;,s);
}
</code></pre></pre>
<p>以上代码有几点值得注意：</p>
<ul>
<li><code>String</code>实现了<code>Deref</code>特征，能被转换成一个<code>&amp;str</code></li>
<li><code>s</code>是一个<code>String</code>类型，当它被传给<code>display</code>函数时，自动通过<code>Deref</code>转换成了<code>&amp;str</code></li>
<li>必须使用<code>&amp;s</code>的方式来触发<code>Deref</code></li>
</ul>
<h4 id="连续的隐式deref转换"><a class="header" href="#连续的隐式deref转换">连续的隐式Deref转换</a></h4>
<p>如果你以为<code>Deref</code>仅仅这点作用，那就大错特错了。<code>Deref</code>可以支持连续的隐式转换，直到找到适合的形式为止:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = MyBox::new(String::from(&quot;hello world&quot;));
    display(&amp;s)
}

fn display(s: &amp;str) {
    println!(&quot;{}&quot;,s);
}
</code></pre></pre>
<p>这里我们使用了之前自定义的智能指针<code>MyBox</code>，并将其通过连续的隐式转换变成<code>&amp;str</code>类型：首先<code>MyBox</code>被<code>Deref</code>成<code>String</code>类型，结果并不能满足<code>display</code>函数参数的要求，编译器发现<code>String</code>还可以继续<code>Deref</code>成<code>&amp;str</code>，最终成功的匹配了函数参数。</p>
<p>想象一下，假如<code>Rust</code>没有提供这种隐式转换，我们该如何调用<code>display</code>函数？</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    display(&amp;(*m)[..]);
}
</code></pre></pre>
<p>结果不言而喻，肯定是<code>&amp;s</code>的方式优秀的多。总之，当参与其中的类型定义了<code>Deref</code>特征时，Rust会分析该类型并且连续使用<code>Deref</code>直到最终获得一个引用来匹配函数或者方法的参数类型，这种行为完全不会造成任何的性能损耗, 因为完全是在编译期完成。</p>
<p>但是<code>Deref</code>并不是没有缺点，缺点就是：如果你不知道某个类型实现了<code>Deref</code>特征，那么在看到某段代码时，并不能在第一时间反应过来该代码发生了隐式的<code>Deref</code>转换。事实上，不仅仅是<code>Deref</code>，在Rust中还有各种<code>From/Into</code>等等会给阅读代码带来一定负担的特征。还是那句话，一切选择都是权衡，有得必有失，得了代码的简洁性，往往就失去了可读性，Go语言就是一个刚好相反的例子。</p>
<p>再来看一下在方法、赋值中自动应用<code>Deref</code>的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = MyBox::new(String::from(&quot;hello, world&quot;));
    let s1: &amp;str = &amp;s;
    let s2: String = s.to_string();
}
</code></pre></pre>
<p>对于<code>s1</code>，我们通过两次<code>Deref</code>将<code>&amp;str</code>类型的值赋给了它；而对于<code>s2</code>，我们在其上直接调用方法<code>to_string</code>, 实际上<code>MyBox</code>根本没有没有实现该方法，能调用<code>to_string</code>，完全是因为编译器对<code>MyBox</code>应用了<code>Deref</code>的结果。</p>
<h2 id="deref规则总结"><a class="header" href="#deref规则总结">Deref规则总结</a></h2>
<p>在上面，我们零碎的介绍了不少关于<code>Deref</code>特征的知识，下面来通过较为正式的方式来对其规则进行下总结。</p>
<p>一个类型为<code>T</code>的对象<code>foo</code>，如果<code>T: Deref&lt;Target=U&gt;</code>，那么，相关<code>foo</code>的引用<code>&amp;foo</code>在应用的时候会自动转换为<code>&amp;U</code>。</p>
<p>粗看这条规则，貌似有点类似于<code>AsRef</code>，而跟<code>解引用</code>似乎风马牛不相及, 实际里面有些玄妙之处。</p>
<h4 id="引用归一化"><a class="header" href="#引用归一化">引用归一化</a></h4>
<p>Rust编译器实际上只能对 <code>&amp;v</code> 形式的引用进行解引用操作，那么问题来了，如果是一个智能指针或者 <code>&amp;&amp;&amp;&amp;v</code> 类型的呢？ 该如何对这两个进行解引用？</p>
<p>答案是：Rust 会在解引用时自动把智能指针和 <code>&amp;&amp;&amp;&amp;v</code> 做引用归一化操作，转换成 <code>&amp;v</code> 形式，最终再对 <code>&amp;v</code> 进行解引用:</p>
<ul>
<li>把智能指针（比如在库中定义的，Box, Rc, Arc, Cow 等）从结构体脱壳为内部的引用类型，也就是转成结构体内部的<code>&amp;v</code></li>
<li>把多重<code>&amp;</code> ,例如 <code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;v</code>，归一成<code>&amp;v</code></li>
</ul>
<p>关于第二种情况，这么干巴巴的说，也许大家会迷迷糊糊的，我们来看一段标准库源码:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: ?Sized&gt; Deref for &amp;T {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        *self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在这段源码中，<code>&amp;T</code> 被自动解引用为 <code>T</code> , 也就是 <code>&amp;T: Deref&lt;Target=T&gt;</code> 。 按照这个代码，<code>&amp;&amp;&amp;&amp;T</code> 会被自动解引用为 <code>&amp;&amp;&amp;T</code>, 然后再自动解引用为 <code>&amp;&amp;T</code>，以此类推， 直到最终变成 <code>&amp;T</code>。</p>
<p>PS: 以下是 <code>LLVM</code> 编译后的部分中间层代码： </p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 代码
let mut _2: &amp;i32;
let _3: &amp;&amp;&amp;&amp;i32;

bb0: {
    _2 = (*(*(*_3)))
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="几个例子"><a class="header" href="#几个例子">几个例子</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn foo(s: &amp;str) {}

    // 由于 String 实现了 Deref&lt;Target=str&gt;
    let owned = &quot;Hello&quot;.to_string();

    // 因此下面的函数可以正常运行:
    foo(&amp;owned);
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::rc::Rc;

    fn foo(s: &amp;str) {}

    // String 实现了 Deref&lt;Target=str&gt;
    let owned = &quot;Hello&quot;.to_string();
    // 且 Rc 智能指针可以被自动脱壳为内部的 `owned` 引用： &amp;String ，然后 &amp;String 再自动解引用为 &amp;str
    let counted = Rc::new(owned);

    // 因此下面的函数可以正常运行:
    foo(&amp;counted);
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct Foo;

    impl Foo {
        fn foo(&amp;self) { println!(&quot;Foo&quot;); }
    }

    let f = &amp;&amp;Foo;

    f.foo();
    (&amp;f).foo();
    (&amp;&amp;f).foo();
    (&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;f).foo();
<span class="boring">}
</span></code></pre></pre>
<h2 id="三种deref转换"><a class="header" href="#三种deref转换">三种Deref转换</a></h2>
<p>在之前，我们讲的都是不可变的<code>Deref</code>转换，实际上Rust还支持将一个可变的引用转换成另一个可变的引用以及将一个可变引用转换成不可变的引用，规则如下：</p>
<ul>
<li>当<code>T: Deref&lt;Target=U&gt;</code>，可以将<code>&amp;T</code>转换成<code>&amp;U</code>，也就是我们之前看到的例子</li>
<li>当<code>T: DerefMut&lt;Target=U&gt;</code>，可以将<code>&amp;mut T</code>转换成<code>&amp;mut U</code></li>
<li>当<code>T: Deref&lt;Target=U&gt;</code>，可以将<code>&amp;mut T</code>转换成<code>&amp;U</code></li>
</ul>
<p>来看一个关于<code>DerefMut</code>的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct MyBox&lt;T&gt; {
    v: T
}

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox{
            v: x
        }
    }
}

use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.v
    }
}

use std::ops::DerefMut;

impl&lt;T&gt; DerefMut for MyBox&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.v
    }
}

fn main() {
    let mut s = MyBox::new(String::from(&quot;hello, &quot;));
    display(&amp;mut s)
}

fn display(s: &amp;mut String) {
    s.push_str(&quot;world&quot;);
    println!(&quot;{}&quot;,s);
}
</code></pre></pre>
<p>以上代码有几点值得注意:</p>
<ul>
<li>要实现<code>DerefMut</code>必须要先实现<code>Deref</code>特征: <code>pub trait DerefMut: Deref</code></li>
<li><code>T: DerefMut&lt;Target=U&gt;</code>解读:将<code>&amp;mut T</code>类型通过<code>DerefMut</code>特征的方法转换为<code>&amp;mut U</code>类型，对应上例中，就是将<code>&amp;mut MyBox&lt;String&gt;</code>转换为<code>&amp;mut String</code></li>
</ul>
<p>对于上述三条规则中的第三条，它比另外两条稍微复杂了点：Rust可以把可变引用隐式的转换成不可变引用，但反之则不行。</p>
<p>如果从Rust的所有权和借用规则的角度考虑，当你拥有一个可变的引用，那该引用肯定是对应数据的唯一借用，那么此时将可变引用变成不可变引用并不会破坏借用规则；但是如果你拥有一个不可变引用，那同时可能还存在其它几个不可变的引用，如果此时将其中一个不可变引用转换成可变引用，就变成了可变引用与不可变引用的共存，最终破坏了借用规则。</p>
<h2 id="总结-8"><a class="header" href="#总结-8">总结</a></h2>
<p><code>Deref</code>可以说是Rust中最常见的隐式类型转换，而且它可以连续的实现如<code>Box&lt;String&gt; -&gt; String -&gt; &amp;str</code>的隐式转换，只要链条上的类型实现了<code>Deref</code>特征。</p>
<p>我们也可以为自己的类型实现<code>Deref</code>特征, 但是原则上来说，只应该为自定义的智能指针实现<code>Deref</code>。例如，虽然你可以为自己的自定义数组类型实现<code>Deref</code>以避免<code>myArr.0[0]</code>的使用形式，但是Rust官方并不推荐这么做，特别是在你开发三方库时。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drop释放资源"><a class="header" href="#drop释放资源">Drop释放资源</a></h1>
<p>在Rust中，我们之所以可以一拳打跑GC的同时一脚踢翻手动资源回收，主要就归功于<code>Drop</code>特征，同时它也是智能指针的必备特征之一。</p>
<h2 id="学习目标"><a class="header" href="#学习目标">学习目标</a></h2>
<p>如何自动和手动释放资源及执行指定的收尾工作</p>
<h2 id="rust中的资源回收"><a class="header" href="#rust中的资源回收">Rust中的资源回收</a></h2>
<p>在一些无GC语言中，程序员在一个变量无需再被使用时，需要手动释放它占用的内存资源，如果忘记了，那么就会发生内存泄漏，最终臭名昭著的<code>OOM</code>问题可能就会发生。</p>
<p>而在Rust中，你可以指定在一个变量超出作用域时，执行一段特定的代码，最终编译器将帮你自动插入这段收尾代码。这样，就无需在每一个使用该变量的地方，都写一段代码来进行收尾工作和资源释放。不禁让人感叹，Rust的大腿真粗，香！</p>
<p>没错，指定这样一段收尾工作靠的就是咱这章的主角 - <code>Drop</code>特征。</p>
<h2 id="一个不那么简单的drop例子"><a class="header" href="#一个不那么简单的drop例子">一个不那么简单的Drop例子</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">struct HasDrop1;
struct HasDrop2;
impl Drop for HasDrop1 {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping HasDrop1!&quot;);
    }
}
impl Drop for HasDrop2 {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping HasDrop2!&quot;);
    }
}
struct HasTwoDrops {
    one: HasDrop1,
    two: HasDrop2,
}
impl Drop for HasTwoDrops {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping HasTwoDrops!&quot;);
    }
}

struct Foo;

impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping Foo!&quot;)
    }
}


fn main() {
    let _x = HasTwoDrops {  two: HasDrop2 ,one: HasDrop1,};
    let _foo = Foo;
    println!(&quot;Running!&quot;);
}
</code></pre></pre>
<p>上面代码虽然长，但是目的其实很单纯，就是为了观察不同情况下的<code>Drop</code>，变量级别的、结构体内部字段的, 有几点值得注意：</p>
<ul>
<li><code>Drop</code>特征中的<code>drop</code>方法借用了目标的可变引用，而不是拿走了所有权，这里先设置一个悬念，后边会讲</li>
<li>结构体中每个字段都有自己的<code>Drop</code></li>
</ul>
<p>来看看输出:</p>
<pre><code class="language-console">Running!
Dropping Foo!
Dropping HasTwoDrops!
Dropping HasDrop1!
Dropping HasDrop2!
</code></pre>
<p>嗯，结果符合预期，每个资源都成功的执行了收尾工作，虽然<code>println!</code>这种收尾工作毫无意义 = , =</p>
<h4 id="drop的顺序"><a class="header" href="#drop的顺序">Drop的顺序</a></h4>
<p>观察以上输出，我们可以得出以下关于<code>Drop</code>顺序的结论</p>
<ul>
<li><strong>变量级别，按照逆序的方式</strong>,<code>_x</code>在<code>_foo</code>之前创建，因此<code>_x</code>在<code>_foo</code>之后被drop</li>
<li><strong>结构体内部，按照顺序的方式</strong>, 结构体<code>_x</code>中的字段按照定义中的顺序依次<code>drop</code></li>
</ul>
<h4 id="没有实现drop的结构体"><a class="header" href="#没有实现drop的结构体">没有实现Drop的结构体</a></h4>
<p>实际上，就算你不为<code>_x</code>结构体实现<code>Drop</code>特征，它内部的两个字段依然会调用<code>drop</code>，移除以下代码，并观察输出：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Drop for HasTwoDrops {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping HasTwoDrops!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>原因在于，Rust自动为几乎所有类型都实现了<code>Drop</code>特征，因此就算你不手动为结构体实现<code>Drop</code>，它依然会调用默认实现的<code>drop</code>函数，同时再调用每个字段的<code>drop</code>方法，最终打印出:</p>
<pre><code class="language-cnosole">Dropping HasDrop1!
Dropping HasDrop2!
</code></pre>
<h2 id="手动回收"><a class="header" href="#手动回收">手动回收</a></h2>
<p>当使用智能指针来管理锁的时候，你可能希望提前释放这个锁，然后让其它代码能及时获得锁，此时就需要提前去手动<code>drop</code>。
但是在之前我们提到一个悬念，就是<code>Drop::drop</code>只是借用了目标值的可变引用，就算你提前调用了该方法，但是后面的代码依然可以使用目标值，这就会访问一个并不存在的值，非常不安全，好在Rust会阻止你：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Foo;

impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping Foo!&quot;)
    }
}

fn main() {
    let foo = Foo;
    foo.drop();
    println!(&quot;Running!:{:?}&quot;, foo);
}
</code></pre></pre>
<p>报错如下：</p>
<pre><code class="language-console">error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:37:9
   |
37 |     foo.drop();
   |     ----^^^^--
   |     |   |
   |     |   explicit destructor calls not allowed
   |     help: consider using `drop` function: `drop(foo)`
</code></pre>
<p>如上所示，编译器直接阻止了我们调用<code>Drop</code>特征的<code>drop</code>方法，原因是该方法是析构函数，这是一个用来清理实例的通用编程概念，对于Rust而言，不允许显式的调用析构函数。好在在报错的同时，编译器还给出了一个提示：使用<code>drop</code>函数。</p>
<p>针对编译器提示的<code>drop</code>函数，我们可以大胆推测下：它能够拿走目标值的所有权。现在来看看这个猜测正确与否，以下是<code>std::mem::drop</code>函数的签名：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn drop&lt;T&gt;(_x: T)
<span class="boring">}
</span></code></pre></pre>
<p>如上所示，<code>drop</code>函数确实拿走了目标值的所有权，来验证下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let foo = Foo;
    drop(foo);
    // 以下代码会报错：借用了所有权被转移的值
    // println!(&quot;Running!:{:?}&quot;, foo);
}
</code></pre></pre>
<p>Bingo，完美拿走了所有权，而且这种实现保证了后续的使用必定会导致编译错误，因此非常安全！</p>
<p>细心的同学可能已经注意到，这里直接调用了<code>drop</code>函数，并没有引入任何模块信息，原因是该函数在<a href="advance/smart-pointer/../../appendix/prelude.html"><code>std::prelude</code></a>里。</p>
<h2 id="drop使用场景"><a class="header" href="#drop使用场景">Drop使用场景</a></h2>
<p>对于Drop而言，主要有两个功能：</p>
<ul>
<li>回收内存资源</li>
<li>执行一些收尾工作</li>
</ul>
<p>对于第二点，在之前我们已经详细介绍过，因此这里主要对第一点进行下简单说明。</p>
<p>在绝大多数情况下，我们都无需手动去<code>drop</code>以回收内存资源，因为Rust会自动帮我们完成这些工作，它甚至会对复杂类型的每个字段都单独的调用<code>drop</code>进行回收！但是确实有极少数情况，需要你自己来回收资源的，例如文件描述符、网络socket等，当这些值超出作用域不再使用时，就需要进行关闭以释放相关的资源，在这些情况下，就需要使用者自己来解决<code>Drop</code>的问题。</p>
<h2 id="互斥的copy和drop"><a class="header" href="#互斥的copy和drop">互斥的Copy和Drop</a></h2>
<p>我们无法为一个类型同时实现<code>Copy</code>和<code>Drop</code>特征。因为实现了<code>Copy</code>的特征会被编译器隐式的复制，因此非常难以预测析构函数执行的时间和频率。因此这些实现了<code>Copy</code>的类型无法拥有析构函数。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy)]
struct Foo;

impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping Foo!&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>以下代码报错如下:</p>
<pre><code class="language-console">error[E0184]: the trait `Copy` may not be implemented for this type; the type has a destructor
  --&gt; src/main.rs:24:10
   |
24 | #[derive(Copy)]
   |          ^^^^ Copy not allowed on types with destructors
</code></pre>
<h2 id="总结-9"><a class="header" href="#总结-9">总结</a></h2>
<p><code>Drop</code>可以用于许多方面，来使得资源清理及收尾工作变得方便和安全，甚至可以用其创建我们自己的内存分配器！通过<code>Drop</code>特征和 Rust 所有权系统，你无需担心之后的代码清理，Rust 会自动考虑这些问题。</p>
<p>我们也无需担心意外的清理掉仍在使用的值，这会造成编译器错误：所有权系统确保引用总是有效的，也会确保<code>drop</code>只会在值不再被使用时被调用一次。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rc与arc"><a class="header" href="#rc与arc">Rc与Arc</a></h1>
<p>Rust所有权机制要求一个值只能有一个所有者，在大多数情况下，都没有问题，但是考虑以下情况:</p>
<ul>
<li>在图数据结构中，多个边可能会拥有同一个节点，该节点直到没有边指向它时，才应该被释放清理</li>
<li>在多线程中，多个线程可能会持有同一个数据，但是你受限于Rust的安全机制，无法同时获取该数据的可变引用。</li>
</ul>
<p>以上场景不是很常见，但是一旦遇到，就非常棘手，为了解决此类问题，Rust在所有权机制之外又引入了额外的措施来简化相应的实现：通过引用计数的方式，允许一个数据资源在同一时刻拥有多个所有者。</p>
<p>这种实现机制就是<code>Rc</code>和<code>Arc</code>，前者适用于单线程，后者适用于多线程。由于二者大部分情况下都相同，因此本章将以<code>Rc</code>作为讲解主体，对于<code>Arc</code>的不同之处，另外进行单独讲解。</p>
<h2 id="rc"><a class="header" href="#rc">Rc<T></a></h2>
<p>引用计数(reference counting)，顾名思义，通过记录一个数据被引用的次数来确定该数据是否正在被使用。当引用次数归零时，就代表该数据不再被使用，因此可以被清理释放。</p>
<p>而<code>Rc</code>正是引用计数的英文缩写。当我们<strong>希望在堆上分配一个对象供程序的多个部分使用且无法确定哪个部分最后一个结束时，就可以使用<code>Rc</code>成为数据值的所有者</strong>，例如之前提到的多线程场景就非常适合。</p>
<p>下面是经典的所有权被转移导致报错的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = String::from(&quot;hello, world&quot;);
    // s在这里被转移给a
    let a = Box::new(s);
    // 报错！此处继续尝试将s转移给b
    let b = Box::new(s);     
}
</code></pre></pre>
<p>使用<code>Rc</code>就可以轻易解决：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::rc::Rc;
fn main() {
    let a = Rc::new(String::from(&quot;hello, world&quot;));
    let b = Rc::clone(&amp;a);

    assert_eq!(2, Rc::strong_count(&amp;a));
    assert_eq!(Rc::strong_count(&amp;a),Rc::strong_count(&amp;b))
}
</code></pre></pre>
<p>以上代码我们使用<code>Rc::new</code>创建了一个新的<code>Rc&lt;String&gt;</code>智能指针并赋给变量<code>a</code>，该指针指向底层的字符串数据。</p>
<p>智能指针<code>Rc&lt;T&gt;</code>在创建时，还会将引用计数加1，此时获取引用计数的关联函数<code>Rc::strong_count</code>返回的值将是<code>1</code>。</p>
<h4 id="rcclone"><a class="header" href="#rcclone">Rc::clone</a></h4>
<p>接着，我们又使用<code>Rc::clone</code>克隆了一份智能指针<code>Rc&lt;String&gt;</code>，并将该智能指针的引用计数增加到<code>2</code>。</p>
<p>由于<code>a</code>和<code>b</code>是同一个智能指针的两个副本，因此通过它们两个获取引用计数的结果都是<code>2</code>。</p>
<p>不要给<code>clone</code>字样所迷惑，以为所有的<code>clone</code>都是深拷贝。这里的<code>clone</code><strong>仅仅复制了智能指针并增加了引用计数，并没有克隆底层数据</strong>，因此<code>a</code>和<code>b</code>是共享了底层的字符串<code>s</code>，这种<strong>复制效率是非常高</strong>的。当然你也可以使用<code>a.clone()</code>的方式来克隆，但是从可读性角度，<code>Rc::clone</code>的方式我们更加推荐。</p>
<p>实际上Rust中，还有不少<code>clone</code>都是浅拷贝，例如<a href="https://course.rs/pitfalls/iterator-everywhere.html">迭代器的克隆</a>.</p>
<h4 id="观察引用计数的变化"><a class="header" href="#观察引用计数的变化">观察引用计数的变化</a></h4>
<p>使用关联函数<code>Rc::strong_count</code>可以获取当前引用计数的值，我们来观察下引用计数如何随着变量声明、释放而变化：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::rc::Rc;
fn main() {
        let a = Rc::new(String::from(&quot;test ref counting&quot;));
        println!(&quot;count after creating a = {}&quot;, Rc::strong_count(&amp;a));
        let b =  Rc::clone(&amp;a);
        println!(&quot;count after creating b = {}&quot;, Rc::strong_count(&amp;a));
        {
            let c =  Rc::clone(&amp;a);
            println!(&quot;count after creating c = {}&quot;, Rc::strong_count(&amp;c));
        }
        println!(&quot;count after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<p>有几点值得注意：</p>
<ul>
<li>由于变量<code>c</code>在语句块内部声明，当离开语句块时它会因为超出作用域而被释放，最终引用计数会减少1, 事实上这个得益于<code>Rc&lt;T&gt;</code>实现了<code>Drop</code>特征</li>
<li><code>a</code>,<code>b</code>,<code>c</code>三个智能指针引用计数都是同样的，并且共享底层的数据，因此打印计数时用哪个都行</li>
<li>无法看到的是: 当<code>a</code>、<code>b</code>超出作用域后，引用计数会变成0，最终智能指针和它指向的底层字符串都会被清理释放</li>
</ul>
<h4 id="不可变引用-1"><a class="header" href="#不可变引用-1">不可变引用</a></h4>
<p>事实上，<code>Rc&lt;T&gt;</code>是指向底层数据的不可变的引用，因此你无法通过它来修改数据，这也符合Rust的借用规则：要么多个不可变借用，要么一个可变借用。</p>
<p>但是可以修改数据也是非常有用的，只不过我们需要配合其它数据类型来一起使用，例如内部可变性的<code>RefCell&lt;T&gt;</code>类型以及互斥锁<code>Mutex&lt;T&gt;</code>。事实上，在多线程编程中，<code>Arc</code>跟<code>Mutext</code>锁的组合使用非常常见，它们既可以让我们在不同的线程中共享数据，又允许在各个线程中对其进行修改。</p>
<h4 id="一个综合例子-2"><a class="header" href="#一个综合例子-2">一个综合例子</a></h4>
<p>考虑一个场景，有很多小器具，里面每个器具都有自己的主人，但是存在多个器具属于同一个主人的情况，此时使用<code>Rc&lt;T&gt;</code>就非常适合:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::rc::Rc;

struct Owner {
    name: String,
    // ...其它字段
}

struct Gadget {
    id: i32,
    owner: Rc&lt;Owner&gt;,
    // ...其它字段
}

fn main() {
    // 创建一个基于引用计数的`Owner`.
    let gadget_owner: Rc&lt;Owner&gt; = Rc::new(
        Owner {
            name: &quot;Gadget Man&quot;.to_string(),
        }
    );

    // 创建两个不同的工具，它们属于同一个主人
    let gadget1 = Gadget {
        id: 1,
        owner: Rc::clone(&amp;gadget_owner),
    };
    let gadget2 = Gadget {
        id: 2,
        owner: Rc::clone(&amp;gadget_owner),
    };

    // 释放掉第一个`Rc&lt;Owner&gt;`
    drop(gadget_owner);

    // 尽管在之前我们释放了gadget_owner，但是依然可以在这里使用owner的信息
    // 原因是上面仅仅drop掉其中一个智能指针引用，而不是drop掉owner数据，外面还有两个引用指向底层的owner数据，引用计数尚未清零
    // 因此owner数据依然可以被使用
    println!(&quot;Gadget {} owned by {}&quot;, gadget1.id, gadget1.owner.name);
    println!(&quot;Gadget {} owned by {}&quot;, gadget2.id, gadget2.owner.name);

    // 在函数最后，`gadget1`和`gadget2`也被释放，最终引用计数归零，随后底层数据也被清理释放
}
</code></pre></pre>
<p>以上代码很好的展示了<code>Rc&lt;T&gt;</code>的用途，当然你也可以用借用的方式，但是实现起来就会复杂的多，而且随着<code>Gadget</code>在代码的各个地方使用，引用生命周期也将变得更加复杂，毕竟结构体中的引用类型，总是令人不那么愉快，对不？</p>
<h4 id="rc简单总结"><a class="header" href="#rc简单总结">Rc简单总结</a></h4>
<ul>
<li><code>Rc/Arc</code>是不可变引用，你无法修改它指向的值，只能进行读取, 如果要修改，需要配合后面章节的内部可变性<code>RefCell</code>或互斥锁<code>Mutex</code></li>
<li>一旦最后一个拥有者消失，则资源会自动被回收，这个生命周期是在编译期就确定下来的</li>
<li>Rc只能用于同一线程内部，想要用于线程之间的对象共享, 你需要使用<code>Arc</code></li>
<li><code>Rc&lt;T&gt;</code>是一个智能指针，实现了<code>Deref</code>特征，因此你无需先解开<code>Rc</code>指针，再使用里面的<code>T</code>，而是可以直接使用<code>T</code>, 例如上例中的<code>gadget1.owner.name</code></li>
</ul>
<h2 id="多线程无力的rc"><a class="header" href="#多线程无力的rc">多线程无力的Rc<T></a></h2>
<p>来看看在多线程场景使用<code>Rc&lt;T&gt;</code>会如何:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::rc::Rc;
use std::thread;

fn main() {
    let s = Rc::new(String::from(&quot;多线程漫游者&quot;));
    for _ in 0..10 {
        let s = Rc::clone(&amp;s);
        let handle = thread::spawn(move || {
           println!(&quot;{}&quot;,s)
        });
    }
}
</code></pre></pre>
<p>由于我们还没有学习多线程的章节，上面的例子就特地简化了相关的实现。首先通过<code>thread::spawn</code>创建一个线程，然后使用<code>move</code>关键字把克隆出的<code>s</code>的所有权转移到线程中。</p>
<p>能够实现这一点，完全得益于<code>Rc</code>带来的多所有权机制，但是以上代码会报错:</p>
<pre><code class="language-console">error[E0277]: `Rc&lt;String&gt;` cannot be sent between threads safely
</code></pre>
<p>表面原因是<code>Rc&lt;T&gt;</code>不能在线程间安全的传递，实际上是因为它没有实现<code>Send</code>特征，而该特征是恰恰是多线程间传递数据的关键，我们会在多线程章节中进行讲解。</p>
<p>当然，还有更深层的原因: 由于<code>Rc&lt;T&gt;</code>需要管理引用计数，但是该计数器并没有使用任何并发原语，因此无法实现原子化的计数操作, 最终会导致计数错误。</p>
<p>好在天无绝人之路，一起来看看Rust为我们提供的功能一致但是多线程安全的<code>Arc</code>。</p>
<h2 id="arc"><a class="header" href="#arc">Arc</a></h2>
<p><code>Arc</code>是<code>Atomic Rc</code>的缩写，顾名思义：原子化的<code>Rc&lt;T&gt;</code>智能指针。原子化是一种并发原语，我们在后续章节会进行深入讲解，这里你只要知道它能保证我们的数据能够安全的在线程间共享即可。</p>
<h4 id="arc的性能损耗"><a class="header" href="#arc的性能损耗">Arc的性能损耗</a></h4>
<p>你可能好奇，为何不直接使用<code>Arc</code>，还要画蛇添足弄一个<code>Rc</code>，还有Rust的基本数据类型、标准库数据类型为什么不自动实现原子化操作？</p>
<p>原因在于原子化或者其它锁带来的线程安全，都会伴随着性能损耗，而且这种性能损耗还不小，因此Rust把这种选择权交给你，毕竟需要线程安全的代码其实占比并不高，大部分时间我们都在跟线程内的代码执行打交道。</p>
<p><code>Arc</code>和<code>Rc</code>拥有完全一样的API，修改起来很简单:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::Arc;
use std::thread;

fn main() {
    let s = Arc::new(String::from(&quot;多线程漫游者&quot;));
    for _ in 0..10 {
        let s = Arc::clone(&amp;s);
        let handle = thread::spawn(move || {
           println!(&quot;{}&quot;,s)
        });
    }
}
</code></pre></pre>
<p>对了，两者还有一点区别: <code>Arc</code>和<code>Rc</code>并没有定义在同一个模块，前者通过<code>use std::sync::Arc</code>来引入，后者<code>use std::rc::Rc</code>.</p>
<h2 id="总结-10"><a class="header" href="#总结-10">总结</a></h2>
<p>在Rust中，所有权机制保证了一个数据只会有一个所有者，但如果你想要在图数据结构、多线程等场景中共享数据，这种机制会成为极大的阻碍。好在Rust为我们提供了智能指针<code>Rc</code>和<code>Arc</code>，使用它们就能实现多个所有者共享一个数据的功能。</p>
<p><code>Rc</code>和<code>Arc</code>的区别在于，后者是原子化实现的引用计数，因此是线程安全的，可以用于多线程中共享数据。</p>
<p>这两者都是只读的，如果想要实现内部数据可修改，必须配合内部可变性<code>RefCell</code>或者互斥锁<code>Mutex</code>来一起使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cell和refcell"><a class="header" href="#cell和refcell">Cell和RefCell</a></h1>
<p>Rust的编译器之严格，可以说是举世无双。特别是在所有权方面，Rust通过严格的规则来保证所有权和借用的正确性，最终为程序的安全保驾护航。</p>
<p>但是严格是一把双刃剑，带来安全提升的同时，损失了灵活性，有时甚至会让用户痛苦不堪、怨声载道。因此Rust提供了<code>Cell</code>和<code>RefCell</code>用于内部可变性, 简而言之，可以在拥有不可变引用的同时修改目标数据，对于正常的代码实现来说，这个是不可能做到的(要么一个可变借用，要么多个不可变借用).</p>
<blockquote>
<p>内部可变性的实现是因为Rust使用了<code>unsafe</code>来做到这一点，但是对于使用者来说，这些都是透明的，因为这些不安全代码都被封装到了安全的API中</p>
</blockquote>
<h2 id="cell"><a class="header" href="#cell">Cell</a></h2>
<p>Cell和RefCell在功能上没有区别，区别在于<code>Cell&lt;T&gt;</code>适用于<code>T</code>实现<code>Copy</code>的情况:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::Cell;
fn main() {
  let c = Cell::new(&quot;asdf&quot;);
  let one = c.get();
  c.set(&quot;qwer&quot;);
  let two = c.get();
  println!(&quot;{},{}&quot;, one,two);
}
</code></pre></pre>
<p>以上代码展示了<code>Cell</code>的基本用法，有几点值得注意:</p>
<ul>
<li>&quot;asdf&quot;是<code>&amp;str</code>类型，它实现了<code>Copy</code>特征</li>
<li><code>c.get</code>用来取值，<code>c.set</code>用来设置新值</li>
</ul>
<p>取到值保存在<code>one</code>变量后，还能同时进行修改，这个违背了Rust的借用规则，但是由于<code>Cell</code>的存在，我们很优雅的做到了这一点，但是如果你尝试在<code>Cell</code>中存放<code>String</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let c = Cell::new(String::from(&quot;asdf&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>编译器会立刻报错，因为<code>String</code>没有实现<code>Copy</code>特征:</p>
<pre><code class="language-console">| pub struct String {
| ----------------- doesn't satisfy `String: Copy`
|
= note: the following trait bounds were not satisfied:
        `String: Copy`
</code></pre>
<h2 id="refcell"><a class="header" href="#refcell">RefCell</a></h2>
<p>由于<code>Cell</code>类型针对的是实现了<code>Copy</code>特征的值类型，因此在实际开发中，<code>Cell</code>使用的并不多，因为我们要解决的往往是可变、不可变引用共存导致的问题，此时就需要借助于<code>RefCell</code>来达成目的。</p>
<p>我们可以将所有权、借用规则与这些智能指针做一个对比:</p>
<table><thead><tr><th>Rust规则</th><th>智能指针带来的额外规则</th></tr></thead><tbody>
<tr><td>一个数据只有一个所有者</td><td><code>Rc/Arc</code>让一个数据可以拥有多个所有者</td></tr>
<tr><td>要么多个不可变借用，要么一个可变借用</td><td><code>RefCell</code>实现编译期可变、不可变引用共存</td></tr>
<tr><td>违背规则导致<strong>编译错误</strong></td><td>违背规则导致<strong>运行时<code>panic</code></strong></td></tr>
</tbody></table>
<p>可以看出，<code>Rc/Arc</code>和<code>RefCell</code>合在一起，解决了Rust中严苛的所有权和借用规则带来的某些场景下难使用的问题。但是它们并不是银弹，例如<code>RefCell</code>实际上并没有解决可变引用和引用可以共存的问题，只是将报错从编译期推迟到运行时，从编译器错误变成了<code>panic</code>异常:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;

fn main() {
    let s = RefCell::new(String::from(&quot;hello, world&quot;));
    let s1 = s.borrow();
    let s2 = s.borrow_mut();

    println!(&quot;{},{}&quot;,s1,s2);
}
</code></pre></pre>
<p>上面代码在编译期不会报任何错误，你可以顺利运行程序：</p>
<pre><code class="language-console">thread 'main' panicked at 'already borrowed: BorrowMutError', src/main.rs:6:16
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>但是依然会因为违背了借用规则导致了运行期<code>panic</code>，这非常像中国的天网，它也许会被罪犯蒙蔽一时，但是并不会被蒙蔽一世，任何导致安全风险的存在都将不能被容忍，法网恢恢，疏而不漏。</p>
<h4 id="refcell为何存在"><a class="header" href="#refcell为何存在">RefCell为何存在</a></h4>
<p>相信肯定有读者有疑问了，这么做有任何意义吗？还不如在编译期报错，至少能提前发现问题，而且性能还更好。</p>
<p>存在即合理，究其根因，在于Rust编译期的<strong>宁可错杀，绝不放过</strong>的原则, 当编译器不能确定你的代码是否正确时，就统统会判定为错误，因此难免会导致一些误报。</p>
<p>而<code>RefCell</code>正是<strong>用于你确信代码是正确的，而编译器却发生了误判时</strong>。</p>
<p>对于大型的复杂程序，也可以选择使用<code>RefCell</code>来让事情简化。例如在Rust编译器的<a href="https://github.com/rust-lang/rust/blob/620d1ee5346bee10ba7ce129b2e20d6e59f0377d/src/librustc/middle/ty.rs#L803-L987"><code>ctxt结构体</code></a>中有大量的<code>RefCell</code>类型的<code>map</code>字段, 主要的原因是：这些<code>map</code>会被分散在各个地方的代码片段所广泛使用或修改。由于这种分散在各处的使用方式，导致了管理可变和不可变成为一件非常复杂的任务(甚至不可能)，你很容易就碰到编译器抛出来的各种错误。而且<code>RefCell</code>的运行时错误在这种情况下也变得非常可爱：一旦有人做了不正确的使用，代码会<code>panic</code>，然后告诉我们哪些借用冲突了。</p>
<p>总之，当你确信编译器误报但不知道该如何解决时，或者你有一个引用类型，需要被四处使用和修改然后导致借用关系难以管理时，都可以优先考虑使用<code>RefCell</code>。</p>
<h4 id="refcell简单总结"><a class="header" href="#refcell简单总结">RefCell简单总结</a></h4>
<ul>
<li>与Cell用于可Copy的值不同，RefCell用于引用</li>
<li>RefCell只是将借用规则从编译期推迟到程序运行期，并不能帮你绕过这个规则</li>
<li>RefCell适用于编译期误报或者一个引用被在多个代码中使用、修改以至于难于管理借用关系时</li>
<li>使用<code>RefCell</code>时，违背借用规则会导致运行期的<code>panic</code></li>
</ul>
<h2 id="选择cell还是refcell"><a class="header" href="#选择cell还是refcell">选择<code>Cell</code>还是<code>RefCell</code></a></h2>
<p>根据本文的内容，我们可以大概总结下两者的区别：</p>
<ul>
<li><code>Cell</code>只适用于<code>Copy</code>类型，用于提供值, 而<code>RefCell</code>用于提供引用</li>
<li><code>Cell</code>不会<code>panic</code>，而<code>RefCell</code>会</li>
</ul>
<h4 id="性能比较"><a class="header" href="#性能比较">性能比较</a></h4>
<p><code>Cell</code>没有额外的性能损耗，例如以下两段代码的性能其实是一致的:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// code snipet 1
let x = Cell::new(1);
let y = &amp;x;
let z = &amp;x;
x.set(2);
y.set(3);
z.set(4);
println!(&quot;{}&quot;, x.get());

// code snipet 2
let mut x = 1;
let y = &amp;mut x;
let z = &amp;mut x;
x = 2;
*y = 3;
*z = 4;
println!(&quot;{}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p>虽然性能一致，但代码<code>1</code>拥有代码<code>2</code>不具有的优势：它能编译成功:)</p>
<p>与<code>Cell</code>的<code>zero cost</code>不同，<code>RefCell</code>其实是有一点运行期开销的，原因是它包含了一个字大小的&quot;借用状态&quot;指示器，该指示器在每次运行时借用时都会被修改，进而产生一点开销。</p>
<p>总之，当非要使用内部可变性时，首选<code>Cell</code>，只有值拷贝的方式不能满足你时，才去选择<code>RefCell</code>。</p>
<h2 id="内部可变性"><a class="header" href="#内部可变性">内部可变性</a></h2>
<p>之前我们提到RefCell具有内部可变性，何为内部可变性？简单来说，对一个不可变的值进行可变借用，但这个并不符合Rust的基本借用规则：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre></pre>
<p>上面的代码会报错，因为我们不能对一个不可变的值进行可变借用，这会破坏Rust的安全性保证，相反，你可以对一个可变值进行不可变借用。原因是：当值不可变时，可能会有多个不可变的引用指向它，修改其中一个为可变的，会造成可变引用与不可变引用共存的情况；而当值可变时，只会有唯一一个可变引用指向它，将其修改为不可变，那么最终依然是只有一个不可变的引用指向它。</p>
<p>虽然基本借用规则是Rust的基石，然而在某些场景中，一个值可以在其方法内部被修改，同时对于其它代码不可变，是很有用的:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 定义在外部库中的特征
pub trait Messenger {
    fn send(&amp;self, msg: String);
}

// --------------------------
// 我们的代码中的数据结构和实现
struct MsgQueue {
    msg_cache: Vec&lt;String&gt;,  
}

impl Messenger for MsgQueue {
    fn send(&amp;self,msg: String) {
        self.msg_cache.push(msg)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如上所示，外部库中定义了一个消息发送器特征<code>Messenger</code>，它就一个功能用于发送消息: <code>fn send(&amp;self, msg: String)</code>，因为发送消息不需要修改自身，因此原作者在定义时，使用了<code>&amp;self</code>的不可变借用, 这个无可厚非。</p>
<p>但是问题来了，我们要在自己的代码中使用该特征实现一个异步消息队列，出于性能的考虑，消息先写到本地缓存(内存)中，然后批量发送出去，因此在<code>send</code>方法中，需要将消息先行插入到本地缓存<code>msg_cache</code>中。但是问题来了，该<code>send</code>方法的签名是<code>&amp;self</code>，因此上述代码会报错:</p>
<pre><code class="language-console">error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/main.rs:11:9
   |
2  |     fn send(&amp;self, msg: String);
   |             ----- help: consider changing that to be a mutable reference: `&amp;mut self`
...
11 |         self.sent_messages.push(msg)
   |         ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
</code></pre>
<p>在报错的同时，编译器大聪明还善意的给出了提示：将<code>&amp;self</code>修改为<code>&amp;mut self</code>，但是。。。我们实现的特征是定义在外部库中，因此该签名根本不能修改。值此危急关头，<code>RefCell</code>闪亮登场:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;
pub trait Messenger {
    fn send(&amp;self, msg: String);
}

pub struct MsgQueue {
    msg_cache: RefCell&lt;Vec&lt;String&gt;&gt;,  
}

impl Messenger for MsgQueue {
    fn send(&amp;self,msg: String) {
        self.msg_cache.borrow_mut().push(msg)
    }
}

fn main() {
    let mq = MsgQueue{msg_cache: RefCell::new(Vec::new())};
    mq.send(&quot;hello, world&quot;.to_string());
}
</code></pre></pre>
<p>这个MQ功能很弱，但是并不妨碍我们演示内部可变性的核心用法：通过包裹一层<code>RefCell</code>，成功的让<code>&amp;self</code>中的<code>msg_cache</code>成为一个可变值，然后实现对其的修改。</p>
<h2 id="rc--refcell组合使用"><a class="header" href="#rc--refcell组合使用">Rc + RefCell组合使用</a></h2>
<p>在Rust中，一个常见的组合就是<code>Rc</code>和<code>RefCell</code>在一起使用，前者可以实现一个数据拥有多个所有者，后者可以实现数据的可变性:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;
use std::rc::Rc;
fn main() {
    let s = Rc::new(RefCell::new(&quot;我很善变，还拥有多个主人&quot;.to_string()));

    let s1 = s.clone();
    let s2 = s.clone();
    // let mut s2 = s.borrow_mut();
    s2.borrow_mut().push_str(&quot;, on yeah!&quot;);

    println!(&quot;{:?}\n{:?}\n{:?}&quot;, s, s1, s2);
}

</code></pre></pre>
<p>上面代码中，我们使用<code>RefCell&lt;String&gt;</code>包裹一个字符串,同时通过<code>Rc</code>创建了它的三个所有者：<code>s</code>,<code>s1</code>和<code>s2</code>，并且通过其中一个所有者<code>s2</code>对字符串内容进行了修改。</p>
<p>由于<code>Rc</code>的所有者们共享同一个底层的数据，因此当一个所有者修改了数据时，会导致全部所有者持有的数据都发生了变化。</p>
<p>程序的运行结果也在预料之中：</p>
<pre><code class="language-console">RefCell { value: &quot;我很善变，还拥有多个主人, on yeah!&quot; }
RefCell { value: &quot;我很善变，还拥有多个主人, on yeah!&quot; }
RefCell { value: &quot;我很善变，还拥有多个主人, on yeah!&quot; }
</code></pre>
<h4 id="性能损耗"><a class="header" href="#性能损耗">性能损耗</a></h4>
<p>相信这两者组合在一起使用时，很多人会好奇到底性能如何，下面我们来简单分析下。</p>
<p>首先给出一个大概的结论，这两者结合在一起使用的性能其实非常高，大致相当于没有线程安全版本的C++ <code>std::shared_ptr</code>指针, 事实上，<code>C++</code>这个指针的主要开销也在于原子性这个并发原语上，毕竟线程安全在哪个语言中开销都不小。</p>
<h4 id="内存损耗"><a class="header" href="#内存损耗">内存损耗</a></h4>
<p>两者结合的数据结构类似:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Wrapper&lt;T&gt; {
    // Rc
    strong_count: usize,
    weak_count: usize,

    // Refcell
    borrow_count: isize,

    // 包裹的数据
    item: T,
}
<span class="boring">}
</span></code></pre></pre>
<p>从上面可以看出，从对内存的影响来看，仅仅多分配了三个<code>usize/isize</code>，并没有其它额外的负担。</p>
<h4 id="cpu损耗"><a class="header" href="#cpu损耗">CPU损耗</a></h4>
<p>从CPU来看，损耗如下：</p>
<ul>
<li>对<code>Rc&lt;T&gt;</code>解引用是免费的(编译期), 但是*带来的间接取值并不免费</li>
<li>克隆<code>Rc&lt;T&gt;</code>需要将当前的引用计数跟<code>0</code>和<code>usize::Max</code>进行一次比较，然后将计数值加1</li>
<li>释放(drop)<code>Rc&lt;T&gt;</code>将计数值减1， 然后跟<code>0</code>进行一次比较</li>
<li>对<code>RefCell</code>进行不可变借用，将<code>isize</code>类型的借用计数加1，然后跟<code>0</code>进行比较</li>
<li>对<code>RefCell</code>的不可变借用进行释放，将<code>isize</code>减1</li>
<li>对<code>RefCell</code>的可变借用大致流程跟上面差不多，但是是先跟<code>0</code>比较，然后再减1</li>
<li>对<code>RefCell</code>的可变借用进行释放，将<code>isize</code>加1</li>
</ul>
<p>其实这些细节不必过于关注，只要知道<code>CPU</code>消耗也非常低，甚至编译器还会对此进行进一步优化！</p>
<h4 id="cpu缓存miss"><a class="header" href="#cpu缓存miss">CPU缓存Miss</a></h4>
<p>唯一需要担心的可能就是这种组合数据结构对于<code>CPU</code>缓存是否亲和，这个我们无法证明，只能提出来存在这个可能性，最终的性能影响还需要在实际场景中进行测试</p>
<p>总之，分析这两者组合的性能还挺复杂的，大概总结下:</p>
<ul>
<li>从表面来看，它们带来的内存和CPU损耗都不大</li>
<li>但是由于<code>Rc</code>额外的引入了一次间接取值(*)，在少数场景下可能会造成性能上的显著损失</li>
<li>CPU缓存可能也不够亲和</li>
</ul>
<h2 id="通过cellfrom_mut解决借用冲突"><a class="header" href="#通过cellfrom_mut解决借用冲突">通过<code>Cell::from_mut</code>解决借用冲突</a></h2>
<p>在Rust1.37版本中新增了两个非常实用的方法:</p>
<ul>
<li>Cell::from_mut, 该方法将<code>&amp;mut T</code>转为<code>&amp;Cell&lt;T&gt;</code></li>
<li>Cell::as_slice_of_cells，该方法将<code>&amp;Cell&lt;[T]&gt;</code>转为<code>&amp;[Cell&lt;T&gt;]</code></li>
</ul>
<p>这里我们不做深入的介绍，但是来看看如何使用这两个方法来解决一个常见的借用冲突问题：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_even(i: i32) -&gt; bool {
    i % 2 == 0
}

fn retain_even(nums: &amp;mut Vec&lt;i32&gt;) {
    let mut i = 0;
    for num in nums.iter().filter(|&amp;num| is_even(*num)) {
        nums[i] = *num;
        i += 1;
    }
    nums.truncate(i);
}
<span class="boring">}
</span></code></pre></pre>
<p>以上代码会报错：</p>
<pre><code class="language-console">error[E0502]: cannot borrow `*nums` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:8:9
  |
7 |     for num in nums.iter().filter(|&amp;num| is_even(*num)) {
  |                ----------------------------------------
  |                |
  |                immutable borrow occurs here
  |                immutable borrow later used here
8 |         nums[i] = *num;
  |         ^^^^ mutable borrow occurs here
</code></pre>
<p>很明显，因为同时借用了不可变与可变引用，你可以通过索引的方式来绕过:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn retain_even(nums: &amp;mut Vec&lt;i32&gt;) {
    let mut i = 0;
    for j in 0..nums.len() {
        if is_even(nums[j]) {
            nums[i] = nums[j];
            i += 1;
        }
    }
    nums.truncate(i);
}
<span class="boring">}
</span></code></pre></pre>
<p>但是这样就违背我们的初衷了，而且迭代器会让代码更加简洁，还有其它的办法吗？</p>
<p>这时就可以使用<code>Cell</code>新增的这两个方法:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

fn retain_even(nums: &amp;mut Vec&lt;i32&gt;) {
    let slice: &amp;[Cell&lt;i32&gt;] = Cell::from_mut(&amp;mut nums[..])
        .as_slice_of_cells();

    let mut i = 0;
    for num in slice.iter().filter(|num| is_even(num.get())) {
        slice[i].set(num.get());
        i += 1;
    }

    nums.truncate(i);
}
<span class="boring">}
</span></code></pre></pre>
<p>此时代码将不会报错，因为<code>Cell</code>上的<code>set</code>方法获取的是不可变引用<code>pub fn set(&amp;self, val: T)</code>.</p>
<p>当然，以上代码的本质还是对<code>Cell</code>的运用，只不过这两个方法可以很方便的帮我们把<code>&amp;mut [T]</code>类型转换成<code>&amp;[Cell&lt;T&gt;]</code>类型。</p>
<h2 id="总结-11"><a class="header" href="#总结-11">总结</a></h2>
<p><code>Cell</code>和<code>RefCell</code>都为我们带来了内部可变性这个重要特性，同时还将借用规则的检查从编译期推迟到运行期，但是这个检查并不能被绕过，该来早晚还是会来，<code>RefCell</code>在运行期的报错会造成<code>panic</code></p>
<p><code>RefCell</code>适用于编译器误报或者一个引用被在多个代码中使用、修改以至于难于管理借用关系时，还有就是需要内部可变性时。</p>
<p>从性能上看，<code>RefCell</code>由于是非线程安全的，因此无需保证原子性，性能虽然有一点损耗，但是依然非常好，而<code>Cell</code>则完全不存在任何额外的性能损耗。</p>
<p><code>Rc</code>跟<code>RefCell</code>结合使用可以实现多个所有者共享同一份数据，非常好用，但是潜在的性能损耗也要考虑进去，建议对于热点代码使用时，做好<code>benchmark</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="循环引用与自引用"><a class="header" href="#循环引用与自引用">循环引用与自引用</a></h1>
<p>实现一个链表是学习各大编程语言的常用技巧，但是在Rust中实现链表意味着····Hell，是的，你没看错，Welcome to hell。</p>
<p>链表在Rust之所以这么难，完全是由于循环引用和自引用的问题引起的，这两个问题可以说综合了Rust的很多难点，难出了新高度，因此本书专门开辟一章，分为上下两篇，试图彻底解决这两个老大难。</p>
<p>本章难度较高，但是非常值得深入阅读，它会让你对Rust的理解上升到一个新的境界。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weak与循环引用"><a class="header" href="#weak与循环引用">Weak与循环引用</a></h1>
<p>Rust的安全性是众所周知的，但是不代表它不会内存泄漏。一个典型的例子就是同时使用<code>Rc&lt;T&gt;</code>和<code>RefCell&lt;T&gt;</code>创建循环引用，最终这些引用的计数都无法被归零，因此<code>Rc&lt;T&gt;</code>拥有的值也不会被释放清理。</p>
<h2 id="何为循环引用"><a class="header" href="#何为循环引用">何为循环引用</a></h2>
<p>关于内存泄漏，如果你没有充足的Rust经验，可能都无法造出一份代码来再现它: </p>
<pre><pre class="playground"><code class="language-rust edition2021">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}
</code></pre></pre>
<p>这里我们创建一个有些复杂的枚举类型<code>List</code>，这个类型很有意思，它的每个值都指向了另一个<code>List</code>，而且得益于<code>Rc</code>的使用还允许多个值指向一个<code>List</code>:</p>
<img alt="" src="advance/circle-self-ref//img/self-ref-01.png" class="center"  />
<p>如上图所示，每个矩形框节点都是一个<code>List</code>类型，它们或者是拥有值且指向另一个<code>List</code>的的<code>Cons</code>，或者是一个没有值的终结点<code>Nil</code>。同时，由于<code>RefCell</code>的使用，每个<code>List</code>所指向的<code>List</code>还能够被修改。</p>
<p>下面来使用一下这个复杂的<code>List</code>枚举：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a的初始化rc计数 = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a指向的节点 = {:?}&quot;, a.tail());

    // 创建`b`到`a`的引用
    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;在b创建后，a的rc计数 = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b的初始化rc计数 = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b指向的节点 = {:?}&quot;, b.tail());
    
    // 利用RefCell的可变性，创建了`a`到`b`的引用
    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;在更改a后，b的rc计数 = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;在更改a后，a的rc计数 = {}&quot;, Rc::strong_count(&amp;a));

    // 下面一行println!将导致循环引用
    // 我们可怜的8MB大小的main线程栈空间将被它冲垮，最终造成栈溢出
    // println!(&quot;a next item = {:?}&quot;, a.tail());
}
</code></pre></pre>
<p>这个类型定义看着复杂，使用起来更复杂！不过排除这些因素，我们可以清晰看出：</p>
<ol>
<li>在创建了<code>a</code>后，紧接着就使用<code>a</code>创建了<code>b</code>，因此<code>b</code>引用了<code>a</code></li>
<li>然后我们又利用<code>Rc</code>克隆了<code>b</code>，然后通过<code>RefCell</code>的可变性，让<code>a</code>引用了<code>b</code></li>
</ol>
<p>至此我们成功创建了循环引用<code>a</code>-&gt; <code>b</code> -&gt; <code>a</code> -&gt; <code>b</code> ····</p>
<p>先来观察下引用计数:</p>
<pre><code class="language-console">a的初始化rc计数 = 1
a指向的节点 = Some(RefCell { value: Nil })
在b创建后，a的rc计数 = 2
b的初始化rc计数 = 1
b指向的节点 = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
在更改a后，b的rc计数 = 2
在更改a后，a的rc计数 = 2
</code></pre>
<p>在<code>main</code>函数结束前，<code>a</code>和<code>b</code>的引用计数均是<code>2</code>，随后<code>b</code>触发<code>Drop</code>，此时引用计数会变为<code>1</code>，并不会归<code>0</code>，因此<code>b</code>所指向内存不会被释放，同理可得<code>a</code>指向的内存也不会被释放，最终发生了内存泄漏。</p>
<p>下面一张图很好的展示了这种引用循环关系:
<img alt="" src="advance/circle-self-ref//img/self-ref-02.png" class="center"  /></p>
<p>现在我们还需要轻轻的推一下，让塔米诺骨牌轰然倒塌。反注释最后一行代码，试着运行下：</p>
<pre><code class="language-console">RefCell { value: Cons(5, RefCell { value: Cons(10, RefCell { value: Cons(5, RefCell { value: Cons(10, RefCell { value: Cons(5, RefCell { value: Cons(10, RefCell { 
...无穷无尽
thread 'main' has overflowed its stack
fatal runtime error: stack overflow
</code></pre>
<p>通过<code>a.tail</code>的调用，Rust试图打印出<code>a -&gt; b -&gt;a···</code>的所有内容，但是在不懈的努力后，<code>main</code>线程终于不堪重负，发生了<a href="https://course.rs/pitfalls/stack-overflow.html">栈溢出</a>。</p>
<p>以上的代码可能并不会造成什么大的问题，但是在一个更加复杂的程序中，类似的问题可能会造成你的程序不断的分配内存、泄漏内存，最终程序会不幸<strong>OOM</strong>，当然这其中的CPU损耗也不可小觑。</p>
<p>总之，创建引用并不简单，但是也并不是完全遇不到，当你使用<code>RefCell&lt;Rc&lt;T&gt;&gt;</code>或者类似的类型嵌套组合(具备内部可变性和引用计数)时，就要打起万分精神，前面可能是深渊！</p>
<p>那么问题来了？ 如果我们确实需要实现上面的功能，该怎么办？答案是使用<code>Weak</code>。</p>
<h2 id="weak"><a class="header" href="#weak">Weak</a></h2>
<p><code>Weak</code>非常类似于<code>Rc</code>，但是与<code>Rc</code>持有所有权不同，<code>Weak</code>不持有所有权，它仅仅保存一份指向数据的弱引用：如果你想要访问数据，需要通过<code>Weak</code>指针的<code>upgrade</code>方法实现，该方法返回一个类型为<code>Option&gt;&lt;Rc&lt;T&gt;&gt;</code>的值。</p>
<p>看到这个返回，相信大家就懂了：何为弱引用？就是<strong>不保证引用关系依然存在</strong>，如果不存在，就返回一个<code>None</code>!</p>
<p>因为<code>Weak</code>引用不计入所有权，因此它<strong>无法阻止所引用的内存值被释放掉</strong>, 而且<code>Weak</code>本身不对值的存在性做任何担保，引用的值还存在就返回<code>Some</code>，不存在就返回<code>None</code>。</p>
<h4 id="weak与rc对比"><a class="header" href="#weak与rc对比">Weak与Rc对比</a></h4>
<p>我们来将<code>Weak</code>与<code>Rc</code>进行以下简单对比:</p>
<table><thead><tr><th><code>Weak</code></th><th><code>Rc</code></th></tr></thead><tbody>
<tr><td>不计数</td><td>引用计数</td></tr>
<tr><td>不拥有所有权</td><td>拥有值的所有权</td></tr>
<tr><td>不阻止值被释放(drop)</td><td>所有权计数归零，才能drop</td></tr>
<tr><td>引用的值存在返回Some,不存在返回None</td><td>引用的值必定存在</td></tr>
<tr><td>通过<code>upgrade</code>取到<code>Option&lt;Rc&lt;T&gt;&gt;</code>,然后再取值</td><td>通过<code>Deref</code>自动解引用，取值无需任何操作</td></tr>
</tbody></table>
<p>通过这个对比，可以非常清晰的看出<code>Weak</code>为何这么弱，而这种弱恰恰非常适合我们实现以下的场景：</p>
<ul>
<li>持有一个<code>Rc</code>对象的临时引用，并且不在乎引用的值是否依然存在</li>
<li>阻止<code>Rc</code>导致的循环引用，因为<code>Rc</code>的所有权机制，会导致多个<code>Rc</code>都无法计数归零</li>
</ul>
<p>使用方式简单总结下：<strong>对于父子引用关系，可以让父节点通过<code>Rc</code>来引用子节点，然后让子节点通过<code>Weak</code>来引用父节点</strong>。</p>
<h4 id="weak总结"><a class="header" href="#weak总结">Weak总结</a></h4>
<p>因为Weak本身并不是很好理解，因此我们再来帮大家梳理总结下，然后再通过一个例子，来彻底掌握。</p>
<p><code>Weak</code>通过<code>use std::rc::Weak</code>来引入，它具有以下特点:</p>
<ul>
<li>可访问，但没有所有权，不增加引用计数，因此不会影响被引用值的释放回收</li>
<li>可由<code>Rc&lt;T&gt;</code>调用<code>downgrade</code>方法转换成<code>Weak&lt;T&gt;</code></li>
<li><code>Weak&lt;T&gt;</code>可使用<code>upgrade</code>方法转换成<code>Option&lt;Rc&lt;T&gt;&gt;</code>,如果资源已经被释放，则<code>Option</code>的值是<code>None</code></li>
<li>常用于解决循环引用的问题</li>
</ul>
<p>一个简单的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::rc::Rc;
fn main() {
    // 创建Rc，持有一个值5
    let five = Rc::new(5);

    // 通过Rc，创建一个Weak指针
    let weak_five = Rc::downgrade(&amp;five);

    // Weak引用的资源依然存在，取到值5
    let strong_five: Option&lt;Rc&lt;_&gt;&gt; = weak_five.upgrade();
    assert_eq!(*strong_five.unwrap(), 5);

    // 手动释放资源`five`
    drop(five);

    // Weak引用的资源已不存在，因此返回None
    let strong_five: Option&lt;Rc&lt;_&gt;&gt; = weak_five.upgrade();
    assert_eq!(strong_five, None);
}
</code></pre></pre>
<p>需要承认的是，使用<code>Weak</code>让Rust本来就堪忧的代码可读性又下降了不少，但是。。。真香，因为可以解决循环引用了。</p>
<h2 id="使用weak解决循环引用"><a class="header" href="#使用weak解决循环引用">使用Weak解决循环引用</a></h2>
<p>理论知识已经足够，现在用两个例子来模拟下真实场景下可能会遇到的循环引用。</p>
<h4 id="工具间的故事"><a class="header" href="#工具间的故事">工具间的故事</a></h4>
<p>工具间里，每个工具都有其主人，且多个工具可以拥有一个主人；同时一个主人也可以拥有多个工具，在这种场景下，就很容易形成循环引用，好在我们有<code>Weak</code>: </p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::rc::Rc;
use std::rc::Weak;
use std::cell::RefCell;

// 主人
struct Owner {
    name: String,
    gadgets: RefCell&lt;Vec&lt;Weak&lt;Gadget&gt;&gt;&gt;,
}

// 工具
struct Gadget {
    id: i32,
    owner: Rc&lt;Owner&gt;,
}

fn main() {
    // 创建一个Owner
    // 需要注意，该Owner也拥有多个`gadgets`
    let gadget_owner : Rc&lt;Owner&gt; = Rc::new(
        Owner {
            name: &quot;Gadget Man&quot;.to_string(),
            gadgets: RefCell::new(Vec::new()),
        }
    );

    // 创建工具，同时与主人进行关联：创建两个gadget，他们分别持有gadget_owner 的一个引用。
    let gadget1 = Rc::new(Gadget{id: 1, owner: gadget_owner.clone()});
    let gadget2 = Rc::new(Gadget{id: 2, owner: gadget_owner.clone()});

    // 为主人更新它所拥有的工具
    // 因为之前使用了`Rc`，现在必须要使用`Weak`，否则就会循环引用
    gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&amp;gadget1));
    gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&amp;gadget2));

    // 遍历 gadget_owner的gadgets字段
    for gadget_opt in gadget_owner.gadgets.borrow().iter() {

        // gadget_opt 是一个 Weak&lt;Gadget&gt; 。 因为 weak 指针不能保证他所引用的对象
        // 仍然存在。所以我们需要显式的调用 upgrade() 来通过其返回值(Option&lt;_&gt;)来判
        // 断其所指向的对象是否存在。
        // 当然，Option为None的时候这个引用原对象就不存在了。
        let gadget = gadget_opt.upgrade().unwrap();
        println!(&quot;Gadget {} owned by {}&quot;, gadget.id, gadget.owner.name);
    }

    // 在main函数的最后， gadget_owner, gadget1和daget2都被销毁。
    // 具体是，因为这几个结构体之间没有了强引用（`Rc&lt;T&gt;`），所以，当他们销毁的时候。
    // 首先 gadget1和gadget2被销毁。
    // 然后因为gadget_owner的引用数量为0，所以这个对象可以被销毁了。
    // 循环引用问题也就避免了
}
</code></pre></pre>
<h4 id="tree数据结构"><a class="header" href="#tree数据结构">tree数据结构</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}

</code></pre></pre>
<p>这个例子就留给读者自己解读和分析，我们就不画蛇添足了：）</p>
<h2 id="unsafe解决循环引用"><a class="header" href="#unsafe解决循环引用">unsafe解决循环引用</a></h2>
<p>除了使用Rust标准库提供的这些类型，你还可以使用<code>unsafe</code>里的原生指针来解决这些棘手的问题，但是由于我们还没有讲解<code>unsafe</code>，因此这里就不进行展开，只附上<a href="https://codes.rs/unsafe/self-ref.html">源码链接</a>, 挺长的，需要耐心o_O</p>
<p>虽然<code>unsafe</code>不安全，但是在各种库的代码中依然很常见用它来实现自引用结构，主要优点如下:</p>
<ul>
<li>性能高，毕竟直接用原生指针操作</li>
<li>代码更简单更符合直觉: 对比下<code>Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;</code></li>
</ul>
<h2 id="总结-12"><a class="header" href="#总结-12">总结</a></h2>
<p>本文深入讲解了何为循环引用以及如何使用<code>Weak</code>来解决，同时还结合<code>Rc</code>、<code>RefCell</code>、<code>Weak</code>等实现了两个有实战价值的例子，让大家对智能指针的使用更加融会贯通。</p>
<p>至此，智能指针一章即将结束(严格来说还有一个Mutex放在多线程一章讲解)，而Rust语言本身的学习之旅也即将结束，后面我们将深入多线程、项目工程、应用实践、性能分析等特色专题，来一睹Rust在这些领域的风采。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构体自引用"><a class="header" href="#结构体自引用">结构体自引用</a></h2>
<p>结构体自引用在Rust中是一个众所周知的难题，而且众说纷纭，也没有一篇文章能把相关的话题讲透，那本文就王婆卖瓜，来试试看能不能讲透这一块儿内容，让读者大大们舒心。</p>
<h2 id="平平无奇的自引用"><a class="header" href="#平平无奇的自引用">平平无奇的自引用</a></h2>
<p>可能也有不少人第一次听说自引用结构体，那咱们先来看看它们长啥样。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RefWithinMe&lt;'a&gt; {
    value: String,

    // 该引用指向上面的value
    pointer_to_value: &amp;'a str,
}
<span class="boring">}
</span></code></pre></pre>
<p>以上就是一个很简单的自引用结构体,看上去好像没什么，那来试着运行下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main(){
    let s = &quot;aaa&quot;.to_string();
    let v = SelfRef {
        value: s,
        pointer_to_value: &amp;s
    };
}
</code></pre></pre>
<p>运行后报错:</p>
<pre><code class="language-console"> let v = SelfRef {
12 |         value: s,
   |                - value moved here
13 |         pointer_to_value: &amp;s
   |                           ^^ value borrowed here after move
</code></pre>
<p>因为我们试图同时使用值和值的引用，最终所有权转移和借用一起发生了。所以，这个问题貌似并没有那么好解决，不信你可以回想下自己具有的知识，是否可以解决？</p>
<h2 id="使用option"><a class="header" href="#使用option">使用Option</a></h2>
<p>最简单的方式就是使用<code>Opiton</code>分两步来实现:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct WhatAboutThis&lt;'a&gt; {
    name: String,
    nickname: Option&lt;&amp;'a str&gt;,
}

fn main() {
    let mut tricky = WhatAboutThis {
        name: &quot;Annabelle&quot;.to_string(),
        nickname: None,
    };
    tricky.nickname = Some(&amp;tricky.name[..4]);

    println!(&quot;{:?}&quot;, tricky);
}
</code></pre></pre>
<p>在某种程度上来说，<code>Option</code>这个方法可以工作，但是这个方法的限制较多，例如从一个函数创建并返回它是不可能的:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn creator&lt;'a&gt;() -&gt; WhatAboutThis&lt;'a&gt; { 
    let mut tricky = WhatAboutThis {
        name: &quot;Annabelle&quot;.to_string(),
        nickname: None,
    };
    tricky.nickname = Some(&amp;tricky.name[..4]);

    tricky
}
<span class="boring">}
</span></code></pre></pre>
<p>报错如下:</p>
<pre><code class="language-console">error[E0515]: cannot return value referencing local data `tricky.name`
  --&gt; src/main.rs:24:5
   |
22 |     tricky.nickname = Some(&amp;tricky.name[..4]);
   |                             ----------- `tricky.name` is borrowed here
23 | 
24 |     tricky
   |     ^^^^^^ returns a value referencing data owned by the current function
</code></pre>
<p>其实从函数签名就能看出来端倪，<code>'a</code>生命周期是凭空产生的！</p>
<p>如果是通过方法使用，你需要一个无用<code>&amp;'a self</code>生命周期标识，一旦有了这个标识，代码将变得更加受限，你将很容易就获得借用错误，就连NLL规则都没用：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct WhatAboutThis&lt;'a&gt; {
    name: String,
    nickname: Option&lt;&amp;'a str&gt;,
}

impl&lt;'a&gt; WhatAboutThis&lt;'a&gt; {
    fn tie_the_knot(&amp;'a mut self) {
       self.nickname = Some(&amp;self.name[..4]); 
    }
}

fn main() {
    let mut tricky = WhatAboutThis {
        name: &quot;Annabelle&quot;.to_string(),
        nickname: None,
    };
    tricky.tie_the_knot();

    // cannot borrow `tricky` as immutable because it is also borrowed as mutable
    // println!(&quot;{:?}&quot;, tricky);
}
</code></pre></pre>
<h2 id="unsafe实现"><a class="header" href="#unsafe实现">unsafe实现</a></h2>
<p>既然借用规则妨碍了我们，那就一脚踢开: </p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct SelfRef {
    value: String,
    pointer_to_value: *const String,
}

impl SelfRef {
    fn new(txt: &amp;str) -&gt; Self {
        SelfRef {
            value: String::from(txt),
            pointer_to_value: std::ptr::null(),
        }
    }

    fn init(&amp;mut self) {
        let self_ref: *const String = &amp;self.value;
        self.pointer_to_value = self_ref;
    }

    fn value(&amp;self) -&gt; &amp;str {
        &amp;self.value
    }

    fn pointer_to_value(&amp;self) -&gt; &amp;String {
        assert!(!self.pointer_to_value.is_null(), &quot;Test::b called without Test::init being called first&quot;);
        unsafe { &amp;*(self.pointer_to_value) }
    }
}

fn main() {
    let mut t = SelfRef::new(&quot;hello&quot;);
    t.init();
    // 打印值和指针地址
    println!(&quot;{}, {:p}&quot;,t.value(), t.pointer_to_value());
}
</code></pre></pre>
<p>在这里，我们在<code>pointer_to_value</code>中直接存储原生指针，而不是Rust的引用，因此不再受到Rust借用规则和生命周期的限制，而且实现起来非常清晰、简洁。但是缺点就是，通过指针获取值时需要使用<code>unsafe</code>代码, </p>
<p>当然，上面的代码你还能通过原生指针来修改<code>String</code>，但是需要将<code>*const</code>修改为<code>*mut</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct SelfRef {
    value: String,
    pointer_to_value: *mut String,
}

impl SelfRef {
    fn new(txt: &amp;str) -&gt; Self {
        SelfRef {
            value: String::from(txt),
            pointer_to_value: std::ptr::null_mut(),
        }
    }

    fn init(&amp;mut self) {
        let self_ref: *mut String = &amp;mut self.value;
        self.pointer_to_value = self_ref;
    }

    fn value(&amp;self) -&gt; &amp;str {
        &amp;self.value
    }

    fn pointer_to_value(&amp;self) -&gt; &amp;String {
        assert!(!self.pointer_to_value.is_null(), &quot;Test::b called without Test::init being called first&quot;);
        unsafe { &amp;*(self.pointer_to_value) }
    }
}

fn main() {
    let mut t = SelfRef::new(&quot;hello&quot;);
    t.init();
    println!(&quot;{}, {:p}&quot;,t.value(), t.pointer_to_value());

    t.value.push_str(&quot;, world&quot;);
    unsafe {
        (&amp;mut *t.pointer_to_value).push_str(&quot;!&quot;);
    }
    
    println!(&quot;{}, {:p}&quot;,t.value(), t.pointer_to_value());
}
</code></pre></pre>
<p>运行后输出:</p>
<pre><code class="language-console">hello, 0x16f3aec70
hello, world!, 0x16f3aec70
</code></pre>
<p>上面的<code>unsafe</code>虽然简单好用，但是它不太安全，是否还有其他选择？还真的有，那就是<code>Pin</code>。</p>
<h2 id="无法被移动的pin"><a class="header" href="#无法被移动的pin">无法被移动的Pin</a></h2>
<p>Pin在后续章节会深入讲解，目前你只需要知道它可以固定住一个值，防止该值在内存中被移动。</p>
<p>通过开头我们知道，自引用最麻烦的就是创建引用的同时，值的所有权会被转移，而通过Pin就可以很好的防止这一点:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::marker::PhantomPinned;
use std::pin::Pin;
use std::ptr::NonNull;

// 下面是一个自引用数据结构体，因为slice字段是一个指针, 指向了data字段
// 我们无法使用普通引用来实现，因为违背了Rust的编译规则
// 因此，这里我们使用了一个原生指针，通过NonNull来确保它不会为null
struct Unmovable {
    data: String,
    slice: NonNull&lt;String&gt;,
    _pin: PhantomPinned,
}

impl Unmovable {
    // 为了确保函数返回时数据的所有权不会被转移, 我们将它放在堆上, 唯一的访问方式就是通过指针
    fn new(data: String) -&gt; Pin&lt;Box&lt;Self&gt;&gt; {
        let res = Unmovable {
            data,
            // 只有在数据到位时，才创建指针，否则数据会在开始之前就被转移所有权
            slice: NonNull::dangling(),
            _pin: PhantomPinned,
        };
        let mut boxed = Box::pin(res);

        let slice = NonNull::from(&amp;boxed.data);
        // 这里其实安全的，因为修改一个字段不会转移整个结构体的所有权
        unsafe {
            let mut_ref: Pin&lt;&amp;mut Self&gt; = Pin::as_mut(&amp;mut boxed);
            Pin::get_unchecked_mut(mut_ref).slice = slice;
        }
        boxed
    }
}

fn main() {
    let unmoved = Unmovable::new(&quot;hello&quot;.to_string());
    // 只要结构体没有被转移，那指针就应该指向正确的位置，而且我们可以随意移动指针
    let mut still_unmoved = unmoved;
    assert_eq!(still_unmoved.slice, NonNull::from(&amp;still_unmoved.data));

    // 因为我们的类型没有实现`Unpin`特征，下面这段代码将无法编译
    // let mut new_unmoved = Unmovable::new(&quot;world&quot;.to_string());
    // std::mem::swap(&amp;mut *still_unmoved, &amp;mut *new_unmoved);
}
</code></pre></pre>
<p>上面的代码也非常清晰，虽然使用了<code>unsafe</code>，其实更多的是无奈之举，跟之前的<code>unsafe</code>实现完全不可同日而语。</p>
<p>其实<code>Pin</code>在这里并没有魔法，它也并不是实现自引用类型的主要原因，最关键的还是里面的原生指针的使用，而<code>Pin</code>起到的作用就是确保我们的值不会被移走，否则指针就会指向一个错误的地址！</p>
<h2 id="使用ouroboros"><a class="header" href="#使用ouroboros">使用ouroboros</a></h2>
<p>对于自引用结构体，三方库也有支持的，其中一个就是<a href="https://github.com/joshua-maros/ouroboros">ouroboros</a>，当然它也有自己的限制，我们后面会提到，先来看看该如何使用：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use ouroboros::self_referencing;

#[self_referencing]
struct SelfRef {
    value: String,

    #[borrows(value)]
    pointer_to_value: &amp;'this str,
}

fn main(){
    let v = SelfRefBuilder {
        value: &quot;aaa&quot;.to_string(),
        pointer_to_value_builder: |value: &amp;String| value,
    }.build();

    // 借用value值
    let s = v.borrow_value();
    // 借用指针
    let p = v.borrow_pointer_to_value();
    // value值和指针指向的值相等
    assert_eq!(s, *p);
}
</code></pre></pre>
<p>可以看到，<code>ouroboros</code>使用起来并不复杂，就是需要你去按照它的方式创建结构体和引用类型：<code>SelfRef</code>变成<code>SelfRefBuilder</code>，引用字段从<code>pointer_to_value</code>变成<code>pointer_to_value_builder</code>，并且连类型都变了。</p>
<p>在使用时，通过<code>borrow_value</code>来借用<code>value</code>的值，通过<code>borrow_pointer_to_value</code>来借用<code>pointer_to_value</code>这个指针。</p>
<p>看上去很美好对吧？但是你可以尝试着去修改<code>String</code>字符串的值试试，<code>ouroboros</code>限制还是较多的，但是对于基本类型依然是支持的不错，以下例子来源于官方:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use ouroboros::self_referencing;

#[self_referencing]
struct MyStruct {
    int_data: i32,
    float_data: f32,
    #[borrows(int_data)]
    int_reference: &amp;'this i32,
    #[borrows(mut float_data)]
    float_reference: &amp;'this mut f32,
}

fn main() {
    let mut my_value = MyStructBuilder {
        int_data: 42,
        float_data: 3.14,
        int_reference_builder: |int_data: &amp;i32| int_data,
        float_reference_builder: |float_data: &amp;mut f32| float_data,
    }.build();

    // Prints 42
    println!(&quot;{:?}&quot;, my_value.borrow_int_data());
    // Prints 3.14
    println!(&quot;{:?}&quot;, my_value.borrow_float_reference());
    // Sets the value of float_data to 84.0
    my_value.with_mut(|fields| {
        **fields.float_reference = (**fields.int_reference as f32) * 2.0;
    });

    // We can hold on to this reference...
    let int_ref = *my_value.borrow_int_reference();
    println!(&quot;{:?}&quot;, *int_ref);
    // As long as the struct is still alive.
    drop(my_value);
    // This will cause an error!
    // println!(&quot;{:?}&quot;, *int_ref);
}
</code></pre></pre>
<p>总之，使用这个库前，强烈建议看一些官方的例子中支持什么样的类型和API，如果能满足的你的需求，就果断使用它，如果不能满足，就继续往下看。</p>
<p>只能说，它确实帮助我们解决了问题，但是一个是破坏了原有的结构，另外就是并不是所有数据类型都支持：它需要目标值的内存地址不会改变，因此<code>Vec</code>动态数组就不适合，因为当内存空间不够时，Rust会重新分配一块空间来存放该数组，这会导致内存地址的改变。 </p>
<p>类似的库还有:</p>
<ul>
<li><a href="https://github.com/jpernst/rental">rental</a>， 这个库其实是最有名的，但是好像不再维护了，用倒是没问题</li>
<li><a href="https://github.com/Kimundi/owning-ref-rs">owning-ref</a> ，将所有者和它的引用绑定到一个封装类型</li>
</ul>
<p>这三个库，各有各的特点，也各有各的缺陷，建议大家需要时，一定要仔细调研，并且写demo进行测试，不可大意。</p>
<blockquote>
<p>rental虽然不怎么维护，但是可能依然是这三个里面最强大的，而且网上的用例也比较多，容易找到参考代码</p>
</blockquote>
<h2 id="rcrefcell或arcmutex"><a class="header" href="#rcrefcell或arcmutex">Rc+RefCell或Arc+Mutex</a></h2>
<p>类似于循环引用的解决方式，自引用也可以用这种组合来解决，但是会导致代码的类型标识到处都是，大大的影响了可读性。</p>
<h2 id="终极大法"><a class="header" href="#终极大法">终极大法</a></h2>
<p>如果两个放在一起会报错，那就分开它们。对，终极大法就这么简单，当然思路上的简单不代表实现上的简单，最终结果就是导致代码复杂度的上升。</p>
<h2 id="学习一本书如何实现链表"><a class="header" href="#学习一本书如何实现链表">学习一本书：如何实现链表</a></h2>
<p>最后，推荐一本专门将如何实现链表的书(真是富有Rust特色，链表都能复杂到出书了O, O)，<a href="https://rust-unofficial.github.io/too-many-lists/">Learn Rust by writing Entirely Too Many Linked Lists</a></p>
<h2 id="总结-13"><a class="header" href="#总结-13">总结</a></h2>
<p>上面讲了这么多方法，但是我们依然无法正确的告诉你在某个场景应该使用哪个方法，这个需要你自己的判断，因为自引用实在是过于复杂。</p>
<p>我们能做的就是告诉你，有这些办法可以解决自引用问题，而这些办法每个都有自己适用的范围，需要你未来去深入的挖掘和发现。</p>
<p>偷偷说一句，就算是我，遇到自引用一样挺头疼，好在这种情况真的不常见，往往是实现特定的算法和数据结构时才需要，应用代码中几乎用不到。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多线程并发编程"><a class="header" href="#多线程并发编程">多线程并发编程</a></h1>
<p>安全和高效的处理并发是Rust语言的主要目标之一。随着现代处理器的核心数不断增加，并发和并行已经成为日常编程不可或缺的一部分，甚至于Go语言已经将并发简化到一个<code>go</code>关键字就可以。</p>
<p>可惜的是，在Rust中由于语言设计理念、安全、性能的多方面考虑，并没有采用Go语言大道至简的方式，而是选择了多线程与<code>async/await</code>相结合，优点是可控性更强、性能更高，缺点是复杂度并不低，当然这也是系统级语言的应有选择：<strong>使用复杂度换取可控性和性能</strong>。</p>
<p>不过，大家也不用担心，本书的目标就是降低Rust使用门槛，这个门槛自然也包括如何在Rust中进行异步并发编程，我们将从多线程以及async/await两个方面去深入浅出的讲解，首先，从本章的多线程开始。</p>
<p>在本章，我们将深入讲解并发和并行的区别以及如何使用多线程进行Rust并发编程，那么先来看看何为并行与并发。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并发和并行"><a class="header" href="#并发和并行">并发和并行</a></h1>
<blockquote>
<p>并发是同一时间应对多件事情的能力 - <a href="https://en.wikipedia.org/wiki/Rob_Pike">Rob Pike</a></p>
</blockquote>
<p>并行和并发其实并不难，但是也给一些用户造成了困扰，因此我们专门开辟一个章节，用于讲清楚这两者的区别。</p>
<p><code>Erlang</code>之父<a href="https://en.wikipedia.org/wiki/Joe_Armstrong_(programmer)"><code>Joe Armstrong</code></a>(伟大的异步编程先驱，开创一个时代的殿堂级计算机科学家，我还犹记得当年刚学到erlang时的震撼，respect!)用一张5岁小孩都能看到的图片解释了并发与并行的区别: </p>
<img alt="" src="advance/concurrency-with-threads//img/threads-01.png" class="center"  />
<p>上图很直观的体现了：</p>
<ul>
<li><strong>并发(Concurrent)</strong> 是多个队列使用同一个咖啡机，然后两个队列轮换着使用(未必是1:1轮换，也可能是其它轮换规则)，最终每个人都能接到咖啡</li>
<li><strong>并行(Parallel)</strong> 是每个队列都拥有一个咖啡机，最终也是每个人都能接到咖啡，但是效率更高，因为同时可以有两个人在接咖啡</li>
</ul>
<p>当然，我们还可以对比下串行：只有一个队列且仅使用一台咖啡机，哪怕前面那个人接咖啡时突然发呆了几分钟，后面的人也只能等他结束才能继续接。可能有读者有疑问了，从图片来看，并发也存在这个问题啊，前面的人抽了几分钟不接怎么办？很简单，另外一个队列的人把他推开就行了，自己队友不能在背后开枪，但是其它队的可以:)</p>
<p>在正式开始之前，先给出一个结论：<strong>并发和并行都是对&quot;多任务&quot;处理的描述，其中并发是轮流处理，而并行是同时处理</strong>。</p>
<h2 id="cpu多核"><a class="header" href="#cpu多核">CPU多核</a></h2>
<p>现在的个人计算机动辄拥有十来个核心(M1 Max/Intel 12代)，如果使用串行的方式那真是太低调了，因此我们把各种任务简单分成多个队列，每个队列都交给一个cpu核心去执行，当某个cpu核心没有任务时，它还能去其它核心的队列中偷任务(真·老黄牛)，这样就实现了并行化处理。</p>
<h4 id="单核心并发"><a class="header" href="#单核心并发">单核心并发</a></h4>
<p>那问题来了，在早期只有一个CPU核心时，我们的任务是怎么处理的呢？其实聪明的读者应该已经想到，是的，并发解君愁。当然，这里还得提到操作系统的多线程，正是操作系统多线程 + CPU核心，才实现了现代化的多任务操作系统。</p>
<p>在OS级别，多线程负责管理我们的任务队列，你可以简单认为一个线程管理着一个任务队列，然后线程之间还能根据空闲度进行任务调度。我们的程序只会跟OS线程打交道，并不关心CPU到底有多少个核心，真正关心的只是OS，当线程把任务交给CPU核心去执行时，如果只有一个CPU核心，那么它就只能同时处理一个任务。</p>
<p>相信大家都看出来了：<strong>CPU核心</strong>对应的是上图的咖啡机，而<strong>多个线程的任务队列</strong>就对应的多个排队的队列，最终受限于CPU核心数, 每次只会有一个任务被处理。</p>
<p>和排队一样，假如某个任务执行时间过长，就会导致用户界面的假死(相信使用Windows的同学或多或少都碰到过假死的问题)， 那么就需要CPU的任务调度了(真实CPU的调度很复杂，我们这里做了简化)，有一个调度器会按照某些条件从队列中选择任务进行执行，并且当一个任务执行时间过长时，会强行切换该任务到后台中(或者放入任务队列，真实情况很复杂！)，去执行新的任务。</p>
<p>不断这样的快速任务切换，对用户而言就实现了表面上的多任务同时处理，但是实际上最终也只有一个CPU核心在不停的工作。</p>
<p>因此并发的关键在于：<strong>快速轮换处理不同的任务</strong>，给用户带来所有任务同时在运行的假象。</p>
<h4 id="多核心并行"><a class="header" href="#多核心并行">多核心并行</a></h4>
<p>当CPU核心增多到<code>N</code>时，那么同一时间就能有<code>N</code>个任务被处理，那么我们的并行度就是<code>N</code>，相应的处理效率也变成了单核心的<code>N</code>倍(实际情况并没有这么高)。</p>
<h4 id="多核心并发"><a class="header" href="#多核心并发">多核心并发</a></h4>
<p>当核心增多到<code>N</code>时，操作系统同时在进行的任务肯定远不止<code>N</code>个，而这些任务将被放入<code>M</code>个线程队列中，接着交给<code>N</code>个CPU核心去执行，最后实现了<code>M:N</code>的处理模型，在这种情况下，<strong>并发跟并行时同时在发生的，所有用户任务从表面来看都在并发的运行，其实实际上，同一时刻只有<code>N</code>个任务能被同时并行的处理</strong>。</p>
<p>看到这里，相信大家已经明白两者的区别，那么我们下面给出一个正式的定义(该定义摘选自&lt;&lt;并发的艺术&gt;&gt;)。</p>
<h2 id="正式的定义"><a class="header" href="#正式的定义">正式的定义</a></h2>
<p>如果某个系统支持两个或者多个动作的<strong>同时存在</strong>，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作<strong>同时执行</strong>，那么这个系统就是一个并行系统。并发系统与并行系统这两个定义之间的关键差异在于 <strong>“存在”</strong> 这个词。</p>
<p>在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是 <strong>同时“存在”</strong> 的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。</p>
<p>相信你已经能够得出结论——<strong>“并行”概念是“并发”概念的一个子集</strong>。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。</p>
<h2 id="编程语言的并发模型"><a class="header" href="#编程语言的并发模型">编程语言的并发模型</a></h2>
<p>如果大家学过其它语言的多线程，可能就知道不同语言对于线程的实现可能大相径庭:</p>
<ul>
<li>由于操作系统提供了创建线程的API，因此部分语言会直接调用该API来创建线程，因此最终程序内的线程数和该程序占用的操作系统线程数相等，一般称之为<strong>1:1线程模型</strong>，例如Rust</li>
<li>还有些语言在内部实现了自己的线程模型(绿色线程、协程)，程序内部的M个线程最后会以某种映射方式使用N个操作系统线程去运行，因此称之为<strong>M:N线程模型</strong>, 其中M和N并没有特定的彼此限制关系。一个典型的代表就是Go语言</li>
<li>还有些语言使用了Actor模型，基于消息传递进行并发, 例如Erlang语言</li>
</ul>
<p>总之，每一种模型都有其优缺点及选择上的权衡，而Rust在设计时考虑的权衡就是运行时(runtime)。出于Rust的系统级使用场景，且要保证调用C时的极致性能，它最终选择了尽量小的运行时实现。</p>
<blockquote>
<p>运行时是那些会被打包到所有程序可执行文件中的Rust代码，根据每个语言的设计权衡，运行时虽然有大有小(例如Go语言由于实现了协程和GC，运行时相对就会更大一些)，但是除了汇编之外，每个语言都拥有它。小运行时的其中一个好处在于最终编译出的可执行文件会相对较小，同时也让该语言更容易被其它语言引入使用。</p>
</blockquote>
<p>而绿色线程/协程的实现会显著增大运行时的大小，因此Rust只在标准库中提供了<code>1:1</code>的线程模型，如果你愿意牺牲一些性能来换取更精确的线程控制以及更小的线程上下文切换成本，那么可以选择<code>Rust</code>中的<code>M:N</code>模型，这些模型由三方库提供了实现，例如大名鼎鼎的<code>tokio</code>。</p>
<p>在了解了并发和并行后，我们可以正式开始Rust的多线程之旅。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用线程"><a class="header" href="#使用线程">使用线程</a></h1>
<p>放在十年前，多线程编程可能还是一个少数人才掌握的核心概念，而在今天随着编程语言的不断发展，多线程、多协程、Actor等并发编程方式已经深入人心，同时多线程编程的门槛也在不断降低，本章节我们来看看在Rust中该如何使用多线程。</p>
<h2 id="多线程编程的风险"><a class="header" href="#多线程编程的风险">多线程编程的风险</a></h2>
<p>由于多线程的代码是同时运行的，因此我们无法保证线程间的执行顺序，这会导致一些问题:</p>
<ul>
<li>竞态条件(race conditions), 多个线程以非一致性的顺序同时访问数据资源</li>
<li>死锁(deadlocks)，两个线程都想使用某个资源，但是又都在等待对方释放资源后才能使用，结果最终都无法继续执行</li>
<li>一些因为多线程导致的很隐晦的BUG，且难以复现和解决</li>
</ul>
<p>虽然Rust已经通过各种机制减少了上述情况的发生，但是依然无法完全避免上述情况，因此我们在编程时需要格外的小心，同时本书也会列出多线程编程时常见的陷阱，让你提前规避可能的风险。</p>
<h2 id="创建线程"><a class="header" href="#创建线程">创建线程</a></h2>
<p>使用<code>thread::spawn</code>可以创建线程:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p>有几点值得注意：</p>
<ul>
<li>线程内部的代码使用闭包来执行</li>
<li><code>main</code>线程一旦结束，程序就立刻结束，因此需要保持它的存活，直到其它子线程完成自己的任务</li>
<li><code>thread::sleep</code>会让当前线程休眠指定的时间，随后其它线程会被调度运行(上一节并发与并行中有简单介绍过)，因此就算你的电脑只有一个CPU核心，该程序也会表现的如同多CPU核心一般，这就是并发！</li>
</ul>
<p>来看看输出:</p>
<pre><code class="language-console">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 4 from the main thread!
hi number 5 from the spawned thread!
</code></pre>
<p>如果多运行几次，你会发现好像每次输出会不太一样，因为: 虽说线程往往是轮流执行的，但是这一点无法被保证！线程调度的方式往往取决于你使用的操作系统。总之，<strong>千万不要依赖线程的执行顺序</strong>!</p>
<h2 id="等待子线程的结束"><a class="header" href="#等待子线程的结束">等待子线程的结束</a></h2>
<p>上面的代码你不仅无法让子线程打印到10，因为主线程会提前结束，导致子线程也随之结束，更过分的是，如果当前系统繁忙，甚至该子线程还没被创建，主线程就已经结束了！</p>
<p>因此我们需要一个方法，让主线程安全、可靠的等所有子线程完成任务后，再kill self:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..5 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p>通过调用<code>handle.join</code>，可以让当前线程阻塞，直到它等待的子线程的结束，在上面代码中，由于<code>main</code>线程会被阻塞，因此它直到子线程结束后才会输出自己的<code>1..5</code>:</p>
<pre><code class="language-console">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>以上输出清晰的展示了线程阻塞的作用，同时如果你将<code>handle.join</code>放置在<code>main</code>线程中的<code>for</code>循环后面，那就是另外一个结果：两个线程交替输出。</p>
<h2 id="在线程闭包中使用move"><a class="header" href="#在线程闭包中使用move">在线程闭包中使用move</a></h2>
<p>在<a href="advance/concurrency-with-threads/../../advance/functional-programing/closure.html#move%E5%92%8CFn">闭包章节</a>中，有讲过<code>move</code>关键字在闭包中的使用可以让该闭包拿走环境中某个值的所有权，同样的，你可以使用<code>move</code>来将所有权从一个线程转移到另外一个线程。</p>
<p>首先，来看看在一个线程中直接使用另一个线程中的数据会如何：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<p>以上代码在子线程的闭包中捕获了环境中的<code>v</code>变量，来看看结果：</p>
<pre><code class="language-console">error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!(&quot;Here's a vector: {:?}&quot;, v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>其实代码本身并没有什么问题，问题在于Rust无法确定新的线程会活多久(多个线程的结束顺序并不是固定的)，所以也无法确定新线程所引用的<code>v</code>是否在使用过程中一直合法:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}
</code></pre></pre>
<p>大家要记住，线程的启动时间点和结束时间点是不确定的，因此假设上述代码可以正常运行，那么当<code>v</code>被释放掉时，新的线程很可能还没有结束甚至还没有被创建成功，此时新线程对<code>v</code>的引用立刻就不再合法！</p>
<p>好在报错里进行了提示：<code>to force the closure to take ownership of v (and any other referenced variables), use the move keyword</code>,让我们使用<code>move</code>关键字拿走<code>v</code>的所有权即可:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();

    // 下面代码会报错borrow of moved value: `v`
    // println!(&quot;{:?}&quot;,v);
}
</code></pre></pre>
<p>如上所示，很简单的代码，而且Rust的所有权机制保证了数据使用上的安全：<code>v</code>的所有权被转移给新的线程后，<code>main</code>线程将无法继续使用：最后一行代码将报错。</p>
<h2 id="线程是如何结束的"><a class="header" href="#线程是如何结束的">线程是如何结束的</a></h2>
<p>之前我们提到<code>main</code>线程是程序的主线程，一旦结束，则程序随之结束，同时各个子线程也将被强行终止。那么有一个问题，如果不是<code>main</code>线程，那么父线程的结束会导致什么？自生自灭还是被干掉？</p>
<p>在系统编程中，操作系统提供了直接杀死线程的接口，简单粗暴，但是Rust并没有提供这样的接口，原因在于，粗暴地终止一个线程可能会导致资源没有释放、状态混乱等不可预期的结果，一向以安全自称的Rust, 自然不会砸自己的饭碗。</p>
<p>那么Rust中线程是如何结束的呢？答案很简单：线程的代码执行完，线程就会自动结束。但是如果线程中的代码不会执行完呢？那么情况可以分为两种进行讨论:</p>
<ul>
<li>线程的任务是一个循环IO读取，任务流程类似: IO阻塞，等待读取新的数据 -&gt; 读到数据，处理完成 -&gt; 继续阻塞等待 ··· -&gt; 收到socket关闭的信号 -&gt; 结束线程, 在此过程中，绝大部分时间线程都处于阻塞的状态，因此虽然看上去是循环，CPU占用其实很小，也是网络服务中最最常见的模型</li>
<li>线程的任务是一个循环，里面没有任何阻塞，包括休眠这种操作也没有，此时cpu很不幸的会被跑满，而且你如果没有设置终止条件，该线程将持续跑满一个cpu核心, 并且不会被终止，直到<code>main</code>线程的结束</li>
</ul>
<p>第一情况很常见，我们来模拟看看第二种情况: </p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::time::Duration;
fn main() {
    // 创建一个线程
    let new_thread = thread::spawn(move || {
        // 再创建一个线程
        thread::spawn(move || {
            loop {
                println!(&quot;I am a new thread.&quot;);
            }
        })
    });

    // 等待新创建的线程执行完成
    new_thread.join().unwrap();
    println!(&quot;Child thread is finish!&quot;);

    // 睡眠一段时间，看子线程创建的子线程是否还在运行
    thread::sleep(Duration::from_millis(100));
}
</code></pre></pre>
<p>以上代码中，<code>main</code>线程创建了一个新的线程A，同时该新线程又创建了一个新的线程<code>B</code>，可以看到<code>A</code>线程在创建完<code>B</code>线程后就立即结束了，而<code>B</code>线程则在不停的循环输出。</p>
<p>从之前的线程结束规则，我们可以猜测程序将这样执行：<code>A</code>线程结束后，由它创建的<code>B</code>线程仍在疯狂输出，直到<code>main</code>线程在100毫秒后结束。如果你把该时间增加到几十秒，就可以看到你的CPU核心100%的盛况了-，-</p>
<h2 id="多线程的性能"><a class="header" href="#多线程的性能">多线程的性能</a></h2>
<p>下面我们从多个方面来看看多线程的性能大概是怎么样的。</p>
<h4 id="创建线程的性能"><a class="header" href="#创建线程的性能">创建线程的性能</a></h4>
<p>据不精确估算，创建一个线程大概需要0.24毫秒，随着线程的变多，这个值会变得更大，因此线程的创建耗时并不是不可忽略的，只有当真的需要处理一个值得用线程去处理的任务时，才使用线程。一些鸡毛蒜皮的任务，就无需创建线程了。</p>
<h4 id="创建多少线程合适"><a class="header" href="#创建多少线程合适">创建多少线程合适</a></h4>
<p>因为CPU的核心数限制，当任务是CPU密集型时，就算线程数超过了CPU核心数，也并不能帮你获得更好的性能，因为每个线程的任务都可以轻松让CPU的某个核心跑满，既然如此，让线程数等于CPU核心数是最好的。</p>
<p>但是当你的任务大部分时间都处于阻塞状态时，就可以考虑增多线程数量，这样当某个线程处于阻塞状态时，会被切走，进而运行其它的线程，典型就是网络IO操作，我们可以为每一个进来的用户连接创建一个线程去处理，该连接绝大部分时间都是处于IO读取阻塞状态，因此有限的CPU核心完全可以处理成百上千的用户连接线程，但是事实上，对于这种网络IO情况，一般都不再使用多线程的方式了，毕竟操作系统的线程数是有限的，意味着并发数也很容易达到上限，而且过多的线程也会导致线程上下文切换的代价过大，使用async/await的<code>M:N</code>并发模型，就没有这个烦恼。</p>
<h4 id="多线程的开销"><a class="header" href="#多线程的开销">多线程的开销</a></h4>
<p>下面的代码是一个无锁实现(CAS)的hashmap在多线程下的使用:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 0..num_threads {
    let ht = Arc::clone(&amp;ht);

    let handle = thread::spawn(move || {
        for j in 0..adds_per_thread {
            let key = thread_rng().gen::&lt;u32&gt;();
            let value = thread_rng().gen::&lt;u32&gt;();
            ht.set_item(key, value);
        }
    });

    handles.push(handle);
}

for handle in handles {
    handle.join().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>按理来说，既然是无锁实现了，那么锁的开销应该几乎没有，性能会随着线程数的增加几近线程增长，但是真的是这样吗？</p>
<p>下图是该代码在<code>48</code>核机器上的运行结果：</p>
<img alt="" src="advance/concurrency-with-threads//img/threads-02.png" class="center"  />
<p>从图上可以明显的看出： 吞吐并不是线性增长，尤其从16核开始，甚至开始肉眼可见的下降，这是为什么呢？</p>
<p>限于书本的篇幅有限，我们只能给出大概的原因：</p>
<ul>
<li>虽然是无锁，但是内部是CAS实现，大量线程的同时访问，会让CAS重试次数大幅增加</li>
<li>线程过多时，CPU缓存的命中率会显著下降, 同时多个线程竞争一个CPU Cache-line的情况也会经常发生</li>
<li>大量读写可能会让内存带宽也成为瓶颈</li>
<li>读和写不一样，无锁数据结构的读往往可以很好的线性增长，但是写不行，因为写竞争太大</li>
</ul>
<p>总之，多线程的开销往往是在锁、数据竞争、缓存失效上，这些限制了现代化软件系统随着CPU核心的增多性能也线性增加的野心。</p>
<h2 id="线程屏障barrier"><a class="header" href="#线程屏障barrier">线程屏障(Barrier)</a></h2>
<p>在Rust中，可以使用<code>Barrier</code>让多个线程都执行到某个点后，才继续一起往后执行:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::{Arc, Barrier};
use std::thread;

fn main() {
    let mut handles = Vec::with_capacity(6);
    let barrier = Arc::new(Barrier::new(6));

    for _ in 0..6 {
        let b = barrier.clone();
        handles.push(thread::spawn(move|| {
            println!(&quot;before wait&quot;);
            b.wait();
            println!(&quot;after wait&quot;);
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
</code></pre></pre>
<p>上面代码，我们在线程打印出<code>before wait</code>后增加了一个屏障，目的就是等所有的线程都打印出<strong>before wait</strong>后，各个线程再继续执行:</p>
<pre><code class="language-console">before wait
before wait
before wait
before wait
before wait
before wait
after wait
after wait
after wait
after wait
after wait
after wait
</code></pre>
<h2 id="线程局部变量thread-loval-variable"><a class="header" href="#线程局部变量thread-loval-variable">线程局部变量(Thread Loval Variable)</a></h2>
<p>对于多线程编程，线程局部变量在一些场景下非常有用，而Rust通过标准库和三方库对此进行了支持。</p>
<h4 id="标准库thread_local"><a class="header" href="#标准库thread_local">标准库thread_local</a></h4>
<p>使用<code>thread_local</code>宏可以初始化线程局部变量，然后在线程内部使用该变量的<code>with</code>方法获取变量值：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use std::thread;

thread_local!(static FOO: RefCell&lt;u32&gt; = RefCell::new(1));

FOO.with(|f| {
    assert_eq!(*f.borrow(), 1);
    *f.borrow_mut() = 2;
});

// 每个线程开始时都会拿到线程局部变量的FOO的初始值
let t = thread::spawn(move|| {
    FOO.with(|f| {
        assert_eq!(*f.borrow(), 1);
        *f.borrow_mut() = 3;
    });
});

// 等待线程完成
t.join().unwrap();

// 尽管子线程中修改为了3，我们在这里依然拥有main线程中的局部值：2
FOO.with(|f| {
    assert_eq!(*f.borrow(), 2);
});
<span class="boring">}
</span></code></pre></pre>
<p>上面代码中，<code>FOO</code>即是我们创建的<strong>线程局部变量</strong>，每个新的线程访问它时，都会使用它的初始值作为开始，各个线程中的<code>FOO</code>值彼此互不干扰。注意<code>FOO</code>使用<code>static</code>声明为生命周期为<code>'static</code>的静态变量。</p>
<p>可以注意到，线程中对<code>FOO</code>的使用是通过借用的方式，但是若我们需要每个线程独自获取它的拷贝，最后进行汇总，就有些强人所难了。</p>
<p>你还可以在结构体中使用线程局部变量：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;

struct Foo;
impl Foo {
    thread_local! {
        static FOO: RefCell&lt;usize&gt; = RefCell::new(0);
    }
}

fn main() {
    Foo::FOO.with(|x| println!(&quot;{:?}&quot;, x));
}
</code></pre></pre>
<p>或者通过引用的方式使用它:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use std::thread::LocalKey;

thread_local! {
    static FOO: RefCell&lt;usize&gt; = RefCell::new(0);
}
struct Bar {
    foo: &amp;'static LocalKey&lt;RefCell&lt;usize&gt;&gt;,
}
impl Bar {
    fn constructor() -&gt; Self {
        Self {
            foo: &amp;FOO,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="三方库thread-local"><a class="header" href="#三方库thread-local">三方库thread-local</a></h4>
<p>除了标准库外，一位大神还开发了<a href="https://github.com/Amanieu/thread_local-rs">thread-local</a>库，它允许每个线程持有值的独立拷贝:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thread_local::ThreadLocal;
use std::sync::Arc;
use std::cell::Cell;
use std::thread;

let tls = Arc::new(ThreadLocal::new());

// 创建多个线程
for _ in 0..5 {
    let tls2 = tls.clone();
    thread::spawn(move || {
        // 将计数器加1
        let cell = tls2.get_or(|| Cell::new(0));
        cell.set(cell.get() + 1);
    }).join().unwrap();
}

// 一旦所有子线程结束，收集它们的线程局部变量中的计数器值，然后进行求和
let tls = Arc::try_unwrap(tls).unwrap();
let total = tls.into_iter().fold(0, |x, y| x + y.get());

// 和为5
assert_eq!(total, 5);
<span class="boring">}
</span></code></pre></pre>
<p>该库不仅仅使用了值的拷贝，而且还能自动把多个拷贝汇总到一个迭代器中，最后进行求和，非常好用。</p>
<h2 id="用条件控制线程的挂起和执行"><a class="header" href="#用条件控制线程的挂起和执行">用条件控制线程的挂起和执行</a></h2>
<p>条件变量(Condition Variables)经常和<code>Mutex</code>一起使用，可以让线程挂起，直到某个条件发生后再继续执行:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::sync::{Arc, Mutex, Condvar};

fn main() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair2 = pair.clone();

    thread::spawn(move|| {
        let &amp;(ref lock, ref cvar) = &amp;*pair2;
        let mut started = lock.lock().unwrap();
        println!(&quot;changing started&quot;);
        *started = true;
        cvar.notify_one();
    });

    let &amp;(ref lock, ref cvar) = &amp;*pair;
    let mut started = lock.lock().unwrap();
    while !*started {
        started = cvar.wait(started).unwrap();
    }

    println!(&quot;started changed&quot;);
}
</code></pre></pre>
<p>上述代码流程如下：</p>
<ol>
<li><code>main</code>线程首先进入<code>while</code>循环，调用<code>wait</code>方法挂起等待子线程的通知，并释放了锁<code>started</code></li>
<li>子线程获取到锁，并将其修改为true, 然后调用条件变量的<code>notify_one</code>方法来通知主线程继续执行</li>
</ol>
<h2 id="只被调用一次的函数"><a class="header" href="#只被调用一次的函数">只被调用一次的函数</a></h2>
<p>有时，我们会需要某个函数在多线程环境下只被调用一次，例如初始化全局变量，无论是哪个线程先调用函数来初始化，都会保证全局变量只会被初始化一次，随后的其它线程调用就会忽略该函数:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::sync::{Once, ONCE_INIT};

static mut VAL: usize = 0;
static INIT: Once = ONCE_INIT;

fn main() {
    let handle1 = thread::spawn(move || {
        INIT.call_once(|| {
            unsafe {
                VAL = 1;
            }
        });
    });

    let handle2 = thread::spawn(move || {
        INIT.call_once(|| {
            unsafe {
                VAL = 2;
            }
        });
    });

    handle1.join().unwrap();
    handle2.join().unwrap();

    println!(&quot;{}&quot;, unsafe { VAL });
}
</code></pre></pre>
<p>代码运行的结果取决于哪个线程先调用<code>INIT.call_once</code>(虽然代码具有先后顺序，但是线程的初始化顺序并无法被保证！因为线程初始化是异步的，且耗时较久)，若<code>handle1</code>先，则输出<code>1</code>，否则输出<code>2</code>。</p>
<p><strong>call_once 方法</strong></p>
<p>执行初始化过程一次，并且只执行一次。</p>
<p>如果当前有另一个初始化过程正在运行，该方法将阻止调用的线程。</p>
<p>当这个函数返回时，保证一些初始化已经运行并完成，它还保证由执行的闭包所执行的任何内存写入都能被其他线程在这时可靠地观察到。</p>
<h2 id="总结-14"><a class="header" href="#总结-14">总结</a></h2>
<p><a href="advance/concurrency-with-threads/./intro.html">Rust的线程模型</a>是<code>1:1</code>模型，因为Rust要保持尽量小的运行时。</p>
<p>我们可以使用<code>thread::spawn</code>来创建线程，创建出的多个线程之间并不存在执行顺序关系，因此代码逻辑千万不要依赖于线程间的执行顺序。</p>
<p><code>main</code>线程若是结束，则所有子线程都将被终止，如果希望等待子线程结束后，再结束<code>main</code>线程，你需要使用创建线程时返回的句柄的<code>join</code>方法。</p>
<p>在线程中无法直接借用外部环境中的变量值，因为新线程的启动时间点和结束时间点是不确定的，这样Rust就无法保证该线程中借用的变量在使用过程中依然是合法的。你可以使用<code>move</code>关键字将变量的所有权转移给新的线程，来解决此问题。</p>
<p>父线程结束后，子线程仍在持续运行，直到子线程的代码运行完成或者<code>main</code>线程的结束。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线程间的消息传递"><a class="header" href="#线程间的消息传递">线程间的消息传递</a></h1>
<p>在多线程间有多种方式可以共享、传递数据，最常用的方式就是通过消息传递或者将锁和<code>Arc</code>联合使用，而对于前者，在编程界还有一个大名鼎鼎的<code>Actor线程模型</code>为其背书，典型的有Erlang语言，还有Go语言中很经典的一句话：</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating</p>
</blockquote>
<p>而对于后者，我们将在下一节中进行讲述。</p>
<h2 id="消息通道"><a class="header" href="#消息通道">消息通道</a></h2>
<p>与Go语言内置的<code>chan</code>不同，Rust是在标准库里提供了消息通道(<code>channel</code>)，你可以将其想象成一场直播，多个主播联合起来在搞一场直播，最终内容通过通道传输给屏幕前的我们，其中主播被称之为<strong>发送者</strong>，观众被称之为<strong>接收者</strong>，显而易见的是：一个通道应该支持多个发送者和接收者。</p>
<p>但是，在实际使用中，我们需要使用不同的库来满足诸如：<strong>多发送者 -&gt; 单接收者，多发送者 -&gt; 多接收者</strong>等场景形式，此时一个标准库显然就不够了，不过别急，让我们先从标准库讲起。</p>
<h2 id="多发送者单接收者"><a class="header" href="#多发送者单接收者">多发送者，单接收者</a></h2>
<p>标准库提供了通道<code>std::sync::mpsc</code>，其中<code>mpsc</code>是<em>multiple producer, single consumer</em>的缩写，代表了该通道支持多个发送者，但是只支持唯一的接收者。 当然，支持多个发送者也意味着支持单个发送者，我们先来看看单发送者、单接收者的简单例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc;
use std::thread;

fn main() {
    // 创建一个消息通道, 返回一个元组：(发送者，接收者)
    let (tx, rx) = mpsc::channel();

    // 创建线程，并发送消息
    thread::spawn(move || {
        // 发送一个数字1, send方法返回Result&lt;T,E&gt;，通过unwrap进行快速错误处理
        tx.send(1).unwrap();
        
        // 下面代码将报错，因为编译器自动推导出通道传递的值是i32类型，那么Option&lt;i32&gt;类型将产生不匹配错误
        // tx.send(Some(1)).unwrap()
    });

    // 在主线程中接收子线程发送的消息并输出
    println!(&quot;receive {}&quot;, rx.recv().unwrap());
}
</code></pre></pre>
<p>以上代码并不复杂，但仍有几点需要注意：</p>
<ul>
<li><code>tx</code>,<code>rx</code>对应发送者和接收者，它们的类型由编译器自动推导: <code>tx.send(1)</code>发送了整数，因此它们分别是<code>mpsc::Sender&lt;i32&gt;</code>和<code>mpsc::Receiver&lt;i32&gt;</code>类型，需要注意，由于内部是泛型实现，一旦类型被推导确定，该通道就只能传递对应类型的值, 例如此例中非<code>i32</code>类型的值将导致编译错误</li>
<li>接收消息的操作<code>rx.recv()</code>会阻塞当前线程，直到读取到值，或者通道被关闭</li>
<li>需要使用<code>move</code>将<code>tx</code>的所有权转移到子线程的闭包中</li>
</ul>
<p>在注释中提到<code>send</code>方法返回一个<code>Result&lt;T,E&gt;</code>，说明它有可能返回一个错误，例如接收者被<code>drop</code>导致了发送的值不会被任何人接收，此时继续发送毫无意义，因此返回一个错误最为合适，在代码中我们仅仅使用<code>unwrap</code>进行了快速处理，但在实际项目中你需要对错误进行进一步的处理。</p>
<p>同样的，对于<code>recv</code>方法来说，当发送者关闭时，它也会接收到一个错误，用于说明不会再有任何值被发送过来。</p>
<h2 id="不阻塞的try_recv方法"><a class="header" href="#不阻塞的try_recv方法">不阻塞的try_recv方法</a></h2>
<p>除了上述<code>recv</code>方法，还可以使用<code>try_recv</code>尝试接收一次消息，该方法并<strong>不会阻塞线程</strong>，当通道中没有消息时，它会立刻返回一个错误：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        tx.send(1).unwrap();
    });

    println!(&quot;receive {:?}&quot;, rx.try_recv());
}
</code></pre></pre>
<p>由于子线程的创建需要时间，因此<code>println!</code>和<code>try_recv</code>方法会先执行，而此时子线程的<strong>消息还未被发出</strong>。<code>try_recv</code>会尝试立即读取一次消息，因为消息没有发出，此次读取最终会报错，且主线程运行结束(可悲的是，相对于主线程中的代码，子线程的创建速度实在是过慢，直到主线程结束，都无法完成子线程的初始化。。):</p>
<pre><code class="language-console">receive Err(Empty)
</code></pre>
<p>如上，<code>try_recv</code>返回了一个错误，错误内容是<code>Empty</code>，代表通道并没有消息。如果你尝试把<code>println!</code>复制一些行，就会发现一个有趣的输出：</p>
<pre><code class="language-console">···
receive Err(Empty)
receive Ok(1)
receive Err(Disconnected)
···
</code></pre>
<p>如上，当子线程创建成功且发送消息后，主线程会接收到<code>Ok(1)</code>的消息内容，紧接着子线程结束，发送者也随着被<code>drop</code>，此时接收者又会报错，但是这次错误原因有所不同：<code>Disconnected</code>代表发送者已经被关闭。</p>
<h2 id="传输具有所有权的数据"><a class="header" href="#传输具有所有权的数据">传输具有所有权的数据</a></h2>
<p>使用通道来传输数据，一样要遵循Rust的所有权规则：</p>
<ul>
<li>若值的类型实现了<code>Copy</code>特征，则直接复制一份该值，然后传输过去，例如之前的<code>i32</code>类型</li>
<li>若值没有实现<code>Copy</code>，则它的所有权会被转移给接收端，在发送端继续使用该值将报错</li>
</ul>
<p>一起来看看第二种情况:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let s = String::from(&quot;我，飞走咯!&quot;);
        tx.send(s).unwrap();
        println!(&quot;val is {}&quot;, s);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre></pre>
<p>以上代码中，<code>String</code>底层的字符串是存储在堆上，并没有实现<code>Copy</code>特征，当它被发送后，会将所有权从发送端的<code>s</code>转移给接收端的<code>received</code>，之后<code>s</code>将无法被使用:</p>
<pre><code class="language-console">error[E0382]: borrow of moved value: `s`
  --&gt; src/main.rs:10:31
   |
8  |         let s = String::from(&quot;我，飞走咯!&quot;);
   |             - move occurs because `s` has type `String`, which does not implement the `Copy` trait // 所有权被转移，由于`String`没有实现`Copy`特征
9  |         tx.send(s).unwrap();
   |                 - value moved here // 所有权被转移走
10 |         println!(&quot;val is {}&quot;, s);
   |                               ^ value borrowed here after move // 所有权被转移后，依然对s进行了借用
</code></pre>
<p>各种细节不禁令人感叹：Rust还是安全！假如没有所有权的保护，<code>String</code>字符串将被两个线程同时持有，任何一个线程对字符串内容的修改都会导致另外一个线程持有的字符串被改变，除非你故意这么设计，否则这就是不安全的隐患。</p>
<h2 id="使用for进行循环接收"><a class="header" href="#使用for进行循环接收">使用for进行循环接收</a></h2>
<p>下面来看看如何连续接收通道中的值:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre></pre>
<p>在上面代码中，主线程和子线程是并发运行的，子线程在不停的<strong>发送消息 -&gt; 休眠1秒</strong>，与此同时，主线程使用<code>for</code>循环<strong>阻塞</strong>的从<code>rx</code><strong>迭代器</strong>中接收消息，当子线程运行完成时，发送者<code>tx</code>会随之被<code>drop</code>，此时<code>for</code>循环将被终止，最终<code>main</code>线程成功结束。</p>
<h3 id="使用多发送者"><a class="header" href="#使用多发送者">使用多发送者</a></h3>
<p>由于子线程会拿走发送者的所有权，因此我们必须对发送者进行克隆，然后让每个线程拿走它的一份拷贝:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();
    let tx1 = tx.clone();
    thread::spawn(move || {
        tx.send(String::from(&quot;hi from raw tx&quot;)).unwrap();
    });

    thread::spawn(move || {
        tx1.send(String::from(&quot;hi from cloned tx&quot;)).unwrap();
    });
    
    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre></pre>
<p>代码并无太大区别，就多了一个对发送者的克隆<code>let tx1 = tx.clone();</code>，然后一个子线程拿走<code>tx</code>的所有权，另一个子线程拿走<code>tx1</code>的所有权，皆大欢喜。</p>
<p>但是有几点需要注意:</p>
<ul>
<li>需要所有的发送者都被<code>drop</code>掉后，接收者<code>rx</code>才会收到错误，进而跳出<code>for</code>循环，最终结束主线程</li>
<li>这里虽然用了<code>clone</code>但是并不会影响性能，因为它并不在热点代码路径中，仅仅会被执行一次</li>
<li>由于两个子线程谁先创建完成是未知的，因此哪条消息先发送也是未知的，最终主线程的输出顺序也不确定</li>
</ul>
<h2 id="消息顺序"><a class="header" href="#消息顺序">消息顺序</a></h2>
<p>上述第三点的消息顺序仅仅是因为线程创建引起的，并不代表通道中的消息是无序的，对于通道而言，消息的发送顺序和接收顺序是一致的，满足<code>FIFO</code>原则(先进先出)。</p>
<p>由于篇幅有限，具体的代码这里就不再给出，感兴趣的读者可以自己验证下。</p>
<h2 id="同步和异步通道"><a class="header" href="#同步和异步通道">同步和异步通道</a></h2>
<p>Rust标准库的<code>mpsc</code>通道其实分为两种类型：同步和异步。</p>
<h4 id="异步通道"><a class="header" href="#异步通道">异步通道</a></h4>
<p>之前我们使用的都是异步通道：无论接收者是否正在接收消息，消息发送者在发送消息时都不会阻塞:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc;
use std::thread;
use std::time::Duration;
fn main() {
    let (tx, rx)= mpsc::channel();

    let handle = thread::spawn(move || {
        println!(&quot;发送之前&quot;);
        tx.send(1).unwrap();
        println!(&quot;发送之后&quot;);
    });

    println!(&quot;睡眠之前&quot;);
    thread::sleep(Duration::from_secs(3));
    println!(&quot;睡眠之后&quot;);

    println!(&quot;收到值 {}&quot;, rx.recv().unwrap());
    handle.join().unwrap();
}
</code></pre></pre>
<p>运行后输出如下:</p>
<pre><code class="language-console">睡眠之前
发送之前
发送之后
//···睡眠3秒
睡眠之后
收到值 1
</code></pre>
<p>主线程因为睡眠阻塞了3秒，因此并没有进行消息接收，而子线程却在此期间轻松完成了消息的发送。等主线程睡眠结束后，才姗姗来迟的从通道中接收了子线程老早之前发送的消息。</p>
<p>从输出还可以看出，<code>发送之前</code>和<code>发送之后</code>是连续输出的，没有受到接收端主线程的任何影响，因此通过<code>mpsc::channel</code>创建的通道是异步通道。</p>
<h4 id="同步通道"><a class="header" href="#同步通道">同步通道</a></h4>
<p>与异步通道相反，同步通道<strong>发送消息是阻塞的，只有在消息被接收后才解除阻塞</strong>，例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc;
use std::thread;
use std::time::Duration;
fn main() {
    let (tx, rx)= mpsc::sync_channel(0);

    let handle = thread::spawn(move || {
        println!(&quot;发送之前&quot;);
        tx.send(1).unwrap();
        println!(&quot;发送之后&quot;);
    });

    println!(&quot;睡眠之前&quot;);
    thread::sleep(Duration::from_secs(3));
    println!(&quot;睡眠之后&quot;);

    println!(&quot;receive {}&quot;, rx.recv().unwrap());
    handle.join().unwrap();
}
</code></pre></pre>
<p>运行后输出如下：</p>
<pre><code class="language-console">睡眠之前
发送之前
//···睡眠3秒
睡眠之后
收到值 1
发送之后
</code></pre>
<p>可以看出，主线程由于睡眠被阻塞导致无法接收消息，因此子线程的发送也一直被阻塞，直到主线程结束睡眠并成功接收消息后，发送才成功：<strong>发送之后</strong>的输出是在<strong>收到值 1</strong>之后，说明<strong>只有接收消息彻底成功后，发送消息才算完成</strong>。</p>
<h4 id="消息缓存"><a class="header" href="#消息缓存">消息缓存</a></h4>
<p>细心的读者可能已经发现在创建同步通道时，我们传递了一个参数<code>0</code>: <code>mpsc::sync_channel(0);</code>，这是什么意思呢？</p>
<p>答案不急给出，先将<code>0</code>改成<code>1</code>，然后再运行试试:</p>
<pre><code class="language-console">睡眠之前
发送之前
发送之后
睡眠之后
receive 1
</code></pre>
<p>纳尼。。竟然得到了和异步通道一样的效果：根本没有等待主线程的接收开始，消息发送就立即完成了！ 难道同步通道变成了异步通道？ 别急，将子线程中的代码修改下试试：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;首次发送之前&quot;);
tx.send(1).unwrap();
println!(&quot;首次发送之后&quot;);
tx.send(1).unwrap();
println!(&quot;再次发送之后&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>在子线程中，我们又多发了一条消息，此时输出如下：</p>
<pre><code class="language-console">睡眠之前
首次发送之前
首次发送之后
//···睡眠3秒
睡眠之后
receive 1
再次发送之后
</code></pre>
<p>Bingo，更奇怪的事出现了，第一条消息瞬间发送完成，没有阻塞，而发送第二条消息时却符合同步通道的特点：阻塞了，直到主线程接收后，才发送完成。</p>
<p>其实，一切的关键就在于<code>1</code>上，该值可以用来指定同步通道的消息缓存条数，当你设定为<code>N</code>时，发送者就可以无阻塞的往通道中发送<code>N</code>条消息，当消息缓冲队列满了后，新的消息发送将被阻塞(如果没有接收者消费缓冲队列中的消息，那么第<code>N+1</code>条消息就将触发发送阻塞)。</p>
<p>问题又来了，异步通道创建时完全没有这个缓冲值参数<code>mpsc::channel()</code>，它的缓冲值怎么设置呢？ 额。。。都异步了，都可以无限发送了，都有摩托车了，还要自行车做啥子哦？事实上异步通道的缓冲上限取决于你的内存大小，不要撑爆就行。</p>
<p>因此，使用异步消息虽然能非常高效且不会造成发送线程的阻塞，但是存在消息未及时消费，最终内存过大的问题。在实际项目中，可以考虑使用一个带缓冲值的同步通道来避免这种风险。</p>
<h2 id="关闭通道"><a class="header" href="#关闭通道">关闭通道</a></h2>
<p>之前我们数次提到了通道关闭，并且提到了当通道关闭后，发送消息或接收消息将会报错。那么如何关闭通道呢？ 很简单：<strong>所有发送者被<code>drop</code>或者所有接收者被<code>drop</code>后，通道会自动关闭</strong>。</p>
<p>神奇的是，这件事是在编译期实现的，完全没有运行期性能损耗！只能说Rust的<code>Drop</code>特征YYDS!</p>
<h2 id="传输多种类型的数据"><a class="header" href="#传输多种类型的数据">传输多种类型的数据</a></h2>
<p>之前提到过，一个消息通道只能传输一种类型的数据，如果你想要传输多种类型的数据，可以为每个类型创建一个通道，你也可以使用枚举类型来实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc::{self, Receiver, Sender};

enum Fruit {
    Apple(u8),
    Orange(String)
}

fn main() {
    let (tx, rx): (Sender&lt;Fruit&gt;, Receiver&lt;Fruit&gt;) = mpsc::channel();

    tx.send(Fruit::Orange(&quot;sweet&quot;.to_string())).unwrap();
    tx.send(Fruit::Apple(2)).unwrap();

    for _ in 0..2 {
        match rx.recv().unwrap() {
            Fruit::Apple(count) =&gt; println!(&quot;received {} apples&quot;, count),
            Fruit::Orange(flavor) =&gt; println!(&quot;received {} oranges&quot;, flavor),
        }
    }
}
</code></pre></pre>
<p>如上所示，枚举类型还能让我们带上想要传输的数据，但是有一点需要注意，Rust会按照枚举中占用内存最大的那个成员进行内存对齐，这意味着就算你传输的是枚举中占用内存最小的成员，它占用的内存依然和最大的成员相同, 因此会造成内存上的浪费。</p>
<h2 id="新手容易遇到的坑"><a class="header" href="#新手容易遇到的坑">新手容易遇到的坑</a></h2>
<p><code>mpsc</code>虽然相当简洁明了，但是在使用起来还是可能存在坑：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc;
fn main() {

    use std::thread;
    
    let (send, recv) = mpsc::channel();
    let num_threads = 3;
    for i in 0..num_threads {
        let thread_send = send.clone();
        thread::spawn(move || {
            thread_send.send(i).unwrap();
            println!(&quot;thread {:?} finished&quot;, i);
        });
    }
    
    // 在这里drop send...
    
    for x in recv {
        println!(&quot;Got: {}&quot;, x);
    }
    println!(&quot;finished iterating&quot;);
}
</code></pre></pre>
<p>以上代码看起来非常正常，但是运行后主线程会一直阻塞，最后一行打印输出也不会被执行，原因在于： 子线程拿走的是复制后的<code>send</code>的所有权，这些拷贝会在子线程结束后被<code>drop</code>，因此无需担心，但是<code>send</code>本身却直到<code>main</code>函数的结束才会被<code>drop</code>。</p>
<p>之前提到，通道关闭的两个条件：发送者全部<code>drop</code>或接收者被<code>drop</code>，要结束<code>for</code>循环显然是要求发送者全部<code>drop</code>，但是由于<code>send</code>自身没有被<code>drop</code>，会导致该循环永远无法结束，最终主线程会一直阻塞。</p>
<p>解决办法很简单，<code>drop</code>掉<code>send</code>即可：在代码中的注释下面添加一行<code>drop(send);</code>。</p>
<h2 id="mpmc-更好的性能"><a class="header" href="#mpmc-更好的性能">mpmc 更好的性能</a></h2>
<p>如果你需要mpmc(多发送者，多接收者)或者需要更高的性能，可以考虑第三方库:</p>
<ul>
<li><a href="https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel"><strong>crossbeam-channel</strong></a>, 老牌强库，功能较全，性能较强，之前是独立的库，但是后面合并到了<code>crossbeam</code>主仓库中</li>
<li><a href="https://github.com/zesterer/flume"><strong>flume</strong></a>, 官方给出的性能数据某些场景要比crossbeam更好些</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线程同步锁condvar和信号量"><a class="header" href="#线程同步锁condvar和信号量">线程同步：锁、Condvar和信号量</a></h1>
<p>在多线程编程中，同步性极其的重要，当你需要同时访问一个资源、控制不同线程的执行次序时，都需要使用到同步性。</p>
<p>在Rust中有多种方式可以实现同步性。在上一节中讲到的消息传递就是同步性的一种实现方式，例如我们可以通过消息传递来控制不同线程间的执行次序。还可以使用共享内存来实现同步性，例如通过锁和原子操作等并发原语来实现多个线程同时且安全地去访问一个资源。</p>
<h2 id="该如何选择"><a class="header" href="#该如何选择">该如何选择</a></h2>
<p>共享内存可以说是同步的灵魂，因为消息传递的底层实际上也是通过共享内存来实现，两者的区别如下：</p>
<ul>
<li>共享内存相对消息传递能节省多次内存拷贝的成本</li>
<li>共享内存的实现简洁的多</li>
<li>共享内存的锁竞争更多</li>
</ul>
<p>消息传递适用的场景很多，我们下面列出了几个主要的使用场景:</p>
<ul>
<li>需要可靠和简单的(简单不等于简洁)实现时</li>
<li>需要模拟现实世界，例如用消息去通知某个目标执行相应的操作时</li>
<li>需要一个任务处理流水线(管道)时，等等</li>
</ul>
<p>而使用共享内存(并发原语)的场景往往就比较简单粗暴：需要简洁的实现以及更高的性能时。</p>
<p>总之，消息传递类似一个单所有权的系统：一个值同时只能有一个所有者，如果另一个线程需要该值的所有权，需要将所有权通过消息传递进行转移。而共享内存类似于一个多所有权的系统：多个线程可以同时访问同一个值。 </p>
<h2 id="互斥锁mutex"><a class="header" href="#互斥锁mutex">互斥锁Mutex</a></h2>
<p>既然是共享内存，那并发原语自然是重中之重，先来一起看看皇冠上的明珠: 互斥锁<code>Mutex</code>(mutual exclusion的缩写)。</p>
<p><code>Mutex</code>让多个线程并发的访问同一个值变成了排队访问：同一时间，只允许一个线程<code>A</code>访问该值，其它线程需要等待<code>A</code>访问完成后才能继续。</p>
<h4 id="单线程中使用mutex"><a class="header" href="#单线程中使用mutex">单线程中使用Mutex</a></h4>
<p>先来看看单线程中<code>Mutex</code>该如何使用: </p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::Mutex;

fn main() {
    // 使用`Mutex`结构体的关联函数创建新的互斥锁实例
    let m = Mutex::new(5);

    {
        // 获取锁，然后deref为`m`的引用
        // lock返回的是Result
        let mut num = m.lock().unwrap();
        *num = 6;
        // 锁自动被drop
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<p>在注释中，已经大致描述了代码的功能，不过有一点需要注意：和<code>Box</code>类似，数据被<code>Mutex</code>所拥有，要访问内部的数据，需要使用方法<code>m.lock()</code>向<code>m</code>申请一个锁, 该方法会<strong>阻塞当前线程，直到获取到锁</strong>，因此当多个线程同时访问该数据时，只有一个线程能获取到锁，其它线程只能阻塞着等待，这样就保证了数据能被安全的修改！</p>
<p><strong><code>m.lock()</code>方法也有可能报错</strong>，例如当前正在持有锁的线程<code>panic</code>了。在这种情况下，其它线程不可能再获得锁，因此<code>lock</code>方法会返回一个错误。</p>
<p>这里你可能奇怪，<code>m.lock</code>明明返回一个锁，怎么就变成我们的<code>num</code>数值了？聪明的读者可能会想到智能指针，没错，因为<code>Mutex&lt;T&gt;</code>是一个智能指针，准确的说是<code>m.lock()</code>返回一个智能指针<code>MutexGuard&lt;T&gt;</code>:</p>
<ul>
<li>它实现了<code>Deref</code>特征，会被自动解引用后获得一个引用类型，该引用指向<code>Mutex</code>内部的数据</li>
<li>它还实现了<code>Drop</code>特征，在超出作用域后，自动释放锁，以便其它线程能继续获取锁</li>
</ul>
<p>正因为智能指针的使用，使得我们无需任何操作就能获取其中的数据。 如果释放锁，你需要做的仅仅是做好锁的作用域管理，例如上述代码的内部花括号使用，建议读者尝试下去掉内部的花括号，然后再次尝试获取第二个锁<code>num1</code>，看看会发生什么，友情提示：不会报错，但是主线程会永远阻塞，因为不幸发生了死锁。</p>
<h4 id="多线程中使用mutex"><a class="header" href="#多线程中使用mutex">多线程中使用Mutex</a></h4>
<p>单线程中使用锁，说实话纯粹是为了演示功能，毕竟多线程才是锁的舞台。 现在，我们再来看看，如何在多线程下使用<code>Mutex</code>来访问同一个资源.</p>
<h5 id="无法运行的rct"><a class="header" href="#无法运行的rct">无法运行的<code>Rc&lt;T&gt;</code></a></h5>
<pre><pre class="playground"><code class="language-rust edition2021">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    // 通过`Rc`实现`Mutex`的多所有权
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        // 创建子线程，并将`Mutex`的所有权拷贝传入到子线程中
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    // 等待所有子线程完成
    for handle in handles {
        handle.join().unwrap();
    }

    // 输出最终的计数结果
    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<p>由于子线程需要通过<code>move</code>拿走锁的所有权，因此我们需要使用多所有权来保证每个线程都拿到数据的独立所有权，恰好智能指针<a href="advance/concurrency-with-threads/../smart-pointer/rc-arc.html"><code>Rc&lt;T&gt;</code></a>可以做到(<strong>上面代码会报错</strong>！具体往下看，别跳过-, -)。</p>
<p>以上代码实现了在多线程中计数的功能，由于多个线程都需要去修改该计数器，因此我们需要使用锁来保证同一时间只有一个线程可以修改计数器，否则会导致脏数据：想象一下A线程和B线程同时拿到计数器，获取了当前值<code>1</code>, 并且同时对其进行了修改，最后值变成<code>2</code>，你会不会在风中凌乱？毕竟正确的值是<code>3</code>，因为两个线程各自加1。</p>
<p>可能有人会说，有那么巧的事情吗？事实上，对于人类来说，因为干啥啥慢，并没有那么多巧合，所以人总会存在巧合心理。但是对于计算机而言，每秒可以轻松运行上亿次，在这种频次下，一切巧合几乎都将必然发生，因此千万不要有任何侥幸心理。</p>
<blockquote>
<p>如果事情有变坏的可能，不管这种可能性有多小，它都会发生！ - 在计算机领域歪打正着的墨菲定律</p>
</blockquote>
<p>事实上，上面的代码会报错:</p>
<pre><code class="language-console">error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely 
                // `Rc`无法在线程中安全的传输
   --&gt; src/main.rs:11:22
    |
11  |           let handle = thread::spawn(move || {
    |  ______________________^^^^^^^^^^^^^_-
    | |                      |
    | |                      `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
12  | |             let mut num = counter.lock().unwrap();
13  | |
14  | |             *num += 1;
15  | |         });
    | |_________- within this `[closure@src/main.rs:11:36: 15:10]`
    |
    = help: within `[closure@src/main.rs:11:36: 15:10]`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`
     // `Rc`没有实现`Send`特征
    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10]`
</code></pre>
<p>错误中提到了一个关键点：<code>Rc&lt;T&gt;</code>无法在线程中传输，因为它没有实现<code>Send</code>特征(在下一节将详细介绍)，而该特征可以确保数据在线程中安全的传输。</p>
<h5 id="多线程安全的arc"><a class="header" href="#多线程安全的arc">多线程安全的Arc<T></a></h5>
<p>好在，我们有<code>Arc&lt;T&gt;</code>，得益于它的<a href="advance/concurrency-with-threads/../smart-pointer/rc-arc.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%97%A0%E5%8A%9B%E7%9A%84rc">内部计数器</a>是多线程安全的，因此可以在多线程环境中使用:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<p>以上代码可以顺利运行:</p>
<pre><code class="language-console">Result: 10
</code></pre>
<h4 id="内部可变性-1"><a class="header" href="#内部可变性-1">内部可变性</a></h4>
<p>在之前章节，我们提到过<a href="advance/concurrency-with-threads/../smart-pointer/cell-refcell.html#%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7">内部可变性</a>，其中<code>Rc&lt;T&gt;</code>和<code>RefCell&lt;T&gt;</code>的结合，可以实现单线程的内部可变性。</p>
<p>现在我们又有了新的武器，由于<code>Mutex&lt;T&gt;</code>可以支持修改内部数据，当结合<code>Arc&lt;T&gt;</code>一起使用时，可以实现多线程的内部可变性。</p>
<p>简单总结下：<code>Rc&lt;T&gt;/RefCell&lt;T&gt;</code>用于单线程内部可变性， <code>Arc&lt;T&gt;/Mutext&lt;T&gt;</code>用于多线程内部可变性。</p>
<h4 id="需要小心使用的mutex"><a class="header" href="#需要小心使用的mutex">需要小心使用的Mutex</a></h4>
<p>如果有其它语言的编程经验，就知道互斥锁这家伙不好对付，想要正确使用，你得牢记在心：</p>
<ul>
<li>在使用数据前必须先获取锁</li>
<li>在数据使用完成后，必须<strong>及时</strong>的释放锁，比如文章开头的例子，使用内部语句块的目的就是为了及时的释放锁</li>
</ul>
<p>这两点看起来不起眼，但要正确的使用，其实是相当不简单的，对于其它语言，忘记释放锁是经常发生的，虽然Rust通过智能指针的<code>drop</code>机制帮助我们避免了这一点，但是由于不及时释放锁导致的性能问题也是常见的。</p>
<p>正因为这种困难性，导致很多用户都热衷于使用消息传递的方式来实现同步，例如Go语言直接把<code>channel</code>内置在语言特性中，甚至还有无锁的语言，例如<code>erlang</code>，完全使用<code>Actor</code>模型，依赖消息传递来完成共享和同步。幸好Rust的类型系统、所有权机制、智能指针等可以很好的帮助我们减轻使用锁时的负担。</p>
<p>另一个值的注意的是在使用<code>Mutex&lt;T&gt;</code>时，Rust无法帮我们避免所有的逻辑错误，例如在之前章节，我们提到过使用<code>Rc&lt;T&gt;</code>可能会导致<a href="advance/concurrency-with-threads/../circle-self-ref/circle-reference.html">循环引用的问题</a>。类似的，<code>Mutex&lt;T&gt;</code>也存在使用上的风险，例如创建死锁(deadlock)：当一个操作试图锁住两个资源，然后两个线程各自获取其中一个锁，并试图获取另一个锁时，就会造成死锁。</p>
<h2 id="死锁"><a class="header" href="#死锁">死锁</a></h2>
<p>在Rust中有多种方式可以创建死锁，了解这些方式有助于你提前规避可能的风险，一起来看看。</p>
<h4 id="单线程死锁"><a class="header" href="#单线程死锁">单线程死锁</a></h4>
<p>这种死锁比较容易规避，但是当代码复杂后还是有可能遇到：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::Mutex;

fn main() {
    let data = Mutex::new(0);
    let d1 = data.lock();
    let d2 = data.lock();
} // d1锁在此处释放
</code></pre></pre>
<p>非常简单，只要你在另一个锁还未被释放时去申请新的锁，就会触发，当代码复杂后，这种情况可能就没有那么显眼。</p>
<h4 id="多线程死锁"><a class="header" href="#多线程死锁">多线程死锁</a></h4>
<p>当我们拥有两个锁，且两个线程各自使用了其中一个锁，然后试图去访问另一个锁时，就可能发生死锁：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::{sync::{Mutex, MutexGuard}, thread};
use std::thread::sleep;
use std::time::Duration;

use lazy_static::lazy_static;
lazy_static! {
    static ref MUTEX1: Mutex&lt;i64&gt; = Mutex::new(0);
    static ref MUTEX2: Mutex&lt;i64&gt; = Mutex::new(0);
}

fn main() {
    // 存放子线程的句柄
    let mut children = vec![];
    for i_thread in 0..2 {
        children.push(thread::spawn(move || {
            for _ in 0..1 {
                // 线程1
                if i_thread % 2 == 0 {
                    // 锁住mutex1
                    let guard: MutexGuard&lt;i64&gt; = MUTEX1.lock().unwrap();

                    println!(&quot;线程 {} 锁住了mutex1，接着准备去锁mutex2 !&quot;, i_thread);

                    // 当前线程睡眠一小会儿，等待线程2锁住mutex2
                    sleep(Duration::from_millis(10));

                    // 去锁mutex2
                    let guard = MUTEX2.lock().unwrap();
                // 线程2
                } else {
                    // 锁住mutex2
                    let _guard = MUTEX2.lock().unwrap();

                    println!(&quot;线程 {} 锁住了mutex2, 准备去锁mutex1&quot;, i_thread);

                    let _guard = MUTEX1.lock().unwrap();
                }
            }
        }));
    }

    // 等子线程完成
    for child in children {
        let _ = child.join();
    }

    println!(&quot;死锁没有发生&quot;);
}
</code></pre></pre>
<p>在上面的描述中，我们用了&quot;可能&quot;二字，原因在于死锁在这段代码中不是必然发生的，总有一次运行你能看到最后一行打印输出。这是由于子线程的初始化顺序和执行速度并不确定，我们无法确定哪个线程中的锁先被执行，因此也无法确定两个线程对锁的具体使用顺序。</p>
<p>但是，可以简单的说明下死锁发生的必然条件：线程1锁住了<code>mutex1</code>并且线程<code>2</code>锁住了<code>mutex2</code>，然后线程1试图去访问<code>mutex2</code>，同时线程<code>2</code>试图去访问<code>mutex1</code>，就会死锁。 因为线程2需要等待线程1释放<code>mutex1</code>后，才会释放<code>mutex2</code>，而与此同时，线程1需要等待线程2释放<code>mutex2</code>后才能释放<code>mutex1</code>，这种情况造成了两个线程都无法释放对方需要的锁，最终死锁。</p>
<p>那么为何某些时候，死锁不会发生？原因很简单，线程2在线程1锁<code>mutex1</code>之前，就已经全部执行完了，随之线程2的<code>mutex2</code>和<code>mutex1</code>被全部释放，线程1对锁的获取将不再有竞争者。 同理，线程1若全部被执行完，那线程2也不会被锁，因此我们在线程1中间加一个睡眠，增加死锁发生的概率。如果你在线程2中同样的位置也增加一个睡眠，那死锁将必然发生!</p>
<h4 id="try_lock"><a class="header" href="#try_lock">try_lock</a></h4>
<p>与<code>lock</code>方法不同，<code>try_lock</code>会<strong>尝试</strong>去获取一次锁，如果无法获取会返回一个错误，因此<strong>不会发生阻塞</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::{sync::{Mutex, MutexGuard}, thread};
use std::thread::sleep;
use std::time::Duration;

use lazy_static::lazy_static;
lazy_static! {
    static ref MUTEX1: Mutex&lt;i64&gt; = Mutex::new(0);
    static ref MUTEX2: Mutex&lt;i64&gt; = Mutex::new(0);
}

fn main() {
    // 存放子线程的句柄
    let mut children = vec![];
    for i_thread in 0..2 {
        children.push(thread::spawn(move || {
            for _ in 0..1 {
                // 线程1
                if i_thread % 2 == 0 {
                    // 锁住mutex1
                    let guard: MutexGuard&lt;i64&gt; = MUTEX1.lock().unwrap();

                    println!(&quot;线程 {} 锁住了mutex1，接着准备去锁mutex2 !&quot;, i_thread);

                    // 当前线程睡眠一小会儿，等待线程2锁住mutex2
                    sleep(Duration::from_millis(10));

                    // 去锁mutex2
                    let guard = MUTEX2.try_lock();
                    println!(&quot;线程1获取mutex2锁的结果: {:?}&quot;,guard);
                // 线程2
                } else {
                    // 锁住mutex2
                    let _guard = MUTEX2.lock().unwrap();

                    println!(&quot;线程 {} 锁住了mutex2, 准备去锁mutex1&quot;, i_thread);
                    sleep(Duration::from_millis(10));
                    let guard = MUTEX1.try_lock();
                    println!(&quot;线程2获取mutex1锁的结果: {:?}&quot;,guard);
                }
            }
        }));
    }

    // 等子线程完成
    for child in children {
        let _ = child.join();
    }

    println!(&quot;死锁没有发生&quot;);
}
</code></pre></pre>
<p>为了演示<code>try_lock</code>的作用，我们特定使用了之前必定会死锁的代码，并且将<code>lock</code>替换成<code>try_lock</code>，与之前的结果不同，这段代码将不会再有死锁发生：</p>
<pre><code class="language-console">线程 0 锁住了mutex1，接着准备去锁mutex2 !
线程 1 锁住了mutex2, 准备去锁mutex1
线程2获取mutex1锁的结果: Err(&quot;WouldBlock&quot;)
线程1获取mutex2锁的结果: Ok(0)
死锁没有发生
</code></pre>
<p>如上所示，当<code>try_lock</code>失败时，会报出一个错误:<code>Err(&quot;WouldBlock&quot;)</code>，接着线程中的剩余代码会继续执行，不会被阻塞。</p>
<blockquote>
<p>一个有趣的命名规则：在Rust标准库中，使用<code>try_xxx</code>都会尝试进行一次操作，如果无法完成，就立即返回，不会发生阻塞。例如消息传递章节中的<code>try_recv</code>以及本章节中的<code>try_lock</code></p>
</blockquote>
<h2 id="读写锁rwlock"><a class="header" href="#读写锁rwlock">读写锁RwLock</a></h2>
<p><code>Mutex</code>会对每次读写都进行加锁，但某些时候，我们需要大量的并发读，<code>Mutex</code>就无法满足需求了，此时就可以使用<code>RwLock</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::RwLock;

fn main() {
    let lock = RwLock::new(5);

    // 同一时间允许多个读
    {
        let r1 = lock.read().unwrap();
        let r2 = lock.read().unwrap();
        assert_eq!(*r1, 5);
        assert_eq!(*r2, 5);
    } // 读锁在此处被drop

    // 同一时间只允许一个写
    {
        let mut w = lock.write().unwrap();
        *w += 1;
        assert_eq!(*w, 6);
        
        // 以下代码会panic，因为读和写不允许同时存在
        // 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于`w`的作用域中
        // let r1 = lock.read();
        // println!(&quot;{:?}&quot;,r1);
    }// 写锁在此处被drop
}
</code></pre></pre>
<p><code>RwLock</code>在使用上和<code>Mutex</code>区别不大，需要注意的是，当读写同时发生时，程序会直接<code>panic</code>(本例是单线程，实际上多个线程中也是如此)，因为会发生死锁：</p>
<pre><code class="language-console">thread 'main' panicked at 'rwlock read lock would result in deadlock', /rustc/efec545293b9263be9edfb283a7aa66350b3acbf/library/std/src/sys/unix/rwlock.rs:49:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>好在我们可以使用<code>try_write</code>和<code>try_read</code>来尝试进行一次写/读，若失败则返回错误:</p>
<pre><code class="language-console">Err(&quot;WouldBlock&quot;)
</code></pre>
<p>简单总结下<code>RwLock</code>:</p>
<ol>
<li>同时允许多个读，但最多只能有一个写</li>
<li>读和写不能同时存在</li>
<li>读可以使用<code>read</code>、<code>try_read</code>，写<code>write</code>、<code>try_write</code>, 在实际项目中，<code>try_xxx</code>会安全的多</li>
</ol>
<h2 id="mutex还是rwlock"><a class="header" href="#mutex还是rwlock">Mutex还是RwLock</a></h2>
<p>首先简单性上<code>Mutex</code>完胜，因为使用<code>RwLock</code>你得操心几个问题：</p>
<ul>
<li>读和写不能同时发生，如果使用<code>try_xxx</code>解决，就必须做大量的错误处理和失败重试机制</li>
<li>当读多写少时，写操作可能会因为一直无法获得锁导致连续多次失败(<a href="https://stackoverflow.com/questions/2190090/how-to-prevent-writer-starvation-in-a-read-write-lock-in-pthreads">writer starvation</a>)</li>
<li>RwLock其实是操作系统提供的，实现原理要比<code>Mutex</code>复杂的多，因此单就锁的性能而言，比不上原生实现的<code>Mutex</code></li>
</ul>
<p>再来简单总结下两者的使用场景：</p>
<ul>
<li>追求高并发读取时，使用<code>RwLock</code>，因为<code>Mutex</code>一次只允许一个线程去读取</li>
<li>如果要保证写操作的成功性，使用<code>Mutex</code></li>
<li>不知道哪个合适，统一使用<code>Mutex</code></li>
</ul>
<p>需要注意的是，<code>RwLock</code>虽然看上去貌似提供了高并发读取的能力，但这个不能说明它的性能比<code>Mutex</code>高，事实上<code>Mutex</code>性能要好不少，后者<strong>唯一的问题也仅仅在于不能并发读取</strong>。</p>
<p>一个常见的、错误的使用<code>RwLock</code>的场景就是使用<code>HashMap</code>进行简单读写，因为<code>HashMap</code>的读和写都非常快，<code>RwLock</code>的复杂实现和相对低的性能反而会导致整体性能的降低，因此一般来说更适合使用<code>Mutex</code>。</p>
<p>总之，如果你要使用<code>RwLock</code>要确保满足以下两个条件：<strong>并发读，且需要对读到的资源进行&quot;长时间&quot;的操作</strong>，<code>HashMap</code>也许满足了并发读的需求，但是往往并不能满足后者：&quot;长时间&quot;的操作。</p>
<blockquote>
<p>benchmark永远是你在迷茫时最好的朋友！</p>
</blockquote>
<h2 id="三方库提供的锁实现"><a class="header" href="#三方库提供的锁实现">三方库提供的锁实现</a></h2>
<p>标准库在设计时总会存在取舍，因为往往性能并不是最好的，如果你追求性能，可以使用三方库提供的并发原语:</p>
<ul>
<li><a href="https://crates.io/crates/parking_lot">parking_lot</a>, 功能更完善、稳定，社区较为活跃，star较多，更新较为活跃</li>
<li><a href="https://crates.io/crates/spin">spin</a>, 在多数场景中性能比<code>parking_lot</code>高一点，最近没怎么更新</li>
</ul>
<p>如果不是追求特别极致的性能，建议选择前者。</p>
<h2 id="用条件变量condvar控制线程的同步"><a class="header" href="#用条件变量condvar控制线程的同步">用条件变量(Condvar)控制线程的同步</a></h2>
<p><code>Mutex</code>用于解决资源安全访问的问题，但是我们还需要一个手段来解决资源访问顺序的问题。而Rust考虑到了这一点，为我们提供了条件变量(Condition Variables)，它经常和<code>Mutex</code>一起使用，可以让线程挂起，直到某个条件发生后再继续执行，其实<code>Condvar</code>我们在之前的多线程章节就已经见到过，现在再来看一个不同的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::{Arc,Mutex,Condvar};
use std::thread::{spawn,sleep};
use std::time::Duration;

fn main() {
    let flag = Arc::new(Mutex::new(false));
    let cond = Arc::new(Condvar::new());
    let cflag = flag.clone();
    let ccond = cond.clone();

    let hdl = spawn(move || {
        let mut m = { *cflag.lock().unwrap() };
        let mut counter = 0;

        while counter &lt; 3 {
            while !m {
                m = *ccond.wait(cflag.lock().unwrap()).unwrap();
            }

            {
                m = false;
                *cflag.lock().unwrap() = false;
            }

            counter += 1;
            println!(&quot;inner counter: {}&quot;, counter);
        }
    });

    let mut counter = 0;
    loop {
        sleep(Duration::from_millis(1000));
        *flag.lock().unwrap() = true;
        counter += 1;
        if counter &gt; 3 {
            break;
        }
        println!(&quot;outside counter: {}&quot;, counter);
        cond.notify_one();
    }
    hdl.join().unwrap();
    println!(&quot;{:?}&quot;, flag);
}
</code></pre></pre>
<p>例子中通过主线程来触发子线程实现交替打印输出：</p>
<pre><code class="language-console">outside counter: 1
inner counter: 1
outside counter: 2
inner counter: 2
outside counter: 3
inner counter: 3
Mutex { data: true, poisoned: false, .. }
</code></pre>
<h2 id="信号量semaphore"><a class="header" href="#信号量semaphore">信号量Semaphore</a></h2>
<p>在多线程中，另一个重要的概念就是信号量，使用它可以让我们精准的控制当前正在运行的任务最大数量。想象一下，当一个新游戏刚开服时(有些较火的老游戏也会，比如<code>wow</code>)，往往会控制游戏内玩家的同时在线数，一旦超过某个临界值，就开始进行排队进服。而在实际使用中，也有很多时候，我们需要通过信号量来控制最大并发数，防止服务器资源被撑爆。</p>
<p>本来Rust在标准库中有提供一个<a href="https://doc.rust-lang.org/1.8.0/std/sync/struct.Semaphore.html">信号量实现</a>, 但是由于各种原因这个库现在已经不再推荐使用了，因此我们推荐使用<code>tokio</code>中提供的<code>Semaphone</code>实现: <a href="https://github.com/tokio-rs/tokio/blob/master/tokio/src/sync/semaphore.rs"><code>tokio::sync::Semaphore</code></a>。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::Arc;
use tokio::sync::Semaphore;

#[tokio::main]
async fn main() {
    let semaphore = Arc::new(Semaphore::new(3));
    let mut join_handles = Vec::new();

    for _ in 0..5 {
        let permit = semaphore.clone().acquire_owned().await.unwrap();
        join_handles.push(tokio::spawn(async move {
            //
            // 在这里执行任务...
            //
            drop(permit);
        }));
    }

    for handle in join_handles {
        handle.await.unwrap();
    }
}
</code></pre></pre>
<p>上面代码创建了一个容量为3的信号量，当正在执行的任务超过3时，剩下的任务需要等待正在执行任务完成并减少信号量后到3以内时，才能继续执行。</p>
<p>这里的关键其实说白了就在于：信号量的申请和归还，使用前需要申请信号量，如果容量满了，就需要等待；使用后需要释放信号量，以便其它等待者可以继续。</p>
<h2 id="总结-15"><a class="header" href="#总结-15">总结</a></h2>
<p>在很多时候，消息传递都是非常好用的手段，它可以让我们的数据在任务流水线上不断流转，实现起来非常优雅。</p>
<p>但是它并不能优雅的解决所有问题，因为我们面临的真实世界是非常复杂的，无法用某一种银弹统一解决。当面临消息传递不太适用的场景时，或者需要更好的性能和简洁性时，我们往往需要用锁来解决这些问题，因为锁允许多个线程同时访问同一个资源，简单粗暴。</p>
<p>除了锁之外，其实还有一种并发原语可以帮助我们解决并发访问数据的问题，那就是原子类型Atomic，在下一章节中，我们会对其进行深入讲解。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线程同步atomic原子类型与内存顺序"><a class="header" href="#线程同步atomic原子类型与内存顺序">线程同步：Atomic原子类型与内存顺序</a></h1>
<p><code>Mutex</code>用起来简单，但是无法并发读，<code>RwLock</code>可以并发读，但是使用场景较为受限且性能不够，那么有没有一种全能性选手呢？ 欢迎我们的<code>Atomic</code>闪亮登场。</p>
<p>从Rust1.34版本后，就正式支持原子类型。原子指的是一系列不可被CPU上下文交换的机器指令，这些指令组合在一起就形成了原子操作。在多核CPU下，当某个CPU核心开始运行原子操作时，会先暂停其它CPU内核对内存的操作，以保证原子操作不会被其它CPU内核所干扰。</p>
<p>由于原子操作是通过指令提供的支持，因此它的性能相比锁和消息传递会好很多。相比较于锁而言，原子类型不需要开发者处理加锁和释放锁的问题，同时支持修改，读取等操作，还具备较高的并发性能，几乎所有的语言都支持原子类型。</p>
<p>可以看出原子类型是无锁类型，但是无锁不代表无需等待，因为原子类型内部使用了<code>CAS</code>循环，当大量的冲突发生时，该等待还是得<a href="advance/concurrency-with-threads/./thread.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%80%E9%94%80">等待</a>！但是总归比锁要好。</p>
<blockquote>
<p>CAS全称是Compare and swap, 它通过一条指令读取指定的内存地址，然后判断其中的值是否等于给定的前置值，如果相等，则将其修改为新的值</p>
</blockquote>
<h2 id="使用atomic作为全局变量"><a class="header" href="#使用atomic作为全局变量">使用Atomic作为全局变量</a></h2>
<p>原子类型的一个常用场景，就是作为全局变量来使用:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Sub;
use std::sync::atomic::{AtomicU64, Ordering};
use std::thread::{self, JoinHandle};
use std::time::Instant;

const N_TIMES: u64 = 10000000;
const N_THREADS: usize = 10;

static R: AtomicU64 = AtomicU64::new(0);

fn add_n_times(n: u64) -&gt; JoinHandle&lt;()&gt; {
    thread::spawn(move || {
        for _ in 0..n {
            R.fetch_add(1, Ordering::Relaxed);
        }
    })
}

fn main() {
    let s = Instant::now();
    let mut threads = Vec::with_capacity(N_THREADS);

    for _ in 0..N_THREADS {
        threads.push(add_n_times(N_TIMES));
    }

    for thread in threads {
        thread.join().unwrap();
    }

    assert_eq!(N_TIMES * N_THREADS as u64, R.load(Ordering::Relaxed));

    println!(&quot;{:?}&quot;,Instant::now().sub(s));
}
</code></pre></pre>
<p>以上代码启动了数个线程，每个线程都在疯狂对全局变量进行加1操作, 最后将它与<code>线程数 * 加1次数</code>进行比较，如果发生了因为多个线程同时修改导致了脏数据，那么这两个必将不相等。好在，它没有让我们失望，不仅快速的完成了任务，而且保证了100%的并发安全性。</p>
<p>当然以上代码的功能其实也可以通过<code>Mutex</code>来实现，但是后者的强大功能是建立在额外的性能损耗基础上的，因此性能会逊色不少:</p>
<pre><code class="language-console">Atomic实现：673ms
Mutex实现: 1136ms
</code></pre>
<p>可以看到<code>Atomic</code>实现会比<code>Mutex</code>快<strong>41%</strong>，实际上在复杂场景下还能更快(甚至达到4倍的性能差距)！</p>
<p>还有一点值得注意: <strong>和<code>Mutex</code>一样，<code>Atomic</code>的值具有内部可变性</strong>，你无需将其声明为<code>mut</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::Mutex;
use std::sync::atomic::{Ordering, AtomicU64};
 
struct Counter {
    count: u64
}
 
fn main() {
    let n = Mutex::new(Counter {
        count: 0
    });
 
    n.lock().unwrap().count += 1;
 
    let n = AtomicU64::new(0);
 
    n.fetch_add(0, Ordering::Relaxed);
}
</code></pre></pre>
<p>这里有一个奇怪的枚举成员<code>Ordering::Relaxed</code>, 看上去很像是排序作用，但是我们并没有做排序操作啊？实际上它用于控制原子操作使用的<strong>内存顺序</strong>。</p>
<h2 id="内存顺序"><a class="header" href="#内存顺序">内存顺序</a></h2>
<p>内存顺序是指CPU在访问内存时的顺序，该顺序可能受以下因素的影响：</p>
<ul>
<li>代码中的先后顺序</li>
<li>编译器优化导致在编译阶段发生改变(内存重排序reordering)</li>
<li>运行阶段因CPU的缓存机制导致顺序被打乱</li>
</ul>
<h4 id="编译器优化导致内存顺序的改变"><a class="header" href="#编译器优化导致内存顺序的改变">编译器优化导致内存顺序的改变</a></h4>
<p>对于第二点，我们举个例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">static mut X: u64 = 0;
static mut Y: u64 = 1;

fn main() {
    ...     // A

    unsafe {
        ... // B
        X = 1;
        ... // C
        Y = 3;
        ... // D
        X = 2;
        ... // E
    }
}
</code></pre></pre>
<p>假如在<code>C</code>和<code>D</code>代码片段中，根本没有用到<code>X = 1</code>，那么编译器很可能会将<code>X = 1</code>和<code>X = 2</code>进行合并:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> ...     // A
 
unsafe {
    ... // B
    X = 2;
    ... // C
    Y = 3;
    ... // D
    ... // E
}
<span class="boring">}
</span></code></pre></pre>
<p>若代码<code>A</code>中创建了一个新的线程用于读取全局静态变量<code>X</code>，则该线程将无法读取到<code>X = 1</code>的结果，因为在编译阶段就已经被优化掉。</p>
<h4 id="cpu缓存导致的内存顺序的改变"><a class="header" href="#cpu缓存导致的内存顺序的改变">CPU缓存导致的内存顺序的改变</a></h4>
<p>假设之前的<code>X = 1</code>没有被优化掉，并且在代码片段<code>A</code>中有一个新的线程:</p>
<pre><code class="language-console">initial state: X = 0, Y = 1
 
THREAD Main     THREAD A
X = 1;          if X == 1 {
Y = 3;              Y *= 2;
X = 2;          }
</code></pre>
<p>我们来讨论下以上线程状态，<code>Y</code>最终的可能值(可能性依次降低):</p>
<ul>
<li><code>Y = 3</code>: 线程<code>Main</code>运行完后才运行线程<code>A</code>，或者线程<code>A</code>运行完后再运行线程<code>Main</code></li>
<li><code>Y = 6</code>: 线程<code>Main</code>的<code>Y = 3</code>运行完，但<code>X = 2</code>还没被运行， 此时线程A开始运行<code>Y *= 2</code>, 最后才运行<code>Main</code>线程的<code>X = 2</code></li>
<li><code>Y = 2</code>: 线程<code>Main</code>正在运行<code>Y = 3</code>还没结束，此时线程<code>A</code>正在运行<code>Y *= 2</code>, 因此<code>Y</code>取到了值1，然后<code>Main</code>的线程将<code>Y</code>设置为3， 紧接着就被线程<code>A</code>的<code>Y = 2</code>所覆盖</li>
<li><code>Y = 2</code>: 上面的还只是一般的数据竞争，这里虽然产生了相同的结果<code>2</code>，但是背后的原理大相径庭: 线程<code>Main</code>运行完<code>Y = 3</code>，但是CPU缓存中的<code>Y = 3</code>还没有被同步到其它CPU缓存中，此时线程<code>A</code>中的<code>Y *= 2</code>就开始读取<code>Y</code>，结果读到了值<code>1</code>，最终计算出结果<code>2</code></li>
</ul>
<p>甚至更改成:</p>
<pre><code class="language-console">initial state: X = 0, Y = 1
 
THREAD Main     THREAD A
X = 1;          if X == 2 {
Y = 3;              Y *= 2;
X = 2;          }
</code></pre>
<p>还是可能出现<code>Y=2</code>，因为<code>Main</code>线程中的<code>X</code>和<code>Y</code>被同步到其它CPU缓存中的顺序未必一致。</p>
<h4 id="限定内存顺序的5个规则"><a class="header" href="#限定内存顺序的5个规则">限定内存顺序的5个规则</a></h4>
<p>在理解了内存顺序可能存在的改变后，你就可以明白为什么Rust提供了<code>Ordering::Relaxed</code>用于限定内存顺序了，事实上，该枚举有5个成员:</p>
<ul>
<li><strong>Relaxed</strong>， 这是最宽松的规则，它对编译器和CPU不做任何限制，可以乱序</li>
<li><strong>Release 释放</strong>，设定内存屏障(Memory barrier)，保证它之前的操作永远在它之前，但是它后面的操作可能被重排到它前面</li>
<li><strong>Acquire 获取</strong>, 设定内存屏障，保证在它之后的访问永远在它之后，但是它之前的操作却有可能被重排到它后面，往往和<code>Release</code>在不同线程中联合使用</li>
<li><strong>AcqRel</strong>, <strong>Acquire</strong>和<strong>Release</strong>的结合，同时拥有它们俩提供的保证。比如你要对一个 <code>atomic</code> 自增 1，同时希望该操作之前和之后的读取或写入操作不会被重新排序</li>
<li><strong>SeqCst 顺序一致性</strong>， <code>SeqCst</code>就像是<code>AcqRel</code>的加强版，它不管原子操作是属于读取还是写入的操作，只要某个线程有用到<code>SeqCst</code>的原子操作，线程中该<code>SeqCst</code>操作前的数据操作绝对不会被重新排在该<code>SeqCst</code>操作之后，且该<code>SeqCst</code>操作后的数据操作也绝对不会被重新排在<code>SeqCst</code>操作前。</li>
</ul>
<p>这些规则由于是系统提供的，因此其它语言提供的相应规则也大同小异，大家如果不明白可以看看其它语言的相关解释。</p>
<h4 id="内存屏障的例子"><a class="header" href="#内存屏障的例子">内存屏障的例子</a></h4>
<p>下面我们以<code>Release</code>和<code>Acquire</code>为例，使用它们构筑出一对内存屏障，防止编译器和CPU将屏障前(Release)和屏障后(Acquire)中的数据操作重新排在屏障围成的范围之外:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread::{self, JoinHandle};
use std::sync::atomic::{Ordering, AtomicBool};
 
static mut DATA: u64 = 0;
static READY: AtomicBool = AtomicBool::new(false);
 
fn reset() {
    unsafe {
        DATA = 0;
    }
    READY.store(false, Ordering::Relaxed);
}
 
fn producer() -&gt; JoinHandle&lt;()&gt; {
    thread::spawn(move || {
        unsafe {
            DATA = 100;                                 // A
        }
        READY.store(true, Ordering::Release);           // B: 内存屏障 ↑
    })
}
 
fn consumer() -&gt; JoinHandle&lt;()&gt; {
    thread::spawn(move || {
        while !READY.load(Ordering::Acquire) {}         // C: 内存屏障 ↓
 
        assert_eq!(100, unsafe { DATA });               // D
    })
}
 
 
fn main() {
    loop {
        reset();
 
        let t_producer = producer();
        let t_consumer = consumer();
 
        t_producer.join().unwrap();
        t_consumer.join().unwrap();
    }
}
</code></pre></pre>
<p>原则上，<code>Acquire</code>用于读取，而<code>Release</code>用于写入。但是由于有些原子操作同时拥有读取和写入的功能，此时就需要使用<code>AcqRel</code>来设置内存顺序了。在内存屏障中被写入的数据，都可以被其它线程读取到，不会有CPU缓存的问题。</p>
<p><strong>内存顺序的选择</strong></p>
<ol>
<li>不知道怎么选择时，优先使用<code>SeqCst</code>，虽然会稍微减慢速度，但是慢一点也比出现错误好</li>
<li>多线程只计数<code>fetch_add</code>而不使用该值触发其他逻辑分支的简单使用场景，可以使用<code>Relaxed</code><br />
参考 <a href="https://stackoverflow.com/questions/30407121/which-stdsyncatomicordering-to-use">Which std::sync::atomic::Ordering to use?</a></li>
</ol>
<h2 id="多线程中使用atomic"><a class="header" href="#多线程中使用atomic">多线程中使用Atomic</a></h2>
<p>在多线程环境中要使用<code>Atomic</code>需要配合<code>Arc</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::{hint, thread};

fn main() {
    let spinlock = Arc::new(AtomicUsize::new(1));

    let spinlock_clone = Arc::clone(&amp;spinlock);
    let thread = thread::spawn(move|| {
        spinlock_clone.store(0, Ordering::SeqCst);
    });

    // 等待其它线程释放锁
    while spinlock.load(Ordering::SeqCst) != 0 {
        hint::spin_loop();
    }

    if let Err(panic) = thread.join() {
        println!(&quot;Thread had an error: {:?}&quot;, panic);
    }
}
</code></pre></pre>
<h2 id="atomic能替代锁吗"><a class="header" href="#atomic能替代锁吗">Atomic能替代锁吗</a></h2>
<p>那么原子类型既然这么全能，它可以替代锁吗？答案是不行：</p>
<ul>
<li>对于复杂的场景下，锁的使用简单粗暴，不容易有坑</li>
<li><code>std::sync::atomic</code>包中仅提供了数值类型的原子操作：<code>AtomicBool</code>, <code>AtomicIsize</code>, <code>AtomicUsize</code>, <code>AtomicI8</code>, <code>AtomicU16</code>等，而锁可以应用于各种类型</li>
<li>在有些情况下，必须使用锁来配合，例如上一章节中使用<code>Mutex</code>配合<code>Condvar</code></li>
</ul>
<h2 id="atomic的应用场景"><a class="header" href="#atomic的应用场景">Atomic的应用场景</a></h2>
<p>事实上，<code>Atomic</code>虽然对于用户不太常用，但是对于高性能库的开发者、标准库开发者都非常常用，它是并发原语的基石，除此之外，还有一些场景适用：</p>
<ul>
<li>无锁(lock free)数据结构</li>
<li>全局变量，例如全局自增ID, 在后续章节会介绍</li>
<li>跨线程计数器，例如可以用于统计指标</li>
</ul>
<p>以上列出的只是<code>Atomic</code>适用的部分场景，具体场景需要大家未来根据自己的需求进行权衡选择。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基于send和sync的线程安全"><a class="header" href="#基于send和sync的线程安全">基于Send和Sync的线程安全</a></h1>
<p>为何Rc、RefCell和原生指针不可以在多线程间使用？如何让原生指针可以在多线程使用？我们一起来探寻下这些问题的答案。</p>
<h2 id="无法用于多线程的rc"><a class="header" href="#无法用于多线程的rc">无法用于多线程的<code>Rc</code></a></h2>
<p>先来看一段多线程使用<code>Rc</code>的代码:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::rc::Rc;
fn main() {
    let v = Rc::new(5);
    let t = thread::spawn(move || {
        println!(&quot;{}&quot;,v);
    });

    t.join().unwrap();
}
</code></pre></pre>
<p>以上代码将<code>v</code>的所有权通过<code>move</code>转移到子线程中，看似正确实则会报错：</p>
<pre><code class="language-console">error[E0277]: `Rc&lt;i32&gt;` cannot be sent between threads safely
------ 省略部分报错 --------
    = help: within `[closure@src/main.rs:5:27: 7:6]`, the trait `Send` is not implemented for `Rc&lt;i32&gt;`
</code></pre>
<p>表面原因是<code>Rc</code>无法在线程间安全的转移，实际是编译器给予我们的那句帮助: <code>the trait Send is not implemented for Rc&lt;i32&gt;</code>(<code>Rc&lt;i32&gt;</code>未实现<code>Send</code>特征), 那么此处的<code>Send</code>特征又是何方神圣？</p>
<h2 id="rc和arc源码对比"><a class="header" href="#rc和arc源码对比">Rc和Arc源码对比</a></h2>
<p>在介绍<code>Send</code>特征之前，再来看看<code>Arc</code>为何可以在多线程使用，玄机在于两者的源码实现上：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rc源码片段
impl&lt;T: ?Sized&gt; !marker::Send for Rc&lt;T&gt; {}
impl&lt;T: ?Sized&gt; !marker::Sync for Rc&lt;T&gt; {}

// Arc源码片段
unsafe impl&lt;T: ?Sized + Sync + Send&gt; Send for Arc&lt;T&gt; {}
unsafe impl&lt;T: ?Sized + Sync + Send&gt; Sync for Arc&lt;T&gt; {}
<span class="boring">}
</span></code></pre></pre>
<p><code>!</code>代表移除特征的相应实现，上面代码中<code>Rc&lt;T&gt;</code>的<code>Send</code>和<code>Sync</code>特征被特地移除了实现，而<code>Arc&lt;T&gt;</code>则相反，实现了<code>Sync + Send</code>，再结合之前的编译器报错，大概可以明白了：<code>Send</code>和<code>Sync</code>是在线程间安全使用一个值的关键。</p>
<h2 id="send和sync"><a class="header" href="#send和sync">Send和Sync</a></h2>
<p><code>Send</code>和<code>Sync</code>是Rust安全并发的重中之重，但是实际上它们只是标记特征(marker trait，该特征未定义任何行为，因此非常适合用于标记), 来看看它们的作用：</p>
<ul>
<li>实现<code>Send</code>的类型可以在线程间安全的传递其所有权</li>
<li>实现了<code>Sync</code>的类型可以在线程间安全的共享(通过引用)</li>
</ul>
<p>这里还有一个潜在的依赖：一个类型要在线程间安全的共享的前提是，指向它的引用必须能在线程间传递。因为如果引用都不能被传递，我们就无法在多个线程间使用引用去访问同一个数据了。</p>
<p>由上可知，<strong>若类型T的引用<code>&amp;T</code>是<code>Send</code>，则<code>T</code>是<code>Sync</code></strong>。</p>
<p>没有例子的概念讲解都是耍流氓，来看看<code>RwLock</code>的实现:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe impl&lt;T: ?Sized + Send + Sync&gt; Sync for RwLock&lt;T&gt; {}
<span class="boring">}
</span></code></pre></pre>
<p>首先<code>RwLock</code>可以在线程间安全的共享，那它肯定是实现了<code>Sync</code>，但是我们的关注点不在这里。众多周知，<code>RwLock</code>可以并发的读，说明其中的值<code>T</code>必定也可以在线程间共享，那<code>T</code>必定要实现<code>Sync</code>。</p>
<p>果不其然，上述代码中，<code>T</code>的特征约束中就有一个<code>Sync</code>特征，那问题又来了，<code>Mutex</code>是不是相反？再来看看:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe impl&lt;T: ?Sized + Send&gt; Sync for Mutex&lt;T&gt; {}
<span class="boring">}
</span></code></pre></pre>
<p>不出所料，<code>Mutex&lt;T&gt;</code>中的<code>T</code>并没有<code>Sync</code>特征约束。</p>
<p>武学秘籍再好，不见生死也是花拳绣腿。同样的，我们需要通过实战来彻底掌握<code>Send</code>和<code>Sync</code>，但在实战之前，先来简单看看有哪些类型实现了它们。</p>
<h2 id="实现send和sync的类型"><a class="header" href="#实现send和sync的类型">实现<code>Send</code>和<code>Sync</code>的类型</a></h2>
<p>在Rust中，几乎所有类型都默认实现了<code>Send</code>和<code>Sync</code>，而且由于这两个特征都是可自动派生的特征(通过<code>derive</code>派生)，意味着一个复合类型(例如结构体), 只要它内部的所有成员都实现了<code>Send</code>或者<code>Sync</code>，那么它就自动实现了<code>Send</code>或<code>Sync</code>。</p>
<p>正是因为以上规则，Rust中绝大多数类型都实现了<code>Send</code>和<code>Sync</code>，除了以下几个(事实上不止这几个，只不过它们比较常见):</p>
<ul>
<li>原生指针两者都没实现，因为它本身就没有任何安全保证</li>
<li><code>UnsafeCell</code>不是<code>Sync</code>，因此<code>Cell</code>和<code>RefCell</code>也不是</li>
<li><code>Rc</code>两者都没实现(因为内部的引用计数器不是线程安全的)</li>
</ul>
<p>当然，如果是自定义的复合类型，那没实现那哥俩的就较为常见了：<strong>只要复合类型中有一个成员不是<code>Send</code>或<code>Sync</code>，那么该符合类型也就不是<code>Send</code>或<code>Sync</code></strong>。</p>
<p><strong>手动实现 <code>Send</code> 和 <code>Sync</code> 是不安全的</strong>，通常并不需要手动实现 Send 和 Sync trait，实现者需要使用<code>unsafe</code>小心维护并发安全保证。</p>
<p>至此，相关的概念大家已经掌握，但是我敢肯定，对于这两个滑不溜秋的家伙，大家依然会非常模糊，不知道它们该如何使用。那么我们来一起看看如何让原生指针可以在线程间安全的使用。</p>
<h2 id="为原生指针实现send"><a class="header" href="#为原生指针实现send">为原生指针实现<code>Send</code></a></h2>
<p>上面我们提到原生指针既没实现<code>Send</code>，意味着下面代码会报错:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
fn main() {
    let p = 5 as *mut u8;
    let t = thread::spawn(move || {
        println!(&quot;{:?}&quot;,p);
    });

    t.join().unwrap();
}
</code></pre></pre>
<p>报错跟之前无二： <code>*mut u8 cannot be sent between threads safely</code>, 但是有一个问题，我们无法为其直接实现<code>Send</code>特征，好在可以用<a href="advance/concurrency-with-threads/../custom-type.html#newtype"><code>newtype</code>类型</a> :<code>struct MyBox(*mut u8);</code>。</p>
<p>还记得之前的规则吗：复合类型中有一个成员没实现<code>Send</code>，该复合类型就不是<code>Send</code>，因此我们需要手动为它实现:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;

#[derive(Debug)]
struct MyBox(*mut u8);
unsafe impl Send for MyBox {}
fn main() {
    let p = MyBox(5 as *mut u8);
    let t = thread::spawn(move || {
        println!(&quot;{:?}&quot;,p);
    });

    t.join().unwrap();
}
</code></pre></pre>
<p>此时，我们的指针已经可以欢快的在多线程间撒欢，以上代码很简单，但有一点需要注意：<code>Send</code>和<code>Sync</code>是<code>unsafe</code>特征，实现时需要用<code>unsafe</code>代码块包裹。</p>
<h2 id="为原生指针实现sync"><a class="header" href="#为原生指针实现sync">为原生指针实现<code>Sync</code></a></h2>
<p>由于<code>Sync</code>是多线程间共享一个值，大家可能会想这么实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
fn main() {
    let v = 5;
    let t = thread::spawn(|| {
        println!(&quot;{:?}&quot;,&amp;v);
    });

    t.join().unwrap();
}
</code></pre></pre>
<p>关于这种用法，在多线程章节也提到过，线程如果直接去借用其它线程的变量，会报错:<code>closure may outlive the current function,</code>, 原因在于编译器无法确定主线程<code>main</code>和子线程<code>t</code>谁的生命周期更长，特别是当两个线程都是子线程时，没有任何人知道哪个子线程会先结束，包括编译器！</p>
<p>因此我们得配合<code>Arc</code>去使用:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::sync::Arc;
use std::sync::Mutex;

#[derive(Debug)]
struct MyBox(*const u8);
unsafe impl Send for MyBox {}

fn main() {
    let b = &amp;MyBox(5 as *const u8);
    let v = Arc::new(Mutex::new(b));
    let t = thread::spawn(move || {
        let _v1 =  v.lock().unwrap();
    });

    t.join().unwrap();
}
</code></pre></pre>
<p>上面代码将智能指针<code>v</code>的所有权转移给新线程，同时<code>v</code>包含了一个引用类型<code>b</code>，当在新的线程中试图获取内部的引用时，会报错：</p>
<pre><code class="language-console">error[E0277]: `*const u8` cannot be shared between threads safely
--&gt; src/main.rs:25:13
|
25  |     let t = thread::spawn(move || {
|             ^^^^^^^^^^^^^ `*const u8` cannot be shared between threads safely
|
= help: within `MyBox`, the trait `Sync` is not implemented for `*const u8`
</code></pre>
<p>因为我们访问的引用实际上还是对主线程中的数据的借用，转移进来的仅仅是外层的智能指针引用。要解决很简单，为<code>MyBox</code>实现<code>Sync</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe impl Sync for MyBox {}
<span class="boring">}
</span></code></pre></pre>
<h2 id="总结-16"><a class="header" href="#总结-16">总结</a></h2>
<p>通过上面的两个原生指针的例子，我们了解了如何实现<code>Send</code>和<code>Sync</code>，以及如何只实现<code>Send</code>而不实现<code>Sync</code>，简单总结下：</p>
<ol>
<li>实现<code>Send</code>的类型可以在线程间安全的传递其所有权, 实现<code>Sync</code>的类型可以在线程间安全的共享(通过引用)</li>
<li>绝大部分类型都实现了<code>Send</code>和<code>Sync</code>，常见的未实现的有：原生指针、Cell/RefCell、Rc等</li>
<li>可以为自定义类型实现<code>Send</code>和<code>Sync</code>，但是需要<code>unsafe</code>代码块</li>
<li>可以为部分Rust中的类型实现<code>Send</code>、<code>Sync</code>，但是需要使用<code>newtype</code>，例如文中的原生指针例子</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实践应用多线程web服务器-todo"><a class="header" href="#实践应用多线程web服务器-todo">实践应用：多线程Web服务器 todo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe"><a class="header" href="#unsafe">unsafe</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raw-pointer"><a class="header" href="#raw-pointer">raw pointer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffi外部语言用"><a class="header" href="#ffi外部语言用">FFI外部语言用</a></h1>
<p>https://www.reddit.com/r/rust/comments/s3x1e3/const_const_u8/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全局变量"><a class="header" href="#全局变量">全局变量</a></h1>
<p>在一些场景，我们可能需要全局变量来简化状态共享的代码，包括全局ID，全局数据存储等等，下面一起来看看有哪些创建全局变量的方法。</p>
<p>首先，有一点可以肯定，全局变量的生命周期肯定是<code>'static</code>，但是不代表它需要用<code>static</code>来声明，例如常量、字符串字面值等无需使用<code>static</code>进行声明，原因是它们已经被打包到二进制可执行文件中。</p>
<p>下面我们从编译期初始化及运行期初始化两个类别来介绍下全局变量有哪些类型及该如何使用。</p>
<h2 id="编译期初始化"><a class="header" href="#编译期初始化">编译期初始化</a></h2>
<p>我们大多数使用的全局变量都只需要在编译期初始化即可，例如静态配置、计数器、状态值等等。</p>
<h4 id="静态常量"><a class="header" href="#静态常量">静态常量</a></h4>
<p>全局常量可以在程序任何一部分使用，当然，如果它是定义在某个模块中，你需要引入对应的模块才能使用。常量，顾名思义它是不可变的，很适合用作静态配置：</p>
<pre><pre class="playground"><code class="language-rust edition2021">const MAX_ID: usize =  usize::MAX / 2;
fn main() {
   println!(&quot;用户ID允许的最大值是{}&quot;,MAX_ID);
}
</code></pre></pre>
<p><strong>常量与普通变量的区别</strong></p>
<ul>
<li>关键字是<code>const</code>而不是<code>let</code></li>
<li>定义常量必须指明类型（如i32）不能省略</li>
<li>定义常量时变量的命名规则一般是全部大写</li>
<li>常量可以在任意作用域进行定义，其生命周期贯穿整个程序的生命周期。编译时编译器会尽可能将其内联到代码中，所以在不同地方对同一常量的引用并不能保证引用到相同的内存地址</li>
<li>常量的赋值只能是常量表达式/数学表达式，也就是说必须是在编译期就能计算出的值，如果需要在运行时才能得出结果的值比如函数，则不能赋值给常量表达式</li>
<li>对于变量出现重复的定义(绑定)会发生变量遮盖，后面定义的变量会遮住前面定义的变量，常量则不允许出现重复的定义</li>
</ul>
<h4 id="静态变量"><a class="header" href="#静态变量">静态变量</a></h4>
<p>静态变量允许声明一个全局的变量，常用于全局数据统计，例如我们希望用一个变量来统计程序当前的总请求数：</p>
<pre><pre class="playground"><code class="language-rust edition2021">static mut REQUEST_RECV: usize = 0;
fn main() {
   unsafe {
        REQUEST_RECV += 1;
        assert_eq!(REQUEST_RECV, 1);
   }
}
</code></pre></pre>
<p>Rust要求必须使用<code>unsafe</code>语句块才能访问和修改<code>static</code>变量，因为这种使用方式往往并不安全，其实编译器是对的，当在多线程中同时去修改时，会不可避免的遇到脏数据。</p>
<p>只有在同一线程内或者不在乎数据的准确性时，才应该使用全局静态变量。</p>
<p>和常量相同，定义静态变量的时候必须赋值为在编译期就可以计算出的值(常量表达式/数学表达式)，不能是运行时才能计算出的值(如函数)</p>
<p><strong>静态变量和常量的区别</strong></p>
<ul>
<li>静态变量不会被内联，在整个程序中，静态变量只有一个实例，所有的引用都会指向同一个地址</li>
<li>存储在静态变量中的值必须要实现Sync trait</li>
</ul>
<h4 id="原子类型"><a class="header" href="#原子类型">原子类型</a></h4>
<p>想要全局计数器、状态控制等功能，又想要线程安全的实现，原子类型是非常好的办法。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::atomic::{AtomicUsize, Ordering};
static REQUEST_RECV: AtomicUsize  = AtomicUsize::new(0);
fn main() {
    for _ in 0..100 {
        REQUEST_RECV.fetch_add(1, Ordering::Relaxed);
    }
  
    println!(&quot;当前用户请求数{:?}&quot;,REQUEST_RECV);
}
</code></pre></pre>
<p>关于原子类型的讲解看<a href="advance/./concurrency-with-threads/sync2.html">这篇文章</a></p>
<h4 id="示例全局id生成器"><a class="header" href="#示例全局id生成器">示例：全局ID生成器</a></h4>
<p>来看看如何使用上面的内容实现一个全局ID生成器:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{Ordering, AtomicUsize};

struct Factory{
    factory_id: usize,
}

static GLOBAL_ID_COUNTER: AtomicUsize = AtomicUsize::new(0);
const MAX_ID: usize = usize::MAX / 2;

fn generate_id()-&gt;usize{
    // 检查两次溢出，否则直接加一可能导致溢出
    let current_val = GLOBAL_ID_COUNTER.load(Ordering::Relaxed);
    if current_val &gt; MAX_ID{
        panic!(&quot;Factory ids overflowed&quot;);
    }
    let next_id = GLOBAL_ID_COUNTER.fetch_add(1, Ordering::Relaxed);
    if next_id &gt; MAX_ID{
        panic!(&quot;Factory ids overflowed&quot;);
    }
    next_id
}

impl Factory{
    fn new()-&gt;Self{
        Self{
            factory_id: generate_id()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="运行期初始化"><a class="header" href="#运行期初始化">运行期初始化</a></h2>
<p>以上的静态初始化有一个致命的问题：无法用函数进行静态初始化，例如你如果想声明一个全局的<code>Mutex</code>锁：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::Mutex;
static names: Mutex&lt;String&gt; = Mutex::new(String::from(&quot;Sunface, Jack, Allen&quot;));

fn main() {
    let v = names.lock().unwrap();
    println!(&quot;{}&quot;,v);
}
</code></pre></pre>
<p>运行后报错如下：</p>
<pre><code class="language-console">error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants
 --&gt; src/main.rs:3:42
  |
3 | static names: Mutex&lt;String&gt; = Mutex::new(String::from(&quot;sunface&quot;));
</code></pre>
<p>但你又必须在声明时就对<code>names</code>进行初始化，此时就陷入了两难的境地。好在天无绝人之路，我们可以使用<code>lazy_static</code>包来解决这个问题。</p>
<h4 id="lazy_static"><a class="header" href="#lazy_static">lazy_static</a></h4>
<p><a href="https://github.com/rust-lang-nursery/lazy-static.rs"><code>lazy_static</code></a>是社区提供的非常强大的宏，用于懒初始化静态变量，之前的静态变量都是在编译器初始化的，因此无法使用函数调用进行赋值，而<code>lazy_static</code>允许我们在运行期初始化静态变量！</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::Mutex;
use lazy_static::lazy_static;
lazy_static! {
    static ref names: Mutex&lt;String&gt; = Mutex::new(String::from(&quot;Sunface, Jack, Allen&quot;));
}

fn main() {
    let mut v = names.lock().unwrap();
    v.push_str(&quot;, Myth&quot;);
    println!(&quot;{}&quot;,v);
}
</code></pre></pre>
<p>当然，使用<code>lazy_static</code>在每次访问静态变量时，会有轻微的性能损失，因为其内部实现用了一个底层的并发原语<code>std::sync::Once</code>，在每次访问该变量时，程序都会执行一次原子指令用于确认静态变量的初始化是否完成。</p>
<p><code>lazy_static</code>宏，匹配的是<code>static ref</code>，所以定义的静态变量都是不可变引用</p>
<p>可能有读者会问，为何需要在运行期初始化一个静态变量，除了上面的全局锁，你会遇到最常见的场景就是：<strong>一个全局的动态配置，它在程序开始后，才加载数据进行初始化，最终可以让各个线程直接访问使用</strong></p>
<p>再来看一个使用<code>lazy_static</code>实现全局缓存的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use lazy_static::lazy_static;
use std::collections::HashMap;

lazy_static! {
    static ref HASHMAP: HashMap&lt;u32, &amp;'static str&gt; = {
        let mut m = HashMap::new();
        m.insert(0, &quot;foo&quot;);
        m.insert(1, &quot;bar&quot;);
        m.insert(2, &quot;baz&quot;);
        m
    };
}

fn main() {
    // 首次访问`HASHMAP`的同时对其进行初始化
    println!(&quot;The entry for `0` is \&quot;{}\&quot;.&quot;, HASHMAP.get(&amp;0).unwrap());

    // 后续的访问仅仅获取值，再不会进行任何初始化操作
    println!(&quot;The entry for `1` is \&quot;{}\&quot;.&quot;, HASHMAP.get(&amp;1).unwrap());
}
</code></pre></pre>
<p>需要注意的是，<code>lazy_static</code>直到运行到<code>main</code>中的第一行代码时，才进行初始化，非常<code>lazy static</code>。</p>
<h4 id="boxleak-1"><a class="header" href="#boxleak-1">Box::leak</a></h4>
<p>在<code>Box</code>智能指针章节中，我们提到了<code>Box::leak</code>可以用于全局变量，例如用作运行期初始化的全局动态配置，先来看看如果不使用<code>lazy_static</code>也不使用<code>Box::leak</code>，会发生什么：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}
static mut config: Option&lt;&amp;mut Config&gt; = None;

fn main() {
    unsafe {
        config = Some(&amp;mut Config {
            a: &quot;A&quot;.to_string(),
            b: &quot;B&quot;.to_string(),
        });

        println!(&quot;{:?}&quot;,config)
    }   
}
</code></pre></pre>
<p>以上代码我们声明了一个全局动态配置<code>config</code>，并且其值初始化为<code>None</code>，然后在程序开始运行后，给它赋予相应的值，运行后报错:</p>
<pre><code class="language-console">error[E0716]: temporary value dropped while borrowed
  --&gt; src/main.rs:10:28
   |
10 |            config = Some(&amp;mut Config {
   |   _________-__________________^
   |  |_________|
   | ||
11 | ||             a: &quot;A&quot;.to_string(),
12 | ||             b: &quot;B&quot;.to_string(),
13 | ||         });
   | ||         ^-- temporary value is freed at the end of this statement
   | ||_________||
   |  |_________|assignment requires that borrow lasts for `'static`
   |            creates a temporary which is freed while still in use
</code></pre>
<p>可以看到，Rust的借用和生命周期规则限制了我们做到这一点，因为试图将一个局部生命周期的变量赋值给全局生命周期的<code>config</code>，这明显是不安全的。</p>
<p>好在<code>Rust</code>为我们提供了<code>Box::leak</code>方法，它可以将一个变量从内存中泄漏(听上去怪怪的，竟然做主动内存泄漏)，然后将其变为<code>'static</code>生命周期，最终该变量将和程序活得一样久，因此可以赋值给全局静态变量<code>config</code>。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::Mutex;

#[derive(Debug)]
struct Config {
    a: String,
    b: String
}
static mut config: Option&lt;&amp;mut Config&gt; = None;

fn main() {
    let c = Box::new(Config {
        a: &quot;A&quot;.to_string(),
        b: &quot;B&quot;.to_string(),
    });

    unsafe {
        // 将`c`从内存中泄漏，变成`'static`生命周期
        config = Some(Box::leak(c));
        println!(&quot;{:?}&quot;, config);
    }
}
</code></pre></pre>
<h4 id="从函数中返回全局变量"><a class="header" href="#从函数中返回全局变量">从函数中返回全局变量</a></h4>
<p>问题又来了，如果我们需要在运行期，从一个函数返回一个全局变量该如何做？例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}
static mut config: Option&lt;&amp;mut Config&gt; = None;

fn init() -&gt; Option&lt;&amp;'static mut Config&gt; {
    Some(&amp;mut Config {
        a: &quot;A&quot;.to_string(),
        b: &quot;B&quot;.to_string(),
    })
}


fn main() {
    unsafe {
        config = init();

        println!(&quot;{:?}&quot;,config)
    }   
}
</code></pre></pre>
<p>报错这里就不展示了，跟之前大同小异，还是生命周期引起的，那么该如何解决呢？依然可以用<code>Box::leak</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}
static mut config: Option&lt;&amp;mut Config&gt; = None;

fn init() -&gt; Option&lt;&amp;'static mut Config&gt; {
    let c = Box::new(Config {
        a: &quot;A&quot;.to_string(),
        b: &quot;B&quot;.to_string(),
    });

    Some(Box::leak(c))
}


fn main() {
    unsafe {
        config = init();

        println!(&quot;{:?}&quot;,config)
    }   
}
</code></pre></pre>
<h2 id="标准库中的oncecell"><a class="header" href="#标准库中的oncecell">标准库中的OnceCell</a></h2>
<p>@todo</p>
<h2 id="总结-17"><a class="header" href="#总结-17">总结</a></h2>
<p>在Rust中有很多方式可以创建一个全局变量，本章也只是介绍了其中一部分，更多的还等待大家自己去挖掘学习(当然，未来可能本章节会不断完善，最后变成一个巨无霸- , -)。</p>
<p>简单来说，全局变量可以分为两种：</p>
<ul>
<li>编译期初始化的全局变量，<code>const</code>创建常量，<code>static</code>创建静态变量，<code>Atomic</code>创建原子类型</li>
<li>运行期初始化的全局变量，<code>lazy_static</code>用于懒初始化，<code>Box::leak</code>利用内存泄漏将一个变量的生命周期变为<code>'static</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简化错误处理"><a class="header" href="#简化错误处理">简化错误处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义错误"><a class="header" href="#自定义错误">自定义错误</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="让错误展示更优雅"><a class="header" href="#让错误展示更优雅">让错误展示更优雅</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="会导致panic的代码"><a class="header" href="#会导致panic的代码">会导致panic的代码</a></h1>
<p>String slice range indices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error. For the purposes of introducing string slices, we are assuming ASCII only in this section; a more thorough discussion of UTF-8 handling is in the “Storing UTF-8 Encoded Text with Strings” section of Chapter 8.</p>
<blockquote>
<p>比方说有一个 <code>u8</code> ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生<strong>整型溢出</strong>。关于这一行为 Rust 有一些有趣的规则。当在 debug 模式编译时，Rust 会检查整型溢出若存在这些问题则使程序在编译时 <em>panic</em>。Rust 使用这个术语来表明程序因错误而退出。 <a href="advance/errors/../../errors/panic.html">该章节</a>会详细介绍 panic。</p>
<p>在当使用 <code>--release</code> 参数进行 release 模式构建时，Rust <strong>不</strong>检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（<em>two’s complement wrapping</em>）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 <code>u8</code> 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 panic，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高阶特征约束hrtb-todo"><a class="header" href="#高阶特征约束hrtb-todo">高阶特征约束(HRTB) todo</a></h1>
<p>https://www.reddit.com/r/rust/comments/s6g16d/help_with_hrtb_lifetimes/</p>
<h2 id="fora"><a class="header" href="#fora">for&lt;'a&gt;</a></h2>
<p>https://www.reddit.com/r/rust/comments/rq43c6/generic_fn_impl_for_iterating_over_mut_items_twice/</p>
<p>https://www.reddit.com/r/rust/comments/6uobit/fora_lifetime_syntax/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异步编程"><a class="header" href="#异步编程">异步编程</a></h1>
<p>在艰难的学完Rust入门和进阶所有的55个章节后，我们终于来到了这里。假如之前攀登的是珠穆拉玛峰，那么现在攀登的就是乔戈里峰，本章将学习的内容是关于async异步编程。</p>
<p>如果你想开发Web服务器、数据库驱动、消息服务等需要高并发的服务，那么本章的内容将值得认真对待和学习，将从以下方面深入讲解Rust的异步编程：</p>
<ul>
<li>Rust异步编程的通用概念介绍</li>
<li>Future以及异步任务调度</li>
<li>async/await和Pin/Unpin</li>
<li>异步编程常用的三方库</li>
<li>tokio库</li>
<li>一些示例</li>
</ul>
<blockquote>
<p>本章在内容上大量借鉴和翻译了原版英文书籍<a href="https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html">Asynchronous Programming In Rust</a>, 特此感谢</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-编程简介"><a class="header" href="#async-编程简介">Async 编程简介</a></h1>
<p>众所周知，Rust 可以让我们写出性能高且安全的软件，那么异步编程这块儿呢？是否依然在高性能的同时保证了安全？</p>
<p>我们先通过一张web框架性能对比图来感受下 Rust 异步编程的性能:</p>
<img alt="actix-vs-gin screenshot" width="100%" src="async//img/async-01.png" class="center"  />
<p>上图并不能说 Rust 写的 <code>actix</code> 框架比 Go 的 <code>gin</code> 更好、更优秀，但是确实可以一定程度上说明 Rust 的异步性能非常的高！</p>
<p>简单来说，异步编程是一个<a href="https://www.zhihu.com/question/33515481/answer/2304727467">并发编程模型</a>，目前主流语言基本都支持了，当然，支持的方式有所不同。异步编程允许我们同时并发运行大量的任务，却仅仅需要几个甚至一个OS线程或CPU核心，现代化的异步编程在使用体验上跟同步编程也几无区别，例如 Go 语言的 <code>go</code> 关键字，也包括我们后面将介绍的 <code>async/await</code> 语法，该语法是 <code>Javascript</code> 和 <code>Rust</code> 的核心特性之一。</p>
<h2 id="async简介"><a class="header" href="#async简介">async简介</a></h2>
<p><code>async</code> 是 Rust 选择的异步编程模型，下面我们来介绍下它的优缺点，以及何时适合使用。</p>
<h4 id="async-vs-其它并发模型"><a class="header" href="#async-vs-其它并发模型">async vs 其它并发模型</a></h4>
<p>由于并发编程在现代社会非常重要，因此每个主流语言都对自己的并发模型进行过权衡取舍和精心设计，Rust 语言也不例外。下面的列表可以帮助大家理解不同并发模型的取舍:</p>
<ul>
<li><strong>OS线程</strong>, 它最简单，也无需改变任何编程模型(业务/代码逻辑)，因此非常适合作为语言的原生并发模型，我们在<a href="async/../advnce/../advance/concurrency-with-threads/concurrency-parallelism.html">多线程章节</a>也提到过，Rust 就选择了原生支持线程级的并发编程。但是，这种模型也有缺点，例如线程间的同步将变得更加困难，线程间的上下文切换损耗较大。使用线程池在一定程度上可以提升性能，但是对于 IO 密集的场景来说，线程池还是不够看。</li>
<li><strong>事件驱动(Event driven)</strong>, 这个名词你可能比较陌生，如果说事件驱动常常跟回调( Callback )一起使用，相信大家就恍然大悟了。这种模型性能相当的好，但最大的问题就是存在回调地狱的风险：非线性的控制流和结果处理导致了数据流向和错误传播变得难以掌控，还会导致代码维护性和可读性的大幅降低，大名鼎鼎的 JS 曾经就存在回调地狱。</li>
<li><strong>协程(Coroutines)</strong> 可能是目前最火的并发模型，<code>Go</code> 语言的协程设计就非常优秀，这也是 <code>Go</code> 语言能够迅速火遍全球的杀手锏之一。协程跟线程类似，无需改变编程模型，同时，它也跟 <code>async</code> 类似，可以支持大量的任务并发运行。但协程抽象层次过高，导致用户无法接触到底层的细节，这对于系统编程语言和自定义异步运行时是难以接受的</li>
<li><strong>actor模型</strong>是erlang的杀手锏之一，它将所有并发计算分割成一个一个单元，这些单元被称为 <code>actor</code> , 单元之间通过消息传递的方式进行通信和数据传递，跟分布式系统的设计理念非常相像。由于 <code>actor</code> 模型跟现实很贴近，因此它相对来说更容易实现，但是一旦遇到流控制、失败重试等场景时，就会变得不太好用</li>
<li><strong>async/await</strong>， 该模型性能高，还能支持底层编程，同时又像线程和协程那样无需过多的改变编程模型，但有得必有失，<code>async</code> 模型的问题就是内部实现机制过于复杂，对于用户来说，理解和使用起来也没有线程和协程简单，好在前者的复杂性开发者们已经帮我们封装好，而理解和使用起来不够简单，正是本章试图解决的问题。</li>
</ul>
<p>总之，Rust 经过权衡取舍后，最终选择了同时提供多线程编程和 async 编程:</p>
<ul>
<li>前者通过标准库实现，当你无需那么高的并发时，例如需要并行计算时，可以选择它，优点是线程内的代码执行效率更高、实现更直观更简单，这块内容已经在多线程章节进行过深入讲解，不再赘述</li>
<li>后者通过语言特性 + 标准库 + 三方库的方式实现，在你需要高并发、异步 <code>I/O</code> 时，选择它就对了</li>
</ul>
<h4 id="async-rust-vs-其它语言"><a class="header" href="#async-rust-vs-其它语言">async: Rust vs 其它语言</a></h4>
<p>目前已经有诸多语言都通过 <code>async</code> 的方式提供了异步编程，例如 <code>Javascript</code> ，但 <code>Rust</code> 在实现上有所区别:</p>
<ul>
<li><strong>Future 在 Rust 中是惰性的</strong>，只有在被轮询(<code>poll</code>)时才会运行， 因此丢弃一个 <code>future</code> 会阻止它未来再被运行, 你可以将<code>Future</code>理解为一个在未来某个时间点被调度执行的任务。</li>
<li><strong>Async 在 Rust 中使用开销是零</strong>， 意味着只有你能看到的代码(自己的代码)才有性能损耗，你看不到的(<code>async</code> 内部实现)都没有性能损耗，例如，你可以无需分配任何堆内存、也无需任何动态分发来使用 <code>async</code> ，这对于热点路径的性能有非常大的好处，正是得益于此，Rust 的异步编程性能才会这么高。</li>
<li><strong>Rust 没有内置异步调用所必须的运行时</strong>，但是无需担心，Rust社区生态中已经提供了非常优异的运行时实现，例如大明星 <a href="https://tokio.rs"><code>tokio</code></a></li>
<li><strong>运行时同时支持单线程和多线程</strong>，这两者拥有各自的优缺点, 稍后会讲</li>
</ul>
<h4 id="rust-async-vs-多线程"><a class="header" href="#rust-async-vs-多线程">Rust: async vs 多线程</a></h4>
<p>虽然 <code>async</code> 和多线程都可以实现并发编程，后者甚至还能通过线程池来增强并发能力，但是这两个方式并不互通，从一个方式切换成另一个需要大量的代码重构工作，因此提前为自己的项目选择适合的并发模型就变得至关重要。</p>
<p><code>OS</code> 线程非常适合少量任务并发，因为线程的创建和上下文切换是非常昂贵的，甚至于空闲的线程都会消耗系统资源。虽说线程池可以有效的降低性能损耗，但是也无法彻底解决问题。当然，线程模型也有其优点，例如它不会破坏你的代码逻辑和编程模型，你之前的顺序代码，经过少量修改适配后依然可以在新线程中直接运行，同时在某些操作系统中，你还可以改变线程的优先级，这对于实现驱动程序或延迟敏感的应用(例如硬实时系统)很有帮助。</p>
<p>对于长时间运行的CPU密集型任务，例如密集计算，使用线程将更有优势。 这种密集任务往往会让所在的线程持续运行，任何不必要的线程切换都会带来性能损耗，因此高并发反而在此时成为了一种多余。同时你所创建的线程数应该等于CPU核心数，充分利用CPU的并行能力，甚至还可以将线程绑定到CPU核心上，进一步减少线程上下文切换。</p>
<p>而高并发更适合 <code>IO</code> 密集型任务，例如 web 服务器、数据库连接等等网络服务，因为这些任务绝大部分时间都处于等待状态，如果使用多线程，那线程大量时间会处于无所事事的状态，再加上线程上下文切换的高昂代价，让多线程做 <code>IO</code> 密集任务变成了一件非常奢侈的事。而使用<code>async</code>，既可以有效的降低 <code>CPU</code> 和内存的负担，又可以让大量的任务并发的运行，一个任务一旦处于<code>IO</code>或者其他等待(阻塞)状态，就会被立刻切走并执行另一个任务，而这里的任务切换的性能开销要远远低于使用多线程时的线程上下文切换。</p>
<p>事实上, <code>async</code> 底层也是基于线程实现，但是它基于线程封装了一个运行时，可以将多个任务映射到少量线程上，然后将线程切换变成了任务切换，后者仅仅是内存中的访问，因此要高效的多。</p>
<p>不过<code>async</code>也有其缺点，原因是编译器会为<code>async</code>函数生成状态机，然后将整个运行时打包进来，这会造成我们编译出的二进制可执行文件体积显著增大。</p>
<p>总之，<code>async</code>编程并没有比多线程更好，最终还是根据你的使用场景作出合适的选择，如果无需高并发，或者也不在意线程切换带来的性能损耗，那么多线程使用起来会简单、方便的多！最后再简单总结下：</p>
<ul>
<li>有大量 <code>IO</code> 任务需要并发运行时，选 <code>async</code> 模型</li>
<li>有部分 <code>IO</code> 任务需要并发运行时，选多线程，如果想要降低线程切换的开销，可以使用线程池</li>
<li>有大量 <code>CPU</code> 密集任务需要并行运行时，例如并行计算，选多线程模型，且让多线程数等于或者稍大于 <code>CPU</code> 核心数</li>
<li>无所谓时，统一选多线程</li>
</ul>
<h4 id="一个例子"><a class="header" href="#一个例子">一个例子</a></h4>
<p>在大概理解<code>async</code>后，我们再来看一个简单的例子。如果想并发的下载文件，你可以使用多线程如下实现:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_two_sites() {
    // 创建两个新线程执行任务
    let thread_one = thread::spawn(|| download(&quot;https://course.rs&quot;));
    let thread_two = thread::spawn(|| download(&quot;https://fancy.rs&quot;));

    // 等待两个线程的完成
    thread_one.join().expect(&quot;thread one panicked&quot;);
    thread_two.join().expect(&quot;thread two panicked&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>如果是在一个小项目中简单的去下载文件，这么写没有任何问题，但是一旦下载文件的并发请求多起来，那一个下载任务占用一个线程的模式就太重了，会很容易成为程序的瓶颈。好在，我们可以使用<code>async</code>的方式来解决：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn get_two_sites_async() {
    // 创建两个不同的`future`，你可以把`future`理解为未来某个时刻会被执行的计划任务
    // 当两个`future`被同时执行后，它们将并发的去下载目标页面
    let future_one = download_async(&quot;https://www.foo.com&quot;);
    let future_two = download_async(&quot;https://www.bar.com&quot;);

    // 同时运行两个`future`，直至完成
    join!(future_one, future_two);
}
<span class="boring">}
</span></code></pre></pre>
<p>此时，不再有线程创建和切换的昂贵开销，所有的函数都是通过静态的方式进行分发，同时也没有任何内存分配发生。这段代码的性能简直无懈可击！</p>
<p>事实上，<code>async</code> 和多线程并不是二选一，在同一应用中，可以根据情况两者一起使用，当然，我们还可以使用其它的并发模型，例如上面提到事件驱动模型，前提是有三方库提供了相应的实现。</p>
<h2 id="async-rust当前的进展"><a class="header" href="#async-rust当前的进展">Async Rust当前的进展</a></h2>
<p>简而言之，Rust 语言的 <code>async</code> 目前还没有达到多线程的成熟度，其中一部分内容还在不断进化中，当然，这并不影响我们在生产级项目中使用，因为社区中还有 <code>tokio</code> 这种大杀器。</p>
<p>使用 <code>async</code> 时，你会遇到好的，也会遇到不好的，例如：</p>
<ul>
<li>收获卓越的性能</li>
<li>会经常跟进阶语言特性打交道，例如生命周期等，这些家伙可不好对付</li>
<li>一些兼容性问题，例如同步和异步代码、不同的异步运行时( <code>tokio</code> 与 <code>async-std</code> )</li>
<li>更昂贵的维护成本，原因是 <code>async</code> 和社区开发的运行时依然在不停的进化</li>
</ul>
<p>总之，<code>async</code> 在 Rust 中并不是一个善茬，你会遇到更多的困难或者说坑，也会带来更高的代码阅读成本及维护成本，但是为了性能，一切都值了，不是吗？</p>
<p>不过好在，这些进化早晚会彻底稳定成熟，而且在实际项目中，我们往往会使用成熟的三方库，例如<code>tokio</code>，因此可以避免一些类似的问题，但是对于本章的学习来说，<code>async</code> 的一些难点还是我们必须要去面对和征服的。</p>
<h4 id="语言和库的支持"><a class="header" href="#语言和库的支持">语言和库的支持</a></h4>
<p><code>async</code> 的底层实现非常复杂，且会导致编译后文件体积显著增加，因此 Rust 没有选择像 Go 语言那样内置了完整的特性和运行时，而是选择了通过 Rust 语言提供了必要的特性支持，再通过社区来提供 <code>async</code> 运行时的支持。 因此要完整的使用 <code>async</code> 异步编程，你需要依赖以下特性和外部库:</p>
<ul>
<li>所必须的特征(例如 <code>Future</code> )、类型和函数，由标准库提供实现</li>
<li>关键字 <code>async/await</code> 由Rust语言提供，并进行了编译器层面的支持</li>
<li>众多实用的类型、宏和函数由官方开发的 <a href="https://github.com/rust-lang/futures-rs"><code>futures</code></a> 包提供(不是标准库)，它们可以用于任何 <code>async</code> 应用中。</li>
<li><code>async</code> 代码的执行、<code>IO</code> 操作、任务创建和调度等等复杂功能由社区的 <code>async</code> 运行时提供，例如 <a href="https://github.com/tokio-rs/tokio"><code>tokio</code></a> 和 <a href="https://github.com/async-rs/async-std"><code>async-std</code></a></li>
</ul>
<p>还有，你在同步( <code>synchronous</code> )代码中使用的一些语言特性在 <code>async</code> 中可能将无法再使用，而且 Rust 也不允许你在特征中声明 <code>async</code> 函数(可以通过三方库实现)， 总之，你会遇到一些在同步代码中不会遇到的奇奇怪怪、形形色色的问题，不过不用担心，本章会专门用一个章节罗列这些问题，并给出相应的解决方案。</p>
<h4 id="编译和错误"><a class="header" href="#编译和错误">编译和错误</a></h4>
<p>在大多数情况下，<code>async</code> 中的编译错误和运行时错误和之前没啥区别，但是依然有以下几点值得注意。</p>
<ul>
<li>编译错误，由于 <code>async</code> 编程时需要经常使用复杂的语言特性，例如生命周期和<code>Pin</code>，因此相关的错误可能会出现的更加频繁</li>
<li>运行时错误，编译器会为每一个<code>async</code>函数生成状态机，这会导致在栈跟踪时会包含这些状态机的细节，同时还包含了运行时对函数的调用，因此，栈跟踪记录(例如 <code>panic</code> 时)将变得更加难以解读</li>
<li>一些隐蔽的错误也可能发生，例如在一个 <code>async</code> 上下文中去调用一个阻塞的函数，或者没有正确的实现 <code>Future</code> 特征都有可能导致这种错误。这种错误可能会悄无声息的通过编译检查甚至有时候会通过单元测试。好在一旦你深入学习并掌握了本章的内容和 <code>async</code> 原理，可以有效的降低遇到这些错误的概率</li>
</ul>
<h4 id="兼容性考虑"><a class="header" href="#兼容性考虑">兼容性考虑</a></h4>
<p>异步代码和同步代码并不总能和睦共处。例如，我们无法在一个同步函数中去调用一个 <code>async</code> 异步函数，同步和异步代码也往往使用不同的设计模式，这些都会导致两者融合上的困难。</p>
<p>甚至于有时候，异步代码之间也存在类似的问题，如果一个库依赖于特定的 <code>async</code> 运行时来运行，那么这个库非常有必要告诉它的用户，它用了这个运行时。否则一旦用户选了不同的或不兼容的运行时，就会导致不可预知的麻烦。</p>
<h4 id="性能特性"><a class="header" href="#性能特性">性能特性</a></h4>
<p><code>async</code> 代码的性能主要取决于你使用的 <code>async</code> 运行时，好在这些运行时都经过了精心的设计，在你能遇到的绝大多数场景中，它们都能拥有非常棒的性能表现。</p>
<p>但是世事皆有例外。目前主流的 <code>async</code> 运行时几乎都使用了多线程实现，相比单线程虽然增加了并发表现，但是对于执行性能会有所损失，因为多线程实现会有同步和切换上的性能开销，若你需要极致的顺序执行性能，那么 <code>async</code> 目前并不是一个好的选择。</p>
<p>同样的，对于延迟敏感的任务来说，任务的执行次序需要能被严格掌控，而不是交由运行时去自动调度，后者会导致不可预知的延迟，例如一个web服务器总是有 <code>1%</code> 的请求，它们的延迟会远高于其它请求，因为调度过于繁忙导致了部分任务被延迟调度，最终导致了较高的延时。正因为此，这些延迟敏感的任务非常依赖于运行时或操作系统提供调度次序上的支持。</p>
<p>以上的两个需求，目前的 <code>async</code> 运行时并不能很好的支持，在未来可能会有更好的支持，但在此之前，我们可以尝试用多线程解决。</p>
<h2 id="asyncawait-简单入门"><a class="header" href="#asyncawait-简单入门">async/.await 简单入门</a></h2>
<p><code>async/.await</code> 是 Rust 内置的语言特性，可以让我们用同步的方式去编写异步的代码。</p>
<p>通过 <code>async</code> 标记的语法块会被转换成实现了<code>Future</code>特征的状态机。 与同步调用阻塞当前线程不同，当<code>Future</code>执行并遇到阻塞时，它会让出当前线程的控制权，这样其它的<code>Future</code>就可以在该线程中运行，这种方式完全不会导致当前线程的阻塞。</p>
<p>下面我们来通过例子学习 <code>async/.await</code> 关键字该如何使用，在开始之前，需要先引入 <code>futures</code> 包。编辑 <code>Cargo.toml</code> 文件并添加以下内容:</p>
<pre><code class="language-toml">[dependencies]
futures = &quot;0.3&quot;
</code></pre>
<h4 id="使用-async"><a class="header" href="#使用-async">使用 async</a></h4>
<p>首先，使用 <code>async fn</code> 语法来创建一个异步函数:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn do_something() { 
    println!(&quot;go go go !&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>需要注意，<strong>异步函数的返回值是一个 <code>Future</code></strong>，若直接调用该函数，不会输出任何结果，因为 <code>Future</code> 还未被执行：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
      do_something();
}
</code></pre></pre>
<p>运行后，<code>go go go</code>并没有打印，同时编译器给予一个提示：<code>warning: unused implementer of Future that must be used</code>，告诉我们 <code>Future</code> 未被使用，那么到底该如何使用？答案是使用一个执行器( <code>executor</code> ):</p>
<pre><pre class="playground"><code class="language-rust edition2021">// `block_on`会阻塞当前线程直到指定的`Future`执行完成，这种阻塞当前线程以等待任务完成的方式较为简单、粗暴，
// 好在其它运行时的执行器(executor)会提供更加复杂的行为，例如将多个`future`调度到同一个线程上执行。
use futures::executor::block_on;

async fn hello_world() {
    println!(&quot;hello, world!&quot;);
}

fn main() {
    let future = hello_world(); // 返回一个Future, 因此不会打印任何输出
    block_on(future); // 执行`Future`并等待其运行完成，此时&quot;hello, world!&quot;会被打印输出
}
</code></pre></pre>
<h4 id="使用await"><a class="header" href="#使用await">使用.await</a></h4>
<p>在上述代码的<code>main</code>函数中，我们使用<code>block_on</code>这个执行器等待<code>Future</code>的完成，让代码看上去非常像是一个同步代码，但是如果你要在一个<code>async fn</code>函数中去使用另一个<code>async fn</code>并等待其完成后再进行后续的代码，该如何做？例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use futures::executor::block_on;

async fn hello_world() {
    hello_cat();
    println!(&quot;hello, world!&quot;);
}

async fn hello_cat() {
    println!(&quot;hello, kitty!&quot;);
}
fn main() {
    let future = hello_world();
    block_on(future); 
}
</code></pre></pre>
<p>这里，我们在<code>hello_world</code>异步函数中先调用了另一个异步函数<code>hello_cat</code>，然后再输出<code>hello, world!</code>，看看运行结果：</p>
<pre><code class="language-console">warning: unused implementer of `futures::Future` that must be used
 --&gt; src/main.rs:6:5
  |
6 |     hello_cat();
  |     ^^^^^^^^^^^^
= note: futures do nothing unless you `.await` or poll them  
...
hello, world!
</code></pre>
<p>不出所料，<code>main</code>函数中的<code>future</code>我们通过<code>block_on</code>函数进行了运行，但是这里的<code>hello_cat</code>返回的<code>Future</code>却没有任何人去执行它，不过好在编译器友善的给出了提示：<code>futures do nothing unless you .await or poll them </code>，两种解决方法：使用<code>.await</code>语法或者对<code>Future</code>进行轮询(<code>poll</code>)。</p>
<p>后者较为复杂，暂且不表，先来使用<code>.await</code>试试:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use futures::executor::block_on;

async fn hello_world() {
    hello_cat().await;
    println!(&quot;hello, world!&quot;);
}

async fn hello_cat() {
    println!(&quot;hello, kitty!&quot;);
}
fn main() {
    let future = hello_world();
    block_on(future); 
}
</code></pre></pre>
<p>为<code>hello_cat()</code>添加上<code>.await</code>后，结果立刻大为不同:</p>
<pre><code class="language-console">hello, kitty!
hello, world!
</code></pre>
<p>输出执行的顺序跟代码定义的顺序完全符合，因此，我们在上面代码中<strong>使用同步的代码顺序实现了异步的执行效果</strong>，非常简单、高效，而且很好理解，未来也绝对不会有回调地狱的发生。</p>
<p>总之，在<code>async fn</code>函数中使用<code>.await</code>可以等待另一个异步调用的完成。<strong>但是与<code>block_on</code>不同，<code>.await</code>并不会阻塞当前的线程</strong>，而是异步的等待<code>Future A</code>的完成，在等待的过程中，该线程还可以继续执行其它的<code>Future B</code>，最终实现了并发处理的效果。</p>
<h4 id="一个例子-1"><a class="header" href="#一个例子-1">一个例子</a></h4>
<p>考虑一个载歌载舞的例子，如果不用<code>.await</code>，我们可能会有如下实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021">async fn learn_song() -&gt; Song { /* ... */ }
async fn sing_song(song: Song) { /* ... */ }
async fn dance() { /* ... */ }

fn main() {
    let song = block_on(learn_song());
    block_on(sing_song(song));
    block_on(dance());
}
</code></pre></pre>
<p>当然，以上代码运行结果无疑是正确的，但。。。它的性能何在？需要通过连续三次阻塞去等待三个任务的完成，一次只能做一件事，实际上我们完全可以载歌载舞啊:</p>
<pre><pre class="playground"><code class="language-rust edition2021">async fn sing_song(song: Song) { /* ... */ }
async fn learn_and_sing() {
    // 这里使用`.await`来等待学歌的完成，但是并不会阻塞当前线程，该线程在学歌的任务`.await`后，完全可以去执行跳舞的任务
    let song = learn_song().await;
    
    // 唱歌必须要在学歌之后
    sing_song(song).await;
}

async fn async_main() {
    let f1 = learn_and_sing();
    let f2 = dance();

    // `join!`可以并发的处理和等待多个`Future`，若`learn_and_sing Future`被阻塞，那`dance Future`可以拿过线程的所有权继续执行。若`dance`也变成阻塞状态，那`learn_and_sing`又可以再次拿回线程所有权，继续执行。
    // 若两个都被阻塞，那么`async main`会变成阻塞状态，然后让出线程所有权，并将其交给`main`函数中的`block_on`执行器
    futures::join!(f1, f2);
}

fn main() {
    block_on(async_main());
}
</code></pre></pre>
<p>上面代码中，学歌和唱歌具有明显的先后顺序，但是这两者都可以跟跳舞一同存在，也就是你可以在跳舞的时候学歌，也可以在跳舞的时候唱歌。如果上面代码不使用<code>.await</code>，而是使用<code>block_on(learn_song())</code>， 那在学歌时，当前线程就会阻塞，不再可以做其它任何事，包括跳舞。</p>
<p>因此<code>.await</code>对于实现异步编程至关重要，它允许我们在同一个线程内并发的运行多个任务，而不是一个一个先后完成。若大家看到这里还是不太明白，强烈建议回头再仔细看一遍，同时亲自上手修改代码试试效果。</p>
<p>至此，读者应该对Rust的<code>async/.await</code>异步编程有了一个清晰的初步印象，下面让我们一起来看看这背后的原理：<code>Future</code>和任务在底层如何被执行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="底层探秘-future执行器与任务调度"><a class="header" href="#底层探秘-future执行器与任务调度">底层探秘: Future执行器与任务调度</a></h1>
<p>异步编程背后到底藏有什么秘密？究竟是哪只幕后之手在操纵这一切？如果你对这些感兴趣，就继续看下去，否则可以直接跳过，因为本章节的内容对于一个API工程师并没有太多帮助。</p>
<p>但是如果你希望能深入理解 <code>Rust</code> 的 <code>async/.await</code> 代码是如何工作、理解运行时和性能，甚至未来想要构建自己的 <code>async</code> 运行时或相关工具，那么本章节终究不会辜负于你。</p>
<h2 id="future-特征"><a class="header" href="#future-特征">Future 特征</a></h2>
<p><code>Future</code> 特征是 Rust 异步编程的核心，毕竟异步函数是异步编程的核心，而 <code>Future</code> 恰恰是异步函数的返回值和被执行的关键。</p>
<p>首先，来给出 <code>Future</code> 的定义：它是一个能产出值的异步计算(虽然该值可能为空，例如 <code>()</code> )。光看这个定义，可能会觉得很空洞，我们来看看一个简化版的 <code>Future</code> 特征:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait SimpleFuture {
    type Output;
    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt;;
}

enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}
</span></code></pre></pre>
<p>在上一章中，我们提到过 <code>Future</code> 需要被执行器<code>poll</code>(轮询)后才能运行，诺，这里 <code>poll</code> 就来了，通过调用该方法，可以推进 <code>Future</code> 的进一步执行，直到被切走为止( 这里不好理解，但是你只需要知道 <code>Future</code> 并不能保证被在一次 <code>poll</code> 中就被执行完，后面会详解介绍)。</p>
<p>若在当前 <code>poll</code> 中， <code>Future</code> 可以被完成，则会返回 <code>Poll::Ready(result)</code> ，反之则返回 <code>Poll::Pending</code>， 并且安排一个 <code>wake</code> 函数：当未来 <code>Future</code> 准备好进一步执行时， 该函数会被调用，然后管理该 <code>Future</code> 的执行器(例如上一章节中的<code>block_on</code>函数)会再次调用 <code>poll</code> 方法，此时 <code>Future</code> 就可以继续执行了。</p>
<p>如果没有 <code>wake </code>方法，那执行器无法知道某个<code>Future</code>是否可以继续被执行，除非执行器定期的轮询每一个 <code>Future</code> ，确认它是否能被执行，但这种作法效率较低。而有了 <code>wake</code>，<code>Future</code> 就可以主动通知执行器，然后执行器就可以精确的执行该 <code>Future</code>。 这种“事件通知 -&gt; 执行”的方式要远比定期对所有 <code>Future</code> 进行一次全遍历来的高效。</p>
<p>也许大家还是迷迷糊糊的，没事，我们用一个例子来说明下。考虑一个需要从 <code>socket</code> 读取数据的场景：如果有数据，可以直接读取数据并返回 <code>Poll::Ready(data)</code>， 但如果没有数据，<code>Future</code> 会被阻塞且不会再继续执行，此时它会注册一个 <code>wake</code> 函数，当 <code>socket</code> 数据准备好时，该函数将被调用以通知执行器：我们的 <code>Future</code> 已经准备好了，可以继续执行。</p>
<p>下面的 <code>SocketRead</code> 结构体就是一个 <code>Future</code>: </p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SocketRead&lt;'a&gt; {
    socket: &amp;'a Socket,
}

impl SimpleFuture for SocketRead&lt;'_&gt; {
    type Output = Vec&lt;u8&gt;;

    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        if self.socket.has_data_to_read() {
            // socket有数据，写入buffer中并返回
            Poll::Ready(self.socket.read_buf())
        } else {
            // socket中还没数据
            // 
            // 注册一个`wake`函数，当数据可用时，该函数会被调用，
            // 然后当前Future的执行器会再次调用`poll`方法，此时就可以读取到数据
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这种 <code>Future</code> 模型允许将多个异步操作组合在一起，同时还无需任何内存分配。不仅仅如此，如果你需要同时运行多个 <code>Future</code>或链式调用多个 <code>Future</code> ，也可以通过无内存分配的状态机实现，例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait SimpleFuture {
    type Output;
    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt;;
}

enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}

/// 一个SimpleFuture，它会并发地运行两个Future直到它们完成
///
/// 之所以可以并发，是因为两个Future的轮询可以交替进行，一个阻塞，另一个就可以立刻执行，反之亦然
pub struct Join&lt;FutureA, FutureB&gt; {
    // 结构体的每个字段都包含一个Future，可以运行直到完成.
    // 如果Future完成后，字段会被设置为 `None`. 这样Future完成后，就不会再被轮询
    a: Option&lt;FutureA&gt;,
    b: Option&lt;FutureB&gt;,
}

impl&lt;FutureA, FutureB&gt; SimpleFuture for Join&lt;FutureA, FutureB&gt;
where
    FutureA: SimpleFuture&lt;Output = ()&gt;,
    FutureB: SimpleFuture&lt;Output = ()&gt;,
{
    type Output = ();
    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        // 尝试去完成一个 Future `a`
        if let Some(a) = &amp;mut self.a {
            if let Poll::Ready(()) = a.poll(wake) {
                self.a.take();
            }
        }

        // 尝试去完成一个 Future `b`
        if let Some(b) = &amp;mut self.b {
            if let Poll::Ready(()) = b.poll(wake) {
                self.b.take();
            }
        }

        if self.a.is_none() &amp;&amp; self.b.is_none() {
            // 两个 Future都已完成 - 我们可以成功地返回了
            Poll::Ready(())
        } else {
            // 至少还有一个 Future 没有完成任务，因此返回 `Poll::Pending`.
            // 当该 Future 再次准备好时，通过调用`wake()`函数来继续执行
            Poll::Pending
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面代码展示了如何同时运行多个 <code>Future</code>， 且在此过程中没有任何内存分配，让并发编程更加高效。 类似的，多个<code>Future</code>也可以一个接一个的连续运行：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 一个SimpleFuture, 它使用顺序的方式，一个接一个地运行两个Future
//
// 注意: 由于本例子用于演示，因此功能简单，`AndThenFut` 会假设两个 Future 在创建时就可用了.
// 而真实的`Andthen`允许根据第一个`Future`的输出来创建第二个`Future`，因此复杂的多。
pub struct AndThenFut&lt;FutureA, FutureB&gt; {
    first: Option&lt;FutureA&gt;,
    second: FutureB,
}

impl&lt;FutureA, FutureB&gt; SimpleFuture for AndThenFut&lt;FutureA, FutureB&gt;
where
    FutureA: SimpleFuture&lt;Output = ()&gt;,
    FutureB: SimpleFuture&lt;Output = ()&gt;,
{
    type Output = ();
    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        if let Some(first) = &amp;mut self.first {
            match first.poll(wake) {
                // 我们已经完成了第一个 Future， 可以将它移除， 然后准备开始运行第二个
                Poll::Ready(()) =&gt; self.first.take(),
                // 第一个 Future 还不能完成
                Poll::Pending =&gt; return Poll::Pending,
            };
        }

        // 运行到这里，说明第一个Future已经完成，尝试去完成第二个
        self.second.poll(wake)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这些例子展示了在不需要内存对象分配以及深层嵌套回调的情况下，该如何使用 <code>Future</code> 特征去表达异步控制流。 在了解了基础的控制流后，我们再来看看真实的 <code>Future</code> 特征有何不同之处。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Future {
    type Output;
    fn poll(
        // 首先值得注意的地方是，`self`的类型从`&amp;mut self`变成了`Pin&lt;&amp;mut Self&gt;`:
        self: Pin&lt;&amp;mut Self&gt;,
        // 其次将`wake: fn()` 修改为 `cx: &amp;mut Context&lt;'_&gt;`:
        cx: &amp;mut Context&lt;'_&gt;,
    ) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>首先这里多了一个 <code>Pin</code> ，关于它我们会在后面章节详细介绍，现在你只需要知道使用它可以创建一个无法被移动的 <code>Future</code> ，因为无法被移动，因此它将具有固定的内存地址，意味着我们可以存储它的指针(如果内存地址可能会变动，那存储指针地址将毫无意义！)，也意味着可以实现一个自引用数据结构: <code>struct MyFut { a: i32, ptr_to_a: *const i32 }</code>。 而对于 <code>async/await</code> 来说，<code>Pin</code> 是不可或缺的关键特性。</p>
<p>其次，从 <code>wake: fn()</code> 变成了 <code>&amp;mut Context&lt;'_&gt;</code> 。意味着 <code>wake</code> 函数可以携带数据了，为何要携带数据？考虑一个真实世界的场景，一个复杂应用例如web服务器可能有数千连接同时在线，那么同时就有数千 <code>Future</code> 在被同时管理着，如果不能携带数据，当一个 <code>Future</code> 调用 <code>wake</code> 后，执行器该如何知道是哪个 <code>Future</code> 调用了 <code>wake</code> ,然后进一步去 <code>poll</code> 对应的 <code>Future</code> ？没有办法！那之前的例子为啥就可以使用没有携带数据的 <code>wake</code> ？ 因为足够简单，不存在歧义性。</p>
<p>总之，在正式场景要进行 <code>wake</code> ，就必须携带上数据。 而 <code>Context</code> 类型通过提供一个 <code>Waker</code> 类型的值，就可以用来唤醒特定的的任务。</p>
<h2 id="使用-waker-来唤醒任务"><a class="header" href="#使用-waker-来唤醒任务">使用 Waker 来唤醒任务</a></h2>
<p>对于 <code>Future</code> 来说，第一次被 <code>poll</code> 时无法完成任务是很正常的。但它需要确保在未来一旦准备好时，可以通知执行器再次对其进行 <code>poll</code> 进而继续往下执行，该通知就是通过 <code>Waker</code> 类型完成的。</p>
<p><code>Waker</code> 提供了一个 <code>wake()</code> 方法可以用于告诉执行器：相关的任务可以被唤醒了，此时执行器就可以对相应的 <code>Future</code> 再次进行 <code>poll</code> 操作。</p>
<h4 id="构建一个定时器"><a class="header" href="#构建一个定时器">构建一个定时器</a></h4>
<p>下面一起来实现一个简单的定时器 <code>Future</code> 。为了让例子尽量简单，当计时器创建时，我们会启动一个线程接着让该线程进入睡眠，等睡眠结束后再通知给 <code>Future</code> 。</p>
<p>注意本例子还会在后面继续使用，因此我们重新创建一个工程来演示：使用 <code>cargo new --lib timer_future</code> 来创建一个新工程，在 <code>lib</code> 包的根路径 <code>src/lib.rs</code> 中添加以下内容：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{
    future::Future,
    pin::Pin,
    sync::{Arc, Mutex},
    task::{Context, Poll, Waker},
    thread,
    time::Duration,
};
<span class="boring">}
</span></code></pre></pre>
<p>继续来实现 <code>Future</code> 定时器，之前提到: 新建线程在睡眠结束后会需要将状态同步给定时器 <code>Future</code> ，由于是多线程环境，我们需要使用  <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 来作为一个共享状态，用于在新线程和 <code>Future</code> 定时器间共享。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TimerFuture {
    shared_state: Arc&lt;Mutex&lt;SharedState&gt;&gt;,
}

/// 在Future和等待的线程间共享状态
struct SharedState {
    /// 定时(睡眠)是否结束
    completed: bool,

    /// 当睡眠结束后，线程可以用`waker`通知`TimerFuture`来唤醒任务
    waker: Option&lt;Waker&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>下面给出 <code>Future</code> 的具体实现:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Future for TimerFuture {
    type Output = ();
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        // 通过检查共享状态，来确定定时器是否已经完成
        let mut shared_state = self.shared_state.lock().unwrap();
        if shared_state.completed {
            Poll::Ready(())
        } else {
            // 设置`waker`，这样新线程在睡眠(计时)结束后可以唤醒当前的任务，接着再次对`Future`进行`poll`操作, 
            // 
            // 下面的`clone`每次被`poll`时都会发生一次，实际上，应该是只`clone`一次更加合理。
            // 选择每次都`clone`的原因是： `TimerFuture`可以在执行器的不同任务间移动，如果只克隆一次，
            // 那么获取到的`waker`可能已经被篡改并指向了其它任务，最终导致执行器运行了错误的任务
            shared_state.waker = Some(cx.waker().clone());
            Poll::Pending
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>代码很简单，只要新线程设置了 <code>shared_state.completed = true</code> ，那任务就能顺利结束。如果没有设置，会为当前的任务克隆一份 <code>Waker</code> ，这样新线程就可以使用它来唤醒当前的任务。</p>
<p>最后，再来创建一个 API 用于构建定时器和启动计时线程: </p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TimerFuture {
    /// 创建一个新的`TimeFuture`，在指定的时间结束后，该`Future`可以完成
    pub fn new(duration: Duration) -&gt; Self {
        let shared_state = Arc::new(Mutex::new(SharedState {
            completed: false,
            waker: None,
        }));

        // 创建新线程
        let thread_shared_state = shared_state.clone();
        thread::spawn(move || {
            // 睡眠指定时间实现计时功能
            thread::sleep(duration);
            let mut shared_state = thread_shared_state.lock().unwrap();
            // 通知执行器定时器已经完成，可以继续`poll`对应的`Future`了
            shared_state.completed = true;
            if let Some(waker) = shared_state.waker.take() {
                waker.wake()
            }
        });

        TimerFuture { shared_state }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>至此，一个简单的定时器 <code>Future</code> 就已创建成功，那么该如何使用它呢？相信部分爱动脑筋的读者已经猜到了：我们需要创建一个执行器，才能让程序动起来。</p>
<h2 id="执行器executor"><a class="header" href="#执行器executor">执行器Executor</a></h2>
<p>Rust的 <code>Future</code> 是惰性的：只有屁股上拍一拍，它才会努力动一动。其中一个推动它的方式就是在 <code>async</code> 函数中使用 <code>.await</code> 来调用另一个 <code>async</code> 函数，但是这个只能解决 <code>async</code> 内部的问题，那么这些最外层的 <code>async</code> 函数，谁来推动它们运行呢？答案就是我们之前多次提到的执行器 <code>executor</code> 。</p>
<p>执行器会管理一批 <code>Future</code> (最外层的 <code>ascyn</code> 函数)，然后通过不停地 <code>poll</code> 推动它们直到完成。 最开始，执行器会先 <code>poll</code> 一次 <code>Future</code> ，后面就不会主动去 <code>poll</code> 了，而是等待 <code>Future</code> 通过调用 <code>wake</code> 函数来通知它可以继续，它才会继续去 <code>poll</code> 。这种<strong>wake 通知然后 poll</strong>的方式会不断重复，直到 <code>Future</code> 完成。</p>
<h4 id="构建执行器"><a class="header" href="#构建执行器">构建执行器</a></h4>
<p>下面我们将实现一个简单的执行器，它可以同时并发运行多个 <code>Future</code> 。例子中，需要用到 <code>futures</code> 包的 <code>ArcWake</code> 特征，它可以提供一个方便的途径去构建一个 <code>Waker</code> 。编辑 <code>Cargo.tom</code> ，添加下面依赖:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
futures = &quot;0.3&quot;
<span class="boring">}
</span></code></pre></pre>
<p>在之前的内容中，我们在 <code>src/lib.rs</code> 中创建了定时器 <code>Future</code> ，现在在 <code>src/main.js</code> 中来创建程序的主体内容，开始之前，先引入所需的包：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use {
    futures::{
        future::{BoxFuture, FutureExt},
        task::{waker_ref, ArcWake},
    },
    std::{
        future::Future,
        sync::mpsc::{sync_channel, Receiver, SyncSender},
        sync::{Arc, Mutex},
        task::{Context, Poll},
        time::Duration,
    },
    // 引入之前实现的定时器模块
    timer_future::TimerFuture,
};
<span class="boring">}
</span></code></pre></pre>
<p>执行器需要从一个消息通道( <code>channel</code> )中拉取事件，然后运行它们。当一个任务准备好后（可以继续执行），它会将自己放入消息通道中，然后等待执行器 <code>poll</code> 。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 任务执行器，负责从通道中接收任务然后执行
struct Executor {
    ready_queue: Receiver&lt;Arc&lt;Task&gt;&gt;,
}

/// `Spawner`负责创建新的`Future`然后将它发送到任务通道中
#[derive(Clone)]
struct Spawner {
    task_sender: SyncSender&lt;Arc&lt;Task&gt;&gt;,
}

/// 一个Future，它可以调度自己(将自己放入任务通道中)，然后等待执行器去`poll`
struct Task {
    /// 进行中的Future，在未来的某个时间点会被完成
    /// 
    /// 按理来说`Mutext`在这里是多余的，因为我们只有一个线程来执行任务。但是由于
    /// Rust并不聪明，它无法知道`Future`只会在一个线程内被修改，并不会被夸线程修改。因此
    /// 我们需要使用`Mutex`来满足这个笨笨的编译器对线程安全的执着。
    ///
    /// 如果是生产级的执行器实现，不会使用`Mutex`，因为会带来性能上的开销，取而代之的是使用`UnsafeCell`
    future: Mutex&lt;Option&lt;BoxFuture&lt;'static, ()&gt;&gt;&gt;,

    /// 可以将该任务自身放回到任务通道中，等待执行器的poll
    task_sender: SyncSender&lt;Arc&lt;Task&gt;&gt;,
}

fn new_executor_and_spawner() -&gt; (Executor, Spawner) {
    // 任务通道允许的最大缓冲数(任务队列的最大长度)
    // 当前的实现仅仅是为了简单，在实际的执行中，并不会这么使用
    const MAX_QUEUED_TASKS: usize = 10_000;
    let (task_sender, ready_queue) = sync_channel(MAX_QUEUED_TASKS);
    (Executor { ready_queue }, Spawner { task_sender })
}
<span class="boring">}
</span></code></pre></pre>
<p>下面再来添加一个方法用于生成 <code>Future</code> , 然后将它放入任务通道中:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Spawner {
    fn spawn(&amp;self, future: impl Future&lt;Output = ()&gt; + 'static + Send) {
        let future = future.boxed();
        let task = Arc::new(Task {
            future: Mutex::new(Some(future)),
            task_sender: self.task_sender.clone(),
        });
        self.task_sender.send(task).expect(&quot;任务队列已满&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在执行器 <code>poll</code> 一个 <code>Future</code> 之前，首先需要调用 <code>wake</code> 方法进行唤醒，然后再由 <code>Waker</code> 负责调度该任务并将其放入任务通道中。创建 <code>Waker</code> 的最简单的方式就是实现 <code>ArcWake</code> 特征，先来为我们的任务实现 <code>ArcWake</code> 特征，这样它们就能被转变成 <code>Waker</code> 然后被唤醒:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ArcWake for Task {
    fn wake_by_ref(arc_self: &amp;Arc&lt;Self&gt;) {
        // 通过发送任务到任务管道的方式来实现`wake`，这样`wake`后，任务就能被执行器`poll`
        let cloned = arc_self.clone();
        arc_self
            .task_sender
            .send(cloned)
            .expect(&quot;任务队列已满&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>当任务实现了 <code>ArcWake</code> 特征后，它就变成了 <code>Waker</code> ，在调用 <code>wake()</code> 对其唤醒后会将任务复制一份所有权( <code>Arc</code> )，然后将其发送到任务通道中。最后我们的执行器将从通道中获取任务，然后进行 <code>poll</code> 执行：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Executor {
    fn run(&amp;self) {
        while let Ok(task) = self.ready_queue.recv() {
            // 获取一个future，若它还没有完成(仍然是Some，不是None)，则对它进行一次poll并尝试完成它
            let mut future_slot = task.future.lock().unwrap();
            if let Some(mut future) = future_slot.take() {
                // 基于任务自身创建一个 `LocalWaker`
                let waker = waker_ref(&amp;task);
                let context = &amp;mut Context::from_waker(&amp;*waker);
                // `BoxFuture&lt;T&gt;`是`Pin&lt;Box&lt;dyn Future&lt;Output = T&gt; + Send + 'static&gt;&gt;`的类型别名
                // 通过调用`as_mut`方法，可以将上面的类型转换成`Pin&lt;&amp;mut dyn Future + Send + 'static&gt;`
                if future.as_mut().poll(context).is_pending() {
                    // Future还没执行完，因此将它放回任务中，等待下次被poll
                    *future_slot = Some(future);
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>恭喜！我们终于拥有了自己的执行器，下面再来写一段代码使用该执行器去运行之前的定时器 <code>Future</code> ：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let (executor, spawner) = new_executor_and_spawner();

    // 生成一个任务
    spawner.spawn(async {
        println!(&quot;howdy!&quot;);
        // 创建定时器Future，并等待它完成
        TimerFuture::new(Duration::new(2, 0)).await;
        println!(&quot;done!&quot;);
    });

    // drop掉任务，这样执行器就知道任务已经完成，不会再有新的任务进来
    drop(spawner);

    // 运行执行器直到任务队列为空
    // 任务运行后，会先打印`howdy!`, 暂停2秒，接着打印 `done!`
    executor.run();
}
</code></pre></pre>
<h2 id="执行器和系统io"><a class="header" href="#执行器和系统io">执行器和系统IO</a></h2>
<p>前面我们一起看过一个使用 <code>Future</code> 从 <code>Socket</code> 中异步读取数据的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SocketRead&lt;'a&gt; {
    socket: &amp;'a Socket,
}

impl SimpleFuture for SocketRead&lt;'_&gt; {
    type Output = Vec&lt;u8&gt;;

    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        if self.socket.has_data_to_read() {
            // socket有数据，写入buffer中并返回
            Poll::Ready(self.socket.read_buf())
        } else {
            // socket中还没数据
            // 
            // 注册一个`wake`函数，当数据可用时，该函数会被调用，
            // 然后当前Future的执行器会再次调用`poll`方法，此时就可以读取到数据
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>该例子中，<code>Future</code> 将从 <code>Socket</code> 读取数据，若当前还没有数据，则会让出当前线程的所有权，允许执行器去执行其它的 <code>Future</code> 。当数据准备好后，会调用 <code>wake()</code> 函数将该 <code>Future</code> 的任务放入任务通道中，等待执行器的 <code>poll</code> 。</p>
<p>关于该流程已经反复讲了很多次，相信大家应该非常清楚了。然而该例子中还有一个疑问没有解决：</p>
<ul>
<li><code>set_readable_callback</code> 方法到底是怎么工作的？怎么才能知道 <code>socket</code> 中的数据已经可以被读取了？</li>
</ul>
<p>关于第二点，其中一个简单粗暴的方法就是使用一个新线程不停的检查 <code>socket</code> 中是否有了数据，当有了后，就调用 <code>wake()</code> 函数。该方法确实可以满足需求，但是性能着实太低了，需要为每个阻塞的 <code>Future</code> 都创建一个单独的线程！</p>
<p>在现实世界中，该问题往往是通过操作系统提供的 <code>IO</code> 服务来完成，例如 <code>linux</code> 、<code>FreeBSD</code> 和 <code>Macos</code> 中的 <strong><code>epoll</code></strong> ，<code>Windows</code> 中的 <strong><code>IOCP</code></strong>, <code>Fuchisa</code>中的 <strong><code>ports</code></strong> 等(可以通过 Rust 的跨平台包 <code>mio</code> 来使用它们)。使用它们，允许一个线程同时阻塞地去等待多个异步IO事件，一旦某个事件完成就立即退出阻塞并返回数据。相关实现类似于以下代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct IoBlocker {
    /* ... */
}

struct Event {
    // Event的唯一ID，该事件发生后，就会被监听起来
    id: usize,

    // 一组需要等待或者已发生的信号
    signals: Signals,
}

impl IoBlocker {
    /// 创建异步IO事件的集合，这些事件是阻塞等待的
    fn new() -&gt; Self { /* ... */ }

    /// 对指定的IO事件表示兴趣
    fn add_io_event_interest(
        &amp;self,

        /// 事件所绑定的socket
        io_object: &amp;IoObject,

        event: Event,
    ) { /* ... */ }

    /// 进入阻塞，直到某个事件出现
    fn block(&amp;self) -&gt; Event { /* ... */ }
}

let mut io_blocker = IoBlocker::new();
io_blocker.add_io_event_interest(
    &amp;socket_1,
    Event { id: 1, signals: READABLE },
);
io_blocker.add_io_event_interest(
    &amp;socket_2,
    Event { id: 2, signals: READABLE | WRITABLE },
);
let event = io_blocker.block();

// 当socket的数据可以读取时，打印 &quot;Socket 1 is now READABLE&quot; 
println!(&quot;Socket {:?} is now {:?}&quot;, event.id, event.signals);
<span class="boring">}
</span></code></pre></pre>
<p>这样，我们只需要一个执行器线程，它会接收IO事件并将其分发到对应的 <code>Waker</code> 中，接着后者会唤醒相关的任务，最终通过执行器 <code>poll</code> 后，任务可以顺利的继续执行, 这种IO读取流程可以不停的循环，直到 <code>socket</code> 关闭。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="定海神针pin和unpin"><a class="header" href="#定海神针pin和unpin">定海神针Pin和Unpin</a></h1>
<p>在Rust异步编程中，有一个定海神针般的存在，它就是 <code>Pin</code> ，作用说简单也简单，说复杂也非常复杂，当初刚出来时就连一些 Rust 大佬都一头雾水，何况瑟瑟发抖的我。好在今非昔比，目前网上的资料已经很全，而我就借花献佛，给大家好好讲讲这个<code>Pin</code>。</p>
<p>在Rust中，所有的类型可以分为两类:</p>
<ul>
<li><strong>类型的值可以在内存中安全地被移动</strong>，例如数值、字符串、布尔值、结构体、枚举，总之你能想到的几乎所有类型都可以落入到此范畴内</li>
<li><strong>自引用类型</strong>，大魔王来了，大家快跑，在之前章节我们已经见识过它的厉害</li>
</ul>
<p>下面就是一个自引用类型</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SelfRef {
    value: String,
    pointer_to_value: *mut String,
}
<span class="boring">}
</span></code></pre></pre>
<p>在上面的结构体中，<code>pointer_to_value</code> 是一个原生指针，指向第一个字段 <code>value</code> 持有的字符串 <code>String</code> 。很简单对吧？现在考虑一个情况， 若<code>String</code> 被移动了怎么办？</p>
<p>此时一个致命的问题就出现了：新的字符串的内存地址变了，而 <code>pointer_to_value</code> 依然指向之前的地址，一个重大bug就出现了！</p>
<p>灾难发生，英雄在哪？只见 <code>Pin</code> 闪亮登场，它可以防止一个类型在内存中被移动。再来回忆下之前在 <code>Future</code> 章节中，我们提到过在 <code>poll</code> 方法的签名中有一个 <code>self: Pin&lt;&amp;mut Self&gt;</code> ，那么为何要在这里使用 <code>Pin</code> 呢？ </p>
<h2 id="为何需要pin"><a class="header" href="#为何需要pin">为何需要Pin</a></h2>
<p>其实 <code>Pin</code> 还有一个小伙伴 <code>UnPin</code> ，与前者相反，后者表示类型可以在内存中安全地移动。在深入之前，我们先来回忆下 <code>async/.await</code> 是如何工作的:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fut_one = /* ... */; // Future 1
let fut_two = /* ... */; // Future 2
async move {
    fut_one.await;
    fut_two.await;
}
<span class="boring">}
</span></code></pre></pre>
<p>在底层，<code>async</code> 会创建一个实现了 <code>Future</code> 的匿名类型，并提供了一个 <code>poll</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `async { ... }`语句块创建的 `Future` 类型
struct AsyncFuture {
    fut_one: FutOne,
    fut_two: FutTwo,
    state: State,
}

// `async` 语句块可能处于的状态
enum State {
    AwaitingFutOne,
    AwaitingFutTwo,
    Done,
}

impl Future for AsyncFuture {
    type Output = ();

    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;()&gt; {
        loop {
            match self.state {
                State::AwaitingFutOne =&gt; match self.fut_one.poll(..) {
                    Poll::Ready(()) =&gt; self.state = State::AwaitingFutTwo,
                    Poll::Pending =&gt; return Poll::Pending,
                }
                State::AwaitingFutTwo =&gt; match self.fut_two.poll(..) {
                    Poll::Ready(()) =&gt; self.state = State::Done,
                    Poll::Pending =&gt; return Poll::Pending,
                }
                State::Done =&gt; return Poll::Ready(()),
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>当 <code>poll</code> 第一次被调用时，它会去查询 <code>fut_one</code> 的状态，若 <code>fut_one</code> 无法完成，则 <code>poll</code> 方法会返回。未来对 <code>poll</code> 的调用将从上一次调用结束的地方开始。该过程会一直持续，直到 <code>Future</code> 完成为止。</p>
<p>然而，如果我们的 <code>async</code> 语句块中使用了引用类型，会发生什么？例如下面例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async {
    let mut x = [0; 128];
    let read_into_buf_fut = read_into_buf(&amp;mut x);
    read_into_buf_fut.await;
    println!(&quot;{:?}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p>这段代码会编译成下面的形式：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ReadIntoBuf&lt;'a&gt; {
    buf: &amp;'a mut [u8], // 指向下面的`x`字段
}

struct AsyncFuture {
    x: [u8; 128],
    read_into_buf_fut: ReadIntoBuf&lt;'what_lifetime?&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>这里，<code>ReadIntoBuf</code> 拥有一个引用字段，指向了结构体的另一个字段 <code>x</code> ，一旦 <code>AsyncFuture</code> 被移动，那 <code>x</code> 的地址也将随之变化，此时对 <code>x</code> 的引用就变成了不合法的，也就是 <code>read_into_buf_fut.buf</code> 会变为不合法的。</p>
<p>若能将 <code>Future</code> 在内存中固定到一个位置，就可以避免这种问题的发生，也就可以安全的创建上面这种引用类型。</p>
<h2 id="unpin"><a class="header" href="#unpin">Unpin</a></h2>
<p>事实上，绝大多数类型都不在意是否被移动(开篇提到的第一种类型)，因此它们都<strong>自动实现</strong>了 <code>Unpin</code> 特征。</p>
<p>从名字推测，大家可能以为 <code>Pin</code> 和 <code>Unpin</code> 都是特征吧？实际上，<code>Pin</code> 不按套路出牌，它是一个结构体：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Pin&lt;P&gt; {
    pointer: P,
}
<span class="boring">}
</span></code></pre></pre>
<p>它包裹一个指针，并且能确保该指针指向的数据不会被移动，例如 <code>Pin&lt;&amp;mut T&gt;</code> , <code>Pin&lt;&amp;T&gt;</code> , <code>Pin&lt;Box&lt;T&gt;&gt;</code> ，都能确保 <code>T</code> 不会被移动。</p>
<img alt="" src="async//img/async-03.png" class="center"  />
<p>而 <code>Unpin</code> 才是一个特征，它表明一个类型可以随意被移动，那么问题来了，可以被 <code>Pin</code> 住的值，它有没有实现什么特征呢？ 答案很出乎意料，可以被 <code>Pin</code> 住的值实现的特征是 <code>!Unpin</code> ，大家可能之前没有见过，但是它其实很简单，<code>!</code> 代表没有实现某个特征的意思，<code>!Unpin</code> 说明类型没有实现 <code>Unpin</code> 特征，那自然就可以被 <code>Pin</code> 了。</p>
<p>那是不是意味着类型如果实现了 <code>Unpin</code> 特征，就不能被 <code>Pin</code> 了？其实，还是可以 <code>Pin</code> 的，毕竟它只是一个结构体，你可以随意使用，<strong>但是不再有任何效果而已，该值一样可以被移动</strong>！</p>
<p>例如 <code>Pin&lt;&amp;mut u8&gt;</code> ，显然 <code>u8</code> 实现了 <code>Unpin</code> 特征，它可以在内存中被移动，因此 <code>Pin&lt;&amp;mut u8&gt;</code> 跟 <code>&amp;mut u8</code> 实际上并无区别，一样可以被移动。</p>
<p>因此，一个类型如果不能被移动，它必须实现 <code>!Unpin</code> 特征。如果大家对 <code>Pin</code> 、 <code>Unpin</code> 还是模模糊糊，建议再重复看一遍之前的内容，理解它们对于我们后面要讲到的内容非常重要！</p>
<p>如果将 <code>Unpin</code> 与之前章节学过的 <a href="https://www.zhihu.com/question/303273488/answer/2309266713"><code>Send/Sync</code></a> 进行下对比，会发现它们都很像：</p>
<ul>
<li>都是标记特征( marker trait )，该特征未定义任何行为，非常适用于标记</li>
<li>都可以通过!语法去除实现</li>
<li>绝大多数情况都是自动实现, 无需我们的操心</li>
</ul>
<h2 id="深入理解-pin"><a class="header" href="#深入理解-pin">深入理解 Pin</a></h2>
<p>对于上面的问题，我们可以简单的归结为如何在 Rust 中处理自引用类型(果然，只要是难点，都和自引用脱离不了关系)，下面用一个稍微简单点的例子来理解下 <code>Pin</code> :</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
}

impl Test {
    fn new(txt: &amp;str) -&gt; Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
        }
    }

    fn init(&amp;mut self) {
        let self_ref: *const String = &amp;self.a;
        self.b = self_ref;
    }

    fn a(&amp;self) -&gt; &amp;str {
        &amp;self.a
    }

    fn b(&amp;self) -&gt; &amp;String {
        assert!(!self.b.is_null(), &quot;Test::b called without Test::init being called first&quot;);
        unsafe { &amp;*(self.b) }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Test</code> 提供了方法用于获取字段 <code>a</code> 和 <code>b</code> 的值的引用。这里<code>b</code> 是 <code>a</code> 的一个引用，但是我们并没有使用引用类型而是用了原生指针，原因是：Rust 的借用规则不允许我们这样用，因为不符合生命周期的要求。 此时的 <code>Test</code> 就是一个自引用结构体。</p>
<p>如果不移动任何值，那么上面的例子将没有任何问题，例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    test1.init();
    let mut test2 = Test::new(&quot;test2&quot;);
    test2.init();

    println!(&quot;a: {}, b: {}&quot;, test1.a(), test1.b());
    println!(&quot;a: {}, b: {}&quot;, test2.a(), test2.b());

}
</code></pre></pre>
<p>输出非常正常：</p>
<pre><code class="language-console">a: test1, b: test1
a: test2, b: test2
</code></pre>
<p>明知山有虎，偏向虎山行，这才是我辈年轻人的风华。既然移动数据会导致指针不合法，那我们就移动下数据试试，将 <code>test</code> 和 <code>test2</code> 进行下交换：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    test1.init();
    let mut test2 = Test::new(&quot;test2&quot;);
    test2.init();

    println!(&quot;a: {}, b: {}&quot;, test1.a(), test1.b());
    std::mem::swap(&amp;mut test1, &amp;mut test2);
    println!(&quot;a: {}, b: {}&quot;, test2.a(), test2.b());

}
</code></pre></pre>
<p>按理来说，这样修改后，输出应该如下:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a: test1, b: test1
a: test1, b: test1
<span class="boring">}
</span></code></pre></pre>
<p>但是实际运行后，却产生了下面的输出:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a: test1, b: test1
a: test1, b: test2
<span class="boring">}
</span></code></pre></pre>
<p>原因是 <code>test2.b</code> 指针依然指向了旧的地址，而该地址对应的值现在在 <code>test1</code> 里，最终会打印出意料之外的值。</p>
<p>如果大家还是将信将疑，那再看看下面的代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    test1.init();
    let mut test2 = Test::new(&quot;test2&quot;);
    test2.init();

    println!(&quot;a: {}, b: {}&quot;, test1.a(), test1.b());
    std::mem::swap(&amp;mut test1, &amp;mut test2);
    test1.a = &quot;I've totally changed now!&quot;.to_string();
    println!(&quot;a: {}, b: {}&quot;, test2.a(), test2.b());

}
</code></pre></pre>
<p>下面的图片也可以帮助更好的理解这个过程：</p>
<img alt="" src="async//img/async-02.jpg" class="center"  />
<h2 id="pin-在实践中的运用"><a class="header" href="#pin-在实践中的运用">Pin 在实践中的运用</a></h2>
<p>在理解了 <code>Pin</code> 的作用后，我们再来看看它怎么帮我们解决问题。</p>
<h4 id="将值固定到栈上"><a class="header" href="#将值固定到栈上">将值固定到栈上</a></h4>
<p>回到之前的例子，我们可以用 <code>Pin</code> 来解决指针指向的数据被移动的问题:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}


impl Test {
    fn new(txt: &amp;str) -&gt; Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned, // 这个标记可以让我们的类型自动实现特征`!Unpin`
        }
    }

    fn init(self: Pin&lt;&amp;mut Self&gt;) {
        let self_ptr: *const String = &amp;self.a;
        let this = unsafe { self.get_unchecked_mut() };
        this.b = self_ptr;
    }

    fn a(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
        &amp;self.get_ref().a
    }

    fn b(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;String {
        assert!(!self.b.is_null(), &quot;Test::b called without Test::init being called first&quot;);
        unsafe { &amp;*(self.b) }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面代码中，我们使用了一个标记类型 <code>PhantomPinned</code> 将自定义结构体 <code>Test</code> 变成了 <code>!Unpin</code> (编译器会自动帮我们实现)，因此该结构体无法再被移动。</p>
<p>一旦类型实现了 <code>!Unpin</code> ，那将它的值固定到栈( <code>stack</code> )上就是不安全的行为，因此在代码中我们使用了 <code>unsafe</code> 语句块来进行处理，你也可以使用 <a href="https://docs.rs/pin-utils/"><code>pin_utils</code></a> 来避免 <code>unsafe</code> 的使用。</p>
<blockquote>
<p>BTW, Rust 中的 unsafe 其实没有那么可怕，虽然听上去很不安全，但是实际上 Rust 依然提供了很多机制来帮我们提升了安全性，因此不必像对待 Go 语言的 <code>unsafe</code> 那样去畏惧于使用Rust中的 <code>unsafe</code> ，大致使用原则总结如下：没必要用时，就不要用，当有必要用时，就大胆用，但是尽量控制好边界，让 <code>unsafe</code> 的范围尽可能小</p>
</blockquote>
<p>此时，再去尝试移动被固定的值，就会导致<strong>编译错误</strong> ：</p>
<pre><pre class="playground"><code class="language-rust edition2021">pub fn main() {
    // 此时的`test1`可以被安全的移动
    let mut test1 = Test::new(&quot;test1&quot;);
    // 新的`test1`由于使用了`Pin`，因此无法再被移动，这里的声明会将之前的`test1`遮蔽掉(shadow)
    let mut test1 = unsafe { Pin::new_unchecked(&amp;mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new(&quot;test2&quot;);
    let mut test2 = unsafe { Pin::new_unchecked(&amp;mut test2) };
    Test::init(test2.as_mut());

    println!(&quot;a: {}, b: {}&quot;, Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    std::mem::swap(test1.get_mut(), test2.get_mut());
    println!(&quot;a: {}, b: {}&quot;, Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
</code></pre></pre>
<p>注意到之前的粗体字了吗？是的，Rust 并不是在运行时做这件事，而是在编译期就完成了，因此没有额外的性能开销！来看看报错:</p>
<pre><code class="language-shell">error[E0277]: `PhantomPinned` cannot be unpinned
   --&gt; src/main.rs:47:43
    |
47  |     std::mem::swap(test1.get_mut(), test2.get_mut());
    |                                           ^^^^^^^ within `Test`, the trait `Unpin` is not implemented for `PhantomPinned`
</code></pre>
<blockquote>
<p>需要注意的是固定在栈上非常依赖于你写出的 <code>unsafe</code> 代码的正确性。我们知道 <code>&amp;'a mut T</code> 可以固定的生命周期是 <code>'a</code> ，但是我们却不知道当生命周期 <code>'a</code> 结束后，该指针指向的数据是否会被移走。如果你的 <code>unsafe</code> 代码里这么实现了，那么就会违背 <code>Pin</code> 应该具有的作用！</p>
<p>一个常见的错误就是忘记去遮蔽(shadow )初始的变量，因为你可以 <code>drop</code> 掉 <code>Pin</code> ，然后在 <code>&amp;'a mut T</code> 结束后去移动数据:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">pub fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    let mut test1 = unsafe { Pin::new_unchecked(&amp;mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new(&quot;test2&quot;);
    let mut test2 = unsafe { Pin::new_unchecked(&amp;mut test2) };
    Test::init(test2.as_mut());

    println!(&quot;a: {}, b: {}&quot;, Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    std::mem::swap(test1.get_mut(), test2.get_mut());
    println!(&quot;a: {}, b: {}&quot;, Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
</code></pre></pre>
<h4 id="固定到堆上"><a class="header" href="#固定到堆上">固定到堆上</a></h4>
<p>将一个 <code>!Unpin</code> 类型的值固定到堆上，会给予该值一个稳定的内存地址，它指向的堆中的值在 <code>Pin</code> 后是无法被移动的。而且与固定在栈上不同，我们知道堆上的值在整个生命周期内都会被稳稳地固定住。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl Test {
    fn new(txt: &amp;str) -&gt; Pin&lt;Box&lt;Self&gt;&gt; {
        let t = Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned,
        };
        let mut boxed = Box::pin(t);
        let self_ptr: *const String = &amp;boxed.as_ref().a;
        unsafe { boxed.as_mut().get_unchecked_mut().b = self_ptr };

        boxed
    }

    fn a(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
        &amp;self.get_ref().a
    }

    fn b(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;String {
        unsafe { &amp;*(self.b) }
    }
}

pub fn main() {
    let test1 = Test::new(&quot;test1&quot;);
    let test2 = Test::new(&quot;test2&quot;);

    println!(&quot;a: {}, b: {}&quot;,test1.as_ref().a(), test1.as_ref().b());
    println!(&quot;a: {}, b: {}&quot;,test2.as_ref().a(), test2.as_ref().b());
}
</code></pre></pre>
<h4 id="将固定住的-future-变为-unpin"><a class="header" href="#将固定住的-future-变为-unpin">将固定住的 <code>Future</code> 变为 <code>Unpin</code></a></h4>
<p>之前的章节我们有提到 <code>async</code> 函数返回的 <code>Future</code> 默认就是 <code>!Unpin</code> 的。</p>
<p>但是，在实际应用中，一些函数会要求它们处理的 <code>Future</code> 是 <code>Unpin</code> 的，此时，若你使用的 <code>Future</code> 是 <code>!Unpin</code> 的，必须要使用以下的方法先将 <code>Future</code> 进行固定:</p>
<ul>
<li><code>Box::pin</code>， 创建一个 <code>Pin&lt;Box&lt;T&gt;&gt;</code></li>
<li><code>pin_utils::pin_mut!</code>， 创建一个 <code>Pin&lt;&amp;mut T&gt;</code></li>
</ul>
<p>固定后获得的 <code>Pin&lt;Box&lt;T&gt;&gt;</code> 和 <code>Pin&lt;&amp;mut T&gt;</code> 既可以用于 <code>Future</code> ，<strong>又会自动实现 <code>Unpin</code></strong>。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pin_utils::pin_mut; // `pin_utils` 可以在crates.io中找到

// 函数的参数是一个`Future`，但是要求该`Future`实现`Unpin`
fn execute_unpin_future(x: impl Future&lt;Output = ()&gt; + Unpin) { /* ... */ }

let fut = async { /* ... */ };
// 下面代码报错: 默认情况下，`fut` 实现的是`!Unpin`，并没有实现`Unpin`
// execute_unpin_future(fut); 

// 使用`Box`进行固定
let fut = async { /* ... */ };
let fut = Box::pin(fut);
execute_unpin_future(fut); // OK

// 使用`pin_mut!`进行固定
let fut = async { /* ... */ };
pin_mut!(fut);
execute_unpin_future(fut); // OK
<span class="boring">}
</span></code></pre></pre>
<h2 id="总结-18"><a class="header" href="#总结-18">总结</a></h2>
<p>相信大家看到这里，脑袋里已经快被 <code>Pin</code> 、 <code>Unpin</code> 、 <code>!Unpin</code> 整爆炸了，没事，我们再来火上浇油下:)</p>
<ul>
<li>若 <code>T: Unpin</code> ( Rust 类型的默认实现)，那么 <code>Pin&lt;'a, T&gt;</code> 跟 <code>&amp;'a mut T</code> 完全相同，也就是 <code>Pin</code> 将没有任何效果, 该移动还是照常移动</li>
<li>绝大多数标准库类型都实现了 <code>Unpin</code> ，事实上，对于 Rust 中你能遇到的绝大多数类型，该结论依然成立
，其中一个例外就是：<code>async/await</code> 生成的 <code>Future</code> 没有实现 <code>Unpin</code></li>
<li>你可以通过以下方法为自己的类型添加 <code>!Unpin</code> 约束：1. 使用文中提到的 <code>std::marker::PhantomPinned</code> 2. 使用<code>nightly</code> 版本下的 <code>feature flag</code> </li>
<li>可以将值固定到栈上，也可以固定到堆上
<ul>
<li>将 <code>!Unpin</code> 值固定到栈上需要使用 <code>unsafe</code></li>
<li>将 <code>!Unpin</code> 值固定到堆上无需 <code>unsafe</code> ，可以通过 <code>Box::pin</code> 来简单的实现</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncawait-和-stream流处理"><a class="header" href="#asyncawait-和-stream流处理">async/await 和 Stream流处理</a></h1>
<p>在入门章节中，我们简单学习了该如何使用 <code>async/.await</code>， 同时在后面也了解了一些底层原理，现在是时候继续继续深入了。</p>
<p><code>async/.await</code>是 Rust 语法的一部分，它在遇到阻塞操作时( 例如IO )会让出当前线程的所有权而不是阻塞当前线程，这样就允许当前线程继续去执行其它代码，最终实现并发。</p>
<p>有两种方式可以使用<code>async</code>： <code>async fn</code>用于声明函数，<code>async { ... }</code>用于声明语句块，它们会返回一个实现 <code>Future</code> 特征的值:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `foo()`返回一个`Future&lt;Output = u8&gt;`,
// 当调用`foo().wait`时，该`Future`将被运行，当调用结束后我们将获取到一个`u8`值
async fn foo() -&gt; u8 { 5 }

fn bar() -&gt; impl Future&lt;Output = u8&gt; {
    // 下面的`async`语句块返回`Future&lt;Output = u8&gt;`
    async {
        let x: u8 = foo().await;
        x + 5
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>async</code> 是懒惰的，直到被执行器 <code>poll</code> 或者 <code>.await</code> 后才会开始运行，其中后者是最常用的运行 <code>Future</code> 的方法。 当 <code>.await</code> 被调用时，它会尝试运行 <code>Future</code> 直到完成，但是若该 <code>Future</code> 进入阻塞，那就会让出当前线程的控制权。当 <code>Future</code> 后面准备再一次被运行时(例如从 <code>socket</code> 中读取到了数据)，执行器会得到通知，并再次运行该 <code>Future</code> ，如此循环，直到完成。</p>
<p>以上过程只是一个简述，详细内容在<a href="async/./future-excuting.html">底层探秘</a>中已经被深入讲解过，因此这里不再赘述。</p>
<h2 id="async-的生命周期"><a class="header" href="#async-的生命周期"><code>async</code> 的生命周期</a></h2>
<p><code>async fn</code> 函数如果拥有引用类型的参数，那它返回的 <code>Future</code> 的生命周期就会被这些参数的生命周期所限制:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo(x: &amp;u8) -&gt; u8 { *x }

// 上面的函数跟下面的函数是等价的:
fn foo_expanded&lt;'a&gt;(x: &amp;'a u8) -&gt; impl Future&lt;Output = u8&gt; + 'a {
    async move { *x }
}
<span class="boring">}
</span></code></pre></pre>
<p>意味着 <code>async fn</code> 函数返回的 <code>Future</code> 必须满足以下条件: 当 <code>x</code> 依然有效时， 该 <code>Future</code> 就必须继续等待( <code>.await</code> ), 也就是说<code>x</code> 必须比 <code>Future</code>活得更久。</p>
<p>在一般情况下，在函数调用后就立即 <code>.await</code> 不会存在任何问题，例如<code>foo(&amp;x).await</code>。但是，若 <code>Future</code> 被先存起来或发送到另一个任务或者线程，就可能存在问题了:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;
fn bad() -&gt; impl Future&lt;Output = u8&gt; {
    let x = 5;
    borrow_x(&amp;x) // ERROR: `x` does not live long enough
}

async fn borrow_x(x: &amp;u8) -&gt; u8 { *x }
<span class="boring">}
</span></code></pre></pre>
<p>以上代码会报错，因为 <code>x</code> 的生命周期只到 <code>bad</code> 函数的结尾。 但是 <code>Future</code> 显然会活得更久：</p>
<pre><code class="language-shell">error[E0597]: `x` does not live long enough
 --&gt; src/main.rs:4:14
  |
4 |     borrow_x(&amp;x) // ERROR: `x` does not live long enough
  |     ---------^^-
  |     |        |
  |     |        borrowed value does not live long enough
  |     argument requires that `x` is borrowed for `'static`
5 | }
  | - `x` dropped here while still borrowed
</code></pre>
<p>其中一个常用的解决方法就是将具有引用参数的 <code>async fn</code> 函数转变成一个具有 <code>'static</code> 生命周期的 <code>Future</code> 。 以上解决方法可以通过将参数和对 <code>async fn</code> 的调用放在同一个 <code>async</code> 语句块来实现:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;

async fn borrow_x(x: &amp;u8) -&gt; u8 { *x }

fn good() -&gt; impl Future&lt;Output = u8&gt; {
    async {
        let x = 5;
        borrow_x(&amp;x).await
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如上所示，通过将参数移动到 <code>async</code> 语句块内， 我们将它的生命周期扩展到 <code>'static</code>， 并跟返回的 <code>Future</code> 保持了一致。</p>
<h2 id="async-move"><a class="header" href="#async-move">async move</a></h2>
<p><code>async</code> 允许我们使用 <code>move</code> 关键字来将环境中变量的所有权转移到语句块内，就像闭包那样，好处是你不再发愁该如何解决借用生命周期的问题，坏处就是无法跟其它代码实现对变量的共享:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 多个不同的 `async` 语句块可以访问同一个本地变量，只要它们在该变量的作用域内执行
async fn blocks() {
    let my_string = &quot;foo&quot;.to_string();

    let future_one = async {
        // ...
        println!(&quot;{my_string}&quot;);
    };

    let future_two = async {
        // ...
        println!(&quot;{my_string}&quot;);
    };

    // 运行两个 Future 直到完成
    let ((), ()) = futures::join!(future_one, future_two);
}



// 由于`async move`会捕获环境中的变量，因此只有一个`async move`语句块可以访问该变量，
// 但是它也有非常明显的好处： 变量可以转移到返回的 Future 中，不再受借用生命周期的限制
fn move_block() -&gt; impl Future&lt;Output = ()&gt; {
    let my_string = &quot;foo&quot;.to_string();
    async move {
        // ...
        println!(&quot;{my_string}&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="当await遇见多线程执行器"><a class="header" href="#当await遇见多线程执行器">当.await遇见多线程执行器</a></h2>
<p>需要注意的是，当使用多线程 <code>Future</code> 执行器( <code>executor</code> )时， <code>Future</code> 可能会在线程间被移动，因此 <code>async</code> 语句块中的变量必须要能在线程间传递。 至于 <code>Future</code> 会在线程间移动的原因是：它内部的任何<code>.await</code>都可能导致它被切换到一个新线程上去执行。</p>
<p>由于需要在多线程环境使用，意味着 <code>Rc</code>、 <code>RefCell</code> 、没有实现 <code>Send</code> 的所有权类型、没有实现 <code>Sync</code> 的引用类型，它们都是不安全的，因此无法被使用</p>
<blockquote>
<p>需要注意！实际上它们还是有可能被使用的，只要在 <code>.await</code> 调用期间，它们没有在作用域范围内。</p>
</blockquote>
<p>类似的原因，在 <code>.await</code> 时使用普通的锁也不安全，例如 <code>Mutex</code> 。原因是，它可能会导致线程池被锁：当一个任务获取锁 <code>A</code> 后，若它将线程的控制权还给执行器，然后执行器又调度运行另一个任务，该任务也去尝试获取了锁 <code>A</code> ，结果当前线程会直接卡死，最终陷入死锁中。</p>
<p>因此，为了避免这种情况的发生，我们需要使用 <code>futures</code> 包下的锁 <code>futures::lock</code> 来替代 <code>Mutex</code> 完成任务。</p>
<h2 id="stream流处理"><a class="header" href="#stream流处理">Stream流处理</a></h2>
<p><code>Stream</code> 特征类似于 <code>Future</code> 特征，但是前者可以在完成前可以生成多个值，这种行为跟标准库中的 <code>Iterator</code> 特征倒是颇为相似。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Stream {
    // Stream生成的值的类型
    type Item;

    // 尝试去解析Stream中的下一个值,
    // 若无数据，返回`Poll::Pending`, 若有数据，返回 `Poll::Ready(Some(x))`, `Stream`完成则返回 `Poll::Ready(None)`
    fn poll_next(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;)
        -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>关于 <code>Stream</code> 的一个常见例子是消息通道（ <code>futures</code> 包中的）的消费者 <code>Receiver</code>。每次有消息从 <code>Send</code> 端发送后，它都可以接收到一个 <code>Some(val)</code> 值， 一旦 <code>Send</code> 端关闭(drop)，且消息通道中没有消息后，它会接收到一个 <code>None</code> 值。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn send_recv() {
    const BUFFER_SIZE: usize = 10;
    let (mut tx, mut rx) = mpsc::channel::&lt;i32&gt;(BUFFER_SIZE);

    tx.send(1).await.unwrap();
    tx.send(2).await.unwrap();
    drop(tx);

    // `StreamExt::next` 类似于 `Iterator::next`, 但是前者返回的不是值，而是一个 `Future&lt;Output = Option&lt;T&gt;&gt;`，
    // 因此还需要使用`.await`来获取具体的值
    assert_eq!(Some(1), rx.next().await);
    assert_eq!(Some(2), rx.next().await);
    assert_eq!(None, rx.next().await);
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="迭代和并发"><a class="header" href="#迭代和并发">迭代和并发</a></h4>
<p>跟迭代器类似，我们也可以迭代一个 <code>Stream</code>。 例如使用<code>map</code>，<code>filter</code>，<code>fold</code>方法，以及它们的<em>遇到错误提前返回</em>的版本： <code>try_map</code>，<code>try_filter</code>，<code>try_fold</code>。</p>
<p>但是跟迭代器又有所不同，<code>for</code> 循环无法在这里使用，但是命令式风格的循环<code>while let</code>是可以用的，同时还可以使用<code>next</code> 和 <code>try_next</code> 方法:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn sum_with_next(mut stream: Pin&lt;&amp;mut dyn Stream&lt;Item = i32&gt;&gt;) -&gt; i32 {
    use futures::stream::StreamExt; // 引入 next
    let mut sum = 0;
    while let Some(item) = stream.next().await {
        sum += item;
    }
    sum
}

async fn sum_with_try_next(
    mut stream: Pin&lt;&amp;mut dyn Stream&lt;Item = Result&lt;i32, io::Error&gt;&gt;&gt;,
) -&gt; Result&lt;i32, io::Error&gt; {
    use futures::stream::TryStreamExt; // 引入 try_next
    let mut sum = 0;
    while let Some(item) = stream.try_next().await? {
        sum += item;
    }
    Ok(sum)
}
<span class="boring">}
</span></code></pre></pre>
<p>上面代码是一次处理一个值的模式，但是需要注意的是：<strong>如果你选择一次处理一个值的模式，可能会造成无法并发，这就失去了异步编程的意义</strong>。 因此，如果可以的话我们还是要选择从一个 <code>Stream</code> 并发处理多个值的方式，通过 <code>for_each_concurrent</code> 或  <code>try_for_each_concurrent</code> 方法来实现:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn jump_around(
    mut stream: Pin&lt;&amp;mut dyn Stream&lt;Item = Result&lt;u8, io::Error&gt;&gt;&gt;,
) -&gt; Result&lt;(), io::Error&gt; {
    use futures::stream::TryStreamExt; // 引入 `try_for_each_concurrent`
    const MAX_CONCURRENT_JUMPERS: usize = 100;

    stream.try_for_each_concurrent(MAX_CONCURRENT_JUMPERS, |num| async move {
        jump_n_times(num).await?;
        report_n_jumps(num).await?;
        Ok(())
    }).await?;

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用join和select同时运行多个future"><a class="header" href="#使用join和select同时运行多个future">使用<code>join!</code>和<code>select!</code>同时运行多个Future</a></h1>
<p>招数单一，杀伤力惊人，说的就是 <code>.await</code> ，但是光用它，还真做不到一招鲜吃遍天。比如我们该如何同时运行多个任务，而不是使用<code>.await</code>慢悠悠地排队完成。</p>
<h2 id="join"><a class="header" href="#join">join!</a></h2>
<p><code>futures</code> 包中提供了很多实用的工具，其中一个就是 <code>join!</code>宏， 它允许我们同时等待多个不同 <code>Future</code> 的完成，且可以并发地运行这些 <code>Future</code>。</p>
<p>先来看一个不是很给力的、使用<code>.await</code>的版本:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn enjoy_book_and_music() -&gt; (Book, Music) {
    let book = enjoy_book().await;
    let music = enjoy_music().await;
    (book, music)
}
<span class="boring">}
</span></code></pre></pre>
<p>这段代码可以顺利运行，但是有一个很大的问题，就是必须先看完书后，才能听音乐。咱们以前，谁又不是那个摇头晃脑爱读书(耳朵里偷偷塞着耳机，听的正high)的好学生呢？</p>
<p>要支持同时看书和听歌，有些人可能会凭空生成下面代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WRONG -- 别这么做
async fn enjoy_book_and_music() -&gt; (Book, Music) {
    let book_future = enjoy_book();
    let music_future = enjoy_music();
    (book_future.await, music_future.await)
}
<span class="boring">}
</span></code></pre></pre>
<p>看上去像模像样，嗯，在某些语言中也许可以，但是 Rust 不行。因为在某些语言中，<code>Future</code>一旦创建就开始运行，等到返回的时候，基本就可以同时结束并返回了。 但是 Rust 中的 <code>Future</code> 是惰性的，直到调用 <code>.await</code> 时，才会开始运行。而那两个 <code>await</code> 由于在代码中有先后顺序，因此它们是连续运行的。</p>
<p>为了正确的并发两个 <code>Future</code> ， 我们来试试 <code>futures::join!</code> 宏:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::join;

async fn enjoy_book_and_music() -&gt; (Book, Music) {
    let book_fut = enjoy_book();
    let music_fut = enjoy_music();
    join!(book_fut, music_fut)
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Duang</code>，目标顺利达成。同时<code>join!</code>会返回一个元组，里面的值是对应的<code>Future</code>执行结束后输出的值。</p>
<h2 id="try_join"><a class="header" href="#try_join">try_join!</a></h2>
<p>由于<code>join!</code>必须等待它管理的所有 <code>Future</code> 完成后才能完成，如果你希望在某一个 <code>Future</code> 报错后就立即停止所有 <code>Future</code> 的执行，可以使用 <code>try_join!</code>，特别是当 <code>Future</code> 返回 <code>Result</code> 时:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::try_join;

async fn get_book() -&gt; Result&lt;Book, String&gt; { /* ... */ Ok(Book) }
async fn get_music() -&gt; Result&lt;Music, String&gt; { /* ... */ Ok(Music) }

async fn get_book_and_music() -&gt; Result&lt;(Book, Music), String&gt; {
    let book_fut = get_book();
    let music_fut = get_music();
    try_join!(book_fut, music_fut)
}
<span class="boring">}
</span></code></pre></pre>
<p>有一点需要注意，传给 <code>try_join!</code> 的所有 <code>Future</code> 都必须拥有相同的错误类型。如果错误类型不同，可以考虑使用来自 <code>futures::future::TryFutureExt</code> 模块的 <code>map_err</code>和<code>err_info</code>方法将错误进行转换:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::{
    future::TryFutureExt,
    try_join,
};

async fn get_book() -&gt; Result&lt;Book, ()&gt; { /* ... */ Ok(Book) }
async fn get_music() -&gt; Result&lt;Music, String&gt; { /* ... */ Ok(Music) }

async fn get_book_and_music() -&gt; Result&lt;(Book, Music), String&gt; {
    let book_fut = get_book().map_err(|()| &quot;Unable to get book&quot;.to_string());
    let music_fut = get_music();
    try_join!(book_fut, music_fut)
}
<span class="boring">}
</span></code></pre></pre>
<p><code>join!</code>很好很强大，但是人无完人，J无完J, 它有一个很大的问题。</p>
<h2 id="select"><a class="header" href="#select">select!</a></h2>
<p><code>join!</code>只有等所有 <code>Future</code> 结束后，才能集中处理结果，如果你想同时等待多个 <code>Future</code> ，且任何一个 <code>Future</code> 结束后，都可以立即被处理，可以考虑使用 <code>futures::select!</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::{
    future::FutureExt, // for `.fuse()`
    pin_mut,
    select,
};

async fn task_one() { /* ... */ }
async fn task_two() { /* ... */ }

async fn race_tasks() {
    let t1 = task_one().fuse();
    let t2 = task_two().fuse();

    pin_mut!(t1, t2);

    select! {
        () = t1 =&gt; println!(&quot;任务1率先完成&quot;),
        () = t2 =&gt; println!(&quot;任务2率先完成&quot;),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面的代码会同时并发地运行 <code>t1</code> 和 <code>t2</code>， 无论两者哪个先完成，都会调用对应的 <code>println!</code> 打印相应的输出，然后函数结束且不会等待另一个任务的完成。</p>
<p>但是，在实际项目中，我们往往需要等待多个任务都完成后，再结束，像上面这种其中一个任务结束就立刻结束的场景着实不多。 </p>
<h4 id="default-和-complete"><a class="header" href="#default-和-complete">default 和 complete</a></h4>
<p><code>select!</code>还支持 <code>default</code> 和 <code>complete</code> 分支:</p>
<ul>
<li><code>complete</code> 分支当所有的 <code>Future</code> 和 <code>Stream</code> 完成后才会被执行，它往往配合<code>loop</code>使用，<code>loop</code>用于循环完成所有的 <code>Future</code></li>
<li><code>default</code>分支，若没有任何 <code>Future</code> 或 <code>Stream</code> 处于 <code>Read</code> 状态， 则该分支会被立即执行</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">use futures::future;
use futures::select;
pub fn main() {
    let mut a_fut = future::ready(4);
    let mut b_fut = future::ready(6);
    let mut total = 0;
    
    loop {
        select! {
            a = a_fut =&gt; total += a,
            b = b_fut =&gt; total += b,
            complete =&gt; break,
            default =&gt; panic!(), // 该分支永远不会运行，因为`Future`会先运行，然后是`complete`
        };
    }
    assert_eq!(total, 10);
}
</code></pre></pre>
<p>以上代码 <code>default</code> 分支由于最后一个运行，而在它之前 <code>complete</code> 分支已经通过 <code>break</code> 跳出了循环，因此<code>default</code>永远不会被执行。</p>
<p>如果你希望 <code>default</code> 也有机会漏下脸，可以将 <code>complete</code> 的 <code>break</code> 修改为其它的，例如<code>println!(&quot;completed!&quot;)</code>，然后再观察下运行结果。</p>
<p>再回到 <code>select</code> 的第一个例子中，里面有一段代码长这样：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let t1 = task_one().fuse();
let t2 = task_two().fuse();

pin_mut!(t1, t2);
<span class="boring">}
</span></code></pre></pre>
<p>当时没有展开讲，相信大家也有疑惑，下面我们来一起看看。</p>
<h4 id="跟-unpin-和-fusedfuture-进行交互"><a class="header" href="#跟-unpin-和-fusedfuture-进行交互">跟 <code>Unpin</code> 和 <code>FusedFuture</code> 进行交互</a></h4>
<p>首先，<code>.fuse()</code>方法可以让 <code>Future</code> 实现 <code>FusedFuture</code> 特征， 而 <code>pin_mut!</code> 宏会为 <code>Future</code> 实现 <code>Unpin</code>特征，这两个特征恰恰是使用 <code>select</code> 所必须的:</p>
<ul>
<li><code>Unpin</code>，由于 <code>select</code> 不会通过拿走所有权的方式使用<code>Future</code>，而是通过可变引用的方式去使用，这样当 <code>select</code> 结束后，该 <code>Future</code> 若没有被完成，它的所有权还可以继续被其它代码使用。</li>
<li><code>FusedFuture</code>的原因跟上面类似，当 <code>Future</code> 一旦完成后，那 <code>select</code> 就不能再对其进行轮询使用。<code>Fuse</code>意味着融化的意思，相当于 <code>Future</code> 一旦完成，就融化了，无法再被使用。</li>
</ul>
<p>只有实现了<code>FusedFuture</code>，<code>select</code> 才能配合 <code>loop</code> 一起使用。假如没有实现，就算一个 <code>Future</code> 已经完成了，它依然会被 <code>select</code> 不停的轮询执行。</p>
<p><code>Stream</code> 稍有不同，它们使用的特征是 <code>FusedStream</code>。 通过<code>.fuse()</code>(也可以手动实现)实现了该特征的 <code>Stream</code>，对其调用<code>.next()</code> 或 <code>.try_next()</code>方法可以获取实现了<code>FusedFuture</code>特征的<code>Future</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::{
    stream::{Stream, StreamExt, FusedStream},
    select,
};

async fn add_two_streams(
    mut s1: impl Stream&lt;Item = u8&gt; + FusedStream + Unpin,
    mut s2: impl Stream&lt;Item = u8&gt; + FusedStream + Unpin,
) -&gt; u8 {
    let mut total = 0;

    loop {
        let item = select! {
            x = s1.next() =&gt; x,
            x = s2.next() =&gt; x,
            complete =&gt; break,
        };
        if let Some(next_num) = item {
            total += next_num;
        }
    }

    total
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="在select循环中并发"><a class="header" href="#在select循环中并发">在select循环中并发</a></h2>
<p>一个很实用但又鲜为人知的函数是 <code>Fuse::terminated()</code> ，可以使用它构建一个空的 <code>Future</code> ，空自然没啥用，但是如果它能在后面再被填充呢？</p>
<p>考虑以下场景：当你要在<code>select</code>循环中运行一个任务，但是该任务却是在<code>select</code>循环内部创建时，上面的函数就非常好用了。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::{
    future::{Fuse, FusedFuture, FutureExt},
    stream::{FusedStream, Stream, StreamExt},
    pin_mut,
    select,
};

async fn get_new_num() -&gt; u8 { /* ... */ 5 }

async fn run_on_new_num(_: u8) { /* ... */ }

async fn run_loop(
    mut interval_timer: impl Stream&lt;Item = ()&gt; + FusedStream + Unpin,
    starting_num: u8,
) {
    let run_on_new_num_fut = run_on_new_num(starting_num).fuse();
    let get_new_num_fut = Fuse::terminated();
    pin_mut!(run_on_new_num_fut, get_new_num_fut);
    loop {
        select! {
            () = interval_timer.select_next_some() =&gt; {
                // 定时器已结束，若`get_new_num_fut`没有在运行，就创建一个新的
                if get_new_num_fut.is_terminated() {
                    get_new_num_fut.set(get_new_num().fuse());
                }
            },
            new_num = get_new_num_fut =&gt; {
                // 收到新的数字 -- 创建一个新的`run_on_new_num_fut`并丢弃掉旧的
                run_on_new_num_fut.set(run_on_new_num(new_num).fuse());
            },
            // 运行 `run_on_new_num_fut`
            () = run_on_new_num_fut =&gt; {},
            // 若所有任务都完成，直接 `panic`， 原因是 `interval_timer` 应该连续不断的产生值，而不是结束
            //后，执行到 `complete` 分支
            complete =&gt; panic!(&quot;`interval_timer` completed unexpectedly&quot;),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>当某个 <code>Future</code> 有多个拷贝都需要同时运行时，可以使用 <code>FuturesUnordered</code> 类型。下面的例子跟上个例子大体相似，但是它会将 <code>run_on_new_num_fut</code> 的每一个拷贝都运行到完成，而不是像之前那样一旦创建新的就终止旧的。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::{
    future::{Fuse, FusedFuture, FutureExt},
    stream::{FusedStream, FuturesUnordered, Stream, StreamExt},
    pin_mut,
    select,
};

async fn get_new_num() -&gt; u8 { /* ... */ 5 }

async fn run_on_new_num(_: u8) -&gt; u8 { /* ... */ 5 }


// 使用从 `get_new_num` 获取的最新数字 来运行 `run_on_new_num`
//
// 每当计时器结束后，`get_new_num` 就会运行一次，它会立即取消当前正在运行的`run_on_new_num` ,
// 并且使用新返回的值来替换 
async fn run_loop(
    mut interval_timer: impl Stream&lt;Item = ()&gt; + FusedStream + Unpin,
    starting_num: u8,
) {
    let mut run_on_new_num_futs = FuturesUnordered::new();
    run_on_new_num_futs.push(run_on_new_num(starting_num));
    let get_new_num_fut = Fuse::terminated();
    pin_mut!(get_new_num_fut);
    loop {
        select! {
            () = interval_timer.select_next_some() =&gt; {
                 // 定时器已结束，若`get_new_num_fut`没有在运行，就创建一个新的
                if get_new_num_fut.is_terminated() {
                    get_new_num_fut.set(get_new_num().fuse());
                }
            },
            new_num = get_new_num_fut =&gt; {
                 // 收到新的数字 -- 创建一个新的`run_on_new_num_fut` (并没有像之前的例子那样丢弃掉旧值)
                run_on_new_num_futs.push(run_on_new_num(new_num));
            },
            // 运行 `run_on_new_num_futs`, 并检查是否有已经完成的
            res = run_on_new_num_futs.select_next_some() =&gt; {
                println!(&quot;run_on_new_num_fut returned {:?}&quot;, res);
            },
            // 若所有任务都完成，直接 `panic`， 原因是 `interval_timer` 应该连续不断的产生值，而不是结束
            //后，执行到 `complete` 分支
            complete =&gt; panic!(&quot;`interval_timer` completed unexpectedly&quot;),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一些疑难问题的解决办法"><a class="header" href="#一些疑难问题的解决办法">一些疑难问题的解决办法</a></h1>
<p><code>async</code> 在 Rust 依然比较新，疑难杂症少不了，而它们往往还处于活跃开发状态，短时间内无法被解决，因此才有了本文。下面一起来看看这些问题以及相应的临时解决方案。</p>
<h2 id="在-async-语句块中使用-"><a class="header" href="#在-async-语句块中使用-">在 async 语句块中使用 ?</a></h2>
<p><code>async</code> 语句块和 <code>async fn</code> 最大的区别就是前者无法显式的声明返回值，在大多数时候这都不是问题，但是当配合 <code>?</code> 一起使用时，问题就有所不同:</p>
<pre><pre class="playground"><code class="language-rust edition2021">async fn foo() -&gt; Result&lt;u8, String&gt; {
    Ok(1)
}
async fn bar() -&gt; Result&lt;u8, String&gt; {
    Ok(1)
}
pub fn main() {
    let fut = async {
        foo().await?;
        bar().await?;
        Ok(())
    };
}
</code></pre></pre>
<p>以上代码编译后会报错:</p>
<pre><code class="language-shell">error[E0282]: type annotations needed
  --&gt; src/main.rs:14:9
   |
11 |     let fut = async {
   |         --- consider giving `fut` a type
...
14 |         Ok(1)
   |         ^^ cannot infer type for type parameter `E` declared on the enum `Result`
</code></pre>
<p>原因在于编译器无法推断出 <code>Result&lt;T, E&gt;</code>中的 <code>E</code> 的类型， 而且编译器的提示<code>consider giving fut a type</code>你也别傻乎乎的相信，然后尝试半天，最后无奈放弃：目前还没有办法为 <code>async</code> 语句块指定返回类型。</p>
<p>既然编译器无法推断出类型，那咱就给它更多提示，可以使用 <code>::&lt; ... &gt;</code> 的方式来增加类型注释：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fut = async {
    foo().await?;
    bar().await?;
    Ok::&lt;(), String&gt;(()) // 在这一行进行显式的类型注释
};
<span class="boring">}
</span></code></pre></pre>
<p>给予类型注释后此时编译器就知道<code>Result&lt;T, E&gt;</code>中的 <code>E</code> 的类型是<code>String</code>，进而成功通过编译。</p>
<h2 id="async-函数和-send-特征"><a class="header" href="#async-函数和-send-特征">async 函数和 Send 特征</a></h2>
<p>在多线程章节我们深入讲过 <code>Send</code> 特征对于多线程间数据传递的重要性，对于 <code>async fn</code> 也是如此，它返回的 <code>Future</code> 能否在线程间传递的关键在于 <code>.await</code> 运行过程中，作用域中的变量类型是否是 <code>Send</code>。</p>
<p>学到这里，相信大家已经很清楚<code>Rc</code>无法在多线程环境使用，原因就在于它并未实现 <code>Send</code> 特征，那咱就用它来做例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

#[derive(Default)]
struct NotSend(Rc&lt;()&gt;);
<span class="boring">}
</span></code></pre></pre>
<p>事实上，未实现 <code>Send</code> 特征的变量可以出现在 <code>async fn</code> 语句块中:</p>
<pre><pre class="playground"><code class="language-rust edition2021">async fn bar() {}
async fn foo() {
    NotSend::default();
    bar().await;
}

fn require_send(_: impl Send) {}

fn main() {
    require_send(foo());
}
</code></pre></pre>
<p>即使上面的 <code>foo</code> 返回的 <code>Future</code> 是 <code>Send</code>， 但是在它内部短暂的使用 <code>NotSend</code> 依然是安全的，原因在于它的作用域并没有影响到 <code>.await</code>，下面来试试声明一个变量，然后让 <code>.await</code>的调用处于变量的作用域中试试:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo() {
    let x = NotSend::default();
    bar().await;
}
<span class="boring">}
</span></code></pre></pre>
<p>不出所料，错误如期而至:</p>
<pre><code class="language-shell">error: future cannot be sent between threads safely
  --&gt; src/main.rs:17:18
   |
17 |     require_send(foo());
   |                  ^^^^^ future returned by `foo` is not `Send`
   |
   = help: within `impl futures::Future&lt;Output = ()&gt;`, the trait `std::marker::Send` is not implemented for `Rc&lt;()&gt;`
note: future is not `Send` as this value is used across an await
  --&gt; src/main.rs:11:5
   |
10 |     let x = NotSend::default();
   |         - has type `NotSend` which is not `Send`
11 |     bar().await;
   |     ^^^^^^^^^^^ await occurs here, with `x` maybe used later
12 | }
   | - `x` is later dropped here
</code></pre>
<p>提示很清晰，<code>.await</code>在运行时处于 <code>x</code> 的作用域内。在之前章节有提到过， <code>.await</code> 有可能被执行器调度到另一个线程上运行，而 <code>Rc</code> 并没有实现 <code>Send</code>，因此编译器无情拒绝了咱们。</p>
<p>其中一个可能的解决方法是在 <code>.await</code> 之前就使用 <code>std::mem::drop</code> 释放掉 <code>Rc</code>，但是很可惜，截止今天，该方法依然不能解决这种问题。</p>
<p>不知道有多少同学还记得语句块 <code>{ ... }</code> 在 Rust 中其实具有非常重要的作用(特别是相比其它大多数语言来说时)：可以将变量声明在语句块内，当语句块结束时，变量会自动被 <code>drop</code>，这个规则可以帮助我们解决很多借用冲突问题，特别是在 <code>NLL</code> 出来之前。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo() {
    {
        let x = NotSend::default();
    }
    bar().await;
}
<span class="boring">}
</span></code></pre></pre>
<p>是不是很简单？最终我们还是通过 <code>Drop</code> 的方式解决了这个问题，当然，还是期待未来 <code>std::mem::drop</code> 也能派上用场。</p>
<h2 id="递归使用async-fn"><a class="header" href="#递归使用async-fn">递归使用async fn</a></h2>
<p>在内部实现中，<code>async fn</code>被编译成一个状态机，这会导致递归使用 <code>async fn</code> 变得较为复杂， 因为编译后的状态机还需要包含自身。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// foo函数:
async fn foo() {
    step_one().await;
    step_two().await;
}
// 会被编译成类似下面的类型：
enum Foo {
    First(StepOne),
    Second(StepTwo),
}

// 因此recursive函数
async fn recursive() {
    recursive().await;
    recursive().await;
}

// 会生成类似以下的类型
enum Recursive {
    First(Recursive),
    Second(Recursive),
}
<span class="boring">}
</span></code></pre></pre>
<p>这是典型的<a href="async/../advance/custom-type.html#%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B">动态大小类型</a>，它的大小会无限增长，因此编译器会直接报错:</p>
<pre><code class="language-shell">error[E0733]: recursion in an `async fn` requires boxing
 --&gt; src/lib.rs:1:22
  |
1 | async fn recursive() {
  |                      ^ an `async fn` cannot invoke itself directly
  |
  = note: a recursive `async fn` must be rewritten to return a boxed future.
</code></pre>
<p>如果认真学过之前的章节，大家应该知道只要将其使用 <code>Box</code> 放到堆上而不是栈上，就可以解决，在这里还是要称赞下 Rust 的编译器，给出的提示总是这么精确<code>recursion in an async fn requires boxing</code>。</p>
<p>就算是使用 <code>Box</code>，这里也大有讲究。如果我们试图使用 <code>Box::pin</code> 这种方式去包裹是不行的，因为编译器自身的限制限制了我们(刚夸过它。。。)。为了解决这种问题，我们只能将 <code>recursive</code> 转变成一个正常的函数，该函数返回一个使用 <code>Box</code> 包裹的 <code>async</code> 语句块：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::future::{BoxFuture, FutureExt};

fn recursive() -&gt; BoxFuture&lt;'static, ()&gt; {
    async move {
        recursive().await;
        recursive().await;
    }.boxed()
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="在特征中使用-async"><a class="header" href="#在特征中使用-async">在特征中使用 async</a></h2>
<p>在目前版本中，我们还无法在特征中定义 <code>async fn</code> 函数，不过大家也不用担心，目前已经有计划在未来移除这个限制了。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Test {
    async fn test();
}
<span class="boring">}
</span></code></pre></pre>
<p>运行后报错:</p>
<pre><code class="language-shell">error[E0706]: functions in traits cannot be declared `async`
 --&gt; src/main.rs:5:5
  |
5 |     async fn test();
  |     -----^^^^^^^^^^^
  |     |
  |     `async` because of this
  |
  = note: `async` trait functions are not currently supported
  = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait
</code></pre>
<p>好在编译器给出了提示，让我们使用 <a href="https://github.com/dtolnay/async-trait"><code>async-trait</code></a> 解决这个问题:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_trait::async_trait;

#[async_trait]
trait Advertisement {
    async fn run(&amp;self);
}

struct Modal;

#[async_trait]
impl Advertisement for Modal {
    async fn run(&amp;self) {
        self.render_fullscreen().await;
        for _ in 0..4u16 {
            remind_user_to_join_mailing_list().await;
        }
        self.hide_for_now().await;
    }
}

struct AutoplayingVideo {
    media_url: String,
}

#[async_trait]
impl Advertisement for AutoplayingVideo {
    async fn run(&amp;self) {
        let stream = connect(&amp;self.media_url).await;
        stream.play().await;

        // 用视频说服用户加入我们的邮件列表
        Modal.run().await;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>不过使用该包并不是免费的，每一次特征中的<code>async</code>函数被调用时，都会产生一次堆内存分配。对于大多数场景，这个性能开销都可以接受，但是当函数一秒调用几十万、几百万次时，就得小心这块儿代码的性能了！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一个实践项目-web服务器"><a class="header" href="#一个实践项目-web服务器">一个实践项目: Web服务器</a></h1>
<p>知识学得再多，不实际应用也是纸上谈兵，不是忘掉就是废掉，对于技术学习尤为如此。在之前章节中，我们已经学习了 <code>Async Rust</code> 的方方面面，现在来将这些知识融会贯通，最终实现一个并发Web服务器。</p>
<h2 id="多线程版本的web服务器"><a class="header" href="#多线程版本的web服务器">多线程版本的Web服务器</a></h2>
<p>在正式开始前，先来看一个单线程版本的 <code>Web</code> 服务器，该例子来源于 <a href="https://doc.rust-lang.org/book/ch20-01-single-threaded.html"><code>Rust Book</code></a> 一书。</p>
<p><code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    // 监听本地端口 7878 ，等待 TCP 连接的建立
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    // 阻塞等待请求的进入
    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    // 从连接中顺序读取 1024 字节数据
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;


    // 处理HTTP协议头，若不符合则返回404和对应的`html`文件
    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };
    let contents = fs::read_to_string(filename).unwrap();

    // 将回复内容写入连接缓存中
    let response = format!(&quot;{status_line}{contents}&quot;);
    stream.write_all(response.as_bytes()).unwrap();
    // 使用flush将缓存中的内容发送到客户端
    stream.flush().unwrap();
}
</code></pre></pre>
<p><code>hello.html</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
<span class="boring">}
</span></code></pre></pre>
<p><code>404.html</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
<span class="boring">}
</span></code></pre></pre>
<p>运行以上代码，并从浏览器访问 <code>127.0.0.1:7878</code> 你将看到一条来自 <code>Ferris</code> 的问候。</p>
<p>在回忆了单线程版本该如何实现后，我们也将进入正题，一起来实现一个基于 <code>ascyn</code> 的异步Web服务器。</p>
<h2 id="运行异步代码"><a class="header" href="#运行异步代码">运行异步代码</a></h2>
<p>一个 Web 服务器必须要能并发的处理大量来自用户的请求，也就是我们不能在处理上一个用户的请求后，再处理下一个用户的请求。上面的单线程版本可以修改为多线程甚至于线程池来实现并发处理，但是线程还是太重了，使用 <code>async</code> 实现 <code>Web</code> 服务器才是最适合的。</p>
<p>首先将 <code>handle_connection</code> 修改为 <code>async</code> 实现:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle_connection(mut stream: TcpStream) {
    //&lt;-- snip --&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>该修改会将函数的返回值从 <code>()</code> 变成 <code>Future&lt;Output=()&gt;</code> ，因此直接运行将不再有任何效果，只用通过<code>.await</code>或执行器的<code>poll</code>调用后才能获取 <code>Future</code> 的结果。</p>
<p>在之前的代码中，我们使用了自己实现的简单的执行器来进行<code>.await</code> 或 <code>poll</code> ，实际上这只是为了学习原理，<strong>在实际项目中，需要选择一个三方的 <code>async</code> 运行时来实现相关的功能</strong>。 具体的选择我们将在下一章节进行讲解，现在先选择 <code>async-std</code> ，该包的最大优点就是跟标准库的 API 类似，相对来说更简单易用。</p>
<h4 id="使用-async-std-作为异步运行时"><a class="header" href="#使用-async-std-作为异步运行时">使用 async-std 作为异步运行时</a></h4>
<p>下面的例子将演示如何使用一个异步运行时<code>async-std</code>来让之前的 <code>async fn</code> 函数运行起来，该运行时允许使用属性 <code>#[async_std::main]</code> 将我们的 <code>fn main</code> 函数变成 <code>async fn main</code> ，这样就可以在 <code>main</code> 函数中直接调用其它 <code>async</code> 函数，否则你得用之前章节的 <code>block_on</code> 方法来让 <code>main</code> 去阻塞等待异步函数的完成，但是这种简单粗暴的阻塞等待方式并不灵活。 </p>
<p>修改 <code>Cargo.toml</code> 添加 <code>async-std</code> 包并开启相应的属性:</p>
<pre><code class="language-toml">[dependencies]
futures = &quot;0.3&quot;

[dependencies.async-std]
version = &quot;1.6&quot;
features = [&quot;attributes&quot;]
</code></pre>
<p>下面将 <code>main</code> 函数修改为异步的，并在其中调用前面修改的异步版本 <code>handle_connection</code> : </p>
<pre><pre class="playground"><code class="language-rust edition2021">#[async_std::main]
async fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    for stream in listener.incoming() {
        let stream = stream.unwrap();
        // 警告，这里无法并发
        handle_connection(stream).await;
    }
}
</code></pre></pre>
<p><strong>上面的代码虽然已经是异步的，实际上它还无法并发</strong>，原因我们后面会解释，先来模拟一下慢请求:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_std::task;

async fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        task::sleep(Duration::from_secs(5)).await;
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };
    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(&quot;{status_line}{contents}&quot;);
    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>上面是全新实现的 <code>handle_connection</code> ，它会在内部睡眠5秒，模拟一次用户慢请求，需要注意的是，我们并没有使用 <code>std::thread::sleep</code> 进行睡眠， 原因是该函数并不适用于并发代码，它会让当前线程陷入睡眠中，导致其它任务无法继续运行！因此我们需要一个睡眠函数 <code>async_std::task::sleep</code>，它仅会让当前的任务陷入睡眠，然后该任务会让出线程的控制权，这样线程就可以继续运行其它任务。</p>
<p>因此，光把函数变成 <code>async</code> 往往是不够的，还需要将它内部的代码也都变成异步兼容的，阻塞线程绝对是不可行的。</p>
<p>现在运行服务器，并访问 <code>127.0.0.1:7878/sleep</code>， 你会发现只有在完成第一个用户请求(5秒后)，才能开始处理第二个用户请求。现在再来看看该如何解决这个问题，让请求并发起来。</p>
<h2 id="并发地处理连接"><a class="header" href="#并发地处理连接">并发地处理连接</a></h2>
<p>上面代码最大的问题是 <code>listener.incoming()</code> 是阻塞的迭代器。当 <code>listener</code> 在等待连接时，执行器是无法执行其它<code>Future</code>的，而且只有在我们处理完已有的连接后，才能接收新的连接。</p>
<p>解决方法是将 <code>listener.incoming()</code> 从一个阻塞的迭代器变成一个非阻塞的 <code>Stream</code>， 后者在前面章节有过专门介绍：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use async_std::net::TcpListener;
use async_std::net::TcpStream;
use futures::stream::StreamExt;

#[async_std::main]
async fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).await.unwrap();
    listener
        .incoming()
        .for_each_concurrent(/* limit */ None, |tcpstream| async move {
            let tcpstream = tcpstream.unwrap();
            handle_connection(tcpstream).await;
        })
        .await;
}
</code></pre></pre>
<p>异步版本的 <code>TcpListener</code> 为 <code>listener.incoming()</code> 实现了 <code>Stream</code> 特征，以上修改有两个好处:</p>
<ul>
<li><code>listener.incoming()</code> 不再阻塞</li>
<li>使用 <code>for_each_concurrent</code> 并发地处理从 <code>Stream</code> 获取的元素</li>
</ul>
<p>现在上面的实现的关键在于 <code>handle_connection</code> 不能再阻塞:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_std::prelude::*;

async fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).await.unwrap();

    //&lt;-- snip --&gt;
    stream.write(response.as_bytes()).await.unwrap();
    stream.flush().await.unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>在将数据读写改造成异步后，现在该函数也彻底变成了异步的版本，因此一次慢请求不再会阻止其它请求的运行。</p>
<h2 id="使用多线程并行处理请求"><a class="header" href="#使用多线程并行处理请求">使用多线程并行处理请求</a></h2>
<p>聪明的读者不知道有没有发现，之前的例子有一个致命的缺陷：只能使用一个线程并发的处理用户请求。是的，这样也可以实现并发，一秒处理几千次请求问题不大，但是这毕竟没有利用上 CPU 的多核并行能力，无法实现性能最大化。</p>
<p><code>async</code> 并发和多线程其实并不冲突，而 <code>async-std</code> 包也允许我们使用多个线程去处理，由于 <code>handle_connection</code> 实现了 <code>Send</code> 特征且不会阻塞，因此使用 <code>async_std::task::spawn</code> 是非常安全的:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use async_std::task::spawn;

#[async_std::main]
async fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).await.unwrap();
    listener
        .incoming()
        .for_each_concurrent(/* limit */ None, |stream| async move {
            let stream = stream.unwrap();
            spawn(handle_connection(stream));
        })
        .await;
}
</code></pre></pre>
<p>至此，我们实现了同时使用并行(多线程)和并发( <code>async</code> )来同时处理多个请求！</p>
<h2 id="测试-handle_connection-函数"><a class="header" href="#测试-handle_connection-函数">测试 handle_connection 函数</a></h2>
<p>对于测试 Web 服务器，使用集成测试往往是最简单的，但是在本例子中，将使用单元测试来测试连接处理函数的正确性。</p>
<p>为了保证单元测试的隔离性和确定性，我们使用 <code>Mock</code> 来替代 <code>TcpStream</code> 。首先，修改 <code>handle_connection</code> 的函数签名让测试更简单，之所以可以修改签名，原因在于 <code>async_std::net::TcpStream</code> 实际上并不是必须的，只要任何结构体实现了 <code>async_std::io::Read</code>, <code>async_std::io::Write</code> 和 <code>marker::Unpin</code> 就可以替代它：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::Unpin;
use async_std::io::{Read, Write};

async fn handle_connection(mut stream: impl Read + Write + Unpin) {
<span class="boring">}
</span></code></pre></pre>
<p>下面，来构建一个mock的 <code>TcpStream</code> 并实现了上面这些特征，它包含一些数据，这些数据将被拷贝到 <code>read</code> 缓存中, 然后返回 <code>Poll::Ready</code> 说明 <code>read</code> 已经结束：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::*;
use futures::io::Error;
use futures::task::{Context, Poll};

use std::cmp::min;
use std::pin::Pin;

struct MockTcpStream {
    read_data: Vec&lt;u8&gt;,
    write_data: Vec&lt;u8&gt;,
}

impl Read for MockTcpStream {
    fn poll_read(
        self: Pin&lt;&amp;mut Self&gt;,
        _: &amp;mut Context,
        buf: &amp;mut [u8],
    ) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt; {
        let size: usize = min(self.read_data.len(), buf.len());
        buf[..size].copy_from_slice(&amp;self.read_data[..size]);
        Poll::Ready(Ok(size))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Write</code>的实现也类似，需要实现三个方法 : <code>poll_write</code>, <code>poll_flush</code>, and <code>poll_close</code>。 <code>poll_write</code> 会拷贝输入数据到mock的 <code>TcpStream</code> 中，当完成后返回 <code>Poll::Ready</code>。由于 <code>TcpStream</code> 无需 <code>flush</code> 和 <code>close</code>，因此另两个方法直接返回 <code>Poll::Ready</code> 即可.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Write for MockTcpStream {
    fn poll_write(
        mut self: Pin&lt;&amp;mut Self&gt;,
        _: &amp;mut Context,
        buf: &amp;[u8],
    ) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt; {
        self.write_data = Vec::from(buf);

        Poll::Ready(Ok(buf.len()))
    }

    fn poll_flush(self: Pin&lt;&amp;mut Self&gt;, _: &amp;mut Context) -&gt; Poll&lt;Result&lt;(), Error&gt;&gt; {
        Poll::Ready(Ok(()))
    }

    fn poll_close(self: Pin&lt;&amp;mut Self&gt;, _: &amp;mut Context) -&gt; Poll&lt;Result&lt;(), Error&gt;&gt; {
        Poll::Ready(Ok(()))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>最后，我们的mock需要实现 <code>Unpin</code> 特征，表示它可以在内存中安全的移动，具体内容在<a href="async/./pin-unpin.html">前面章节</a>有讲。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::Unpin;
impl Unpin for MockTcpStream {}
<span class="boring">}
</span></code></pre></pre>
<p>现在可以准备开始测试了，在使用初始化数据设置好 <code>MockTcpStream</code> 后，我们可以使用 <code>#[async_std::test]</code> 来运行 <code>handle_connection</code> 函数，该函数跟 <code>#[async_std::main]</code> 的作用类似。为了确保 <code>handle_connection</code> 函数正确工作，需要根据初始化数据检查正确的数据被写入到 <code>MockTcpStream</code> 中。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;

#[async_std::test]
async fn test_handle_connection() {
    let input_bytes = b&quot;GET / HTTP/1.1\r\n&quot;;
    let mut contents = vec![0u8; 1024];
    contents[..input_bytes.len()].clone_from_slice(input_bytes);
    let mut stream = MockTcpStream {
        read_data: contents,
        write_data: Vec::new(),
    };

    handle_connection(&amp;mut stream).await;
    let mut buf = [0u8; 1024];
    stream.read(&amp;mut buf).await.unwrap();

    let expected_contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
    let expected_response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, expected_contents);
    assert!(stream.write_data.starts_with(expected_response.as_bytes()));
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokio使用指南"><a class="header" href="#tokio使用指南">Tokio使用指南</a></h1>
<p>在上一个章节中，我们提到了 Rust 异步编程的限制，其中之一就是你必须引入社区提供的异步运行时，其中最有名的就是 <code>tokio</code>。</p>
<p>在本章中，我们一起来看看 <code>tokio</code> 到底有什么优势，以及该如何使用它。</p>
<blockquote>
<p>本章在内容上大量借鉴和翻译了tokio官方文档<a href="https://tokio.rs/tokio/tutorial">Tokio Tutorial</a>, 但是重新组织了内容形式并融入了很多自己的见解和感悟，给大家提供更好的可读性和知识扩展性</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokio概览"><a class="header" href="#tokio概览">tokio概览</a></h1>
<p>对于 Async Rust，最最重要的莫过于底层的异步运行时，它提供了执行器、任务调度、异步API等核心服务。简单来说，使用 Rust 提供的 <code>async/.await</code> 特性编写的异步代码要运行起来，就必须依赖于异步运行时，否则这些代码将毫无用处。</p>
<h2 id="异步运行时"><a class="header" href="#异步运行时">异步运行时</a></h2>
<p>Rust 语言本身只提供了异步编程所需的基本特性，例如 <code>async/.await</code> 关键字，标准库中的 <code>Future</code> 特征，官方提供的 <code>futures</code> 实用库，这些特性单独使用没有任何用处，因此我们需要一个运行时来将这些特性实现的代码运行起来。</p>
<p>异步运行时是由 Rust 社区提供的，它们的核心是一个 <code>reactor</code> 和一个或多个 <code>executor</code>(执行器):</p>
<ul>
<li><code>reactor</code> 用于提供外部事件的订阅机制，例如 <code>I/O</code> 、进程间通信、定时器等</li>
<li><code>executor</code> 在上一章我们有过深入介绍，它用于调度和执行相应的任务( <code>Future</code> )</li>
</ul>
<p>目前最受欢迎的几个运行时有:</p>
<ul>
<li><a href="https://github.com/tokio-rs/tokio"><code>tokio</code></a>，目前最受欢迎的异步运行时，功能强大，还提供了异步所需的各种工具(例如 tracing )、网络协议框架(例如 HTTP，gRPC )等等</li>
<li><a href="https://github.com/async-rs/async-std"><code>async-std</code></a>，最大的优点就是跟标准库兼容性较强</li>
<li><a href="https://github.com/smol-rs/smol"><code>smol</code></a>, 一个小巧的异步运行时</li>
</ul>
<p>但是，大浪淘沙，留下的才是金子，随着时间的流逝，<code>tokio</code>越来越亮眼，无论是性能、功能还是社区、文档，它在各个方面都异常优秀，时至今日，可以说已成为事实上的标准。</p>
<h4 id="异步运行时的兼容性"><a class="header" href="#异步运行时的兼容性">异步运行时的兼容性</a></h4>
<p>为何选择异步运行时这么重要？不仅仅是它们在功能、性能上存在区别，更重要的是当你选择了一个，往往就无法切换到另外一个，除非异步代码很少。</p>
<p>使用异步运行时，往往伴随着对它相关的生态系统的深入使用，因此耦合性会越来越强，直至最后你很难切换到另一个运行时，例如 <code>tokio</code> 和 <code>async-std</code> ，就存在这种问题。</p>
<p>如果你实在有这种需求，可以考虑使用 <a href="https://github.com/smol-rs/async-compat"><code>async-compat</code></a>，该包提供了一个中间层，用于兼容 <code>tokio</code> 和其它运行时。</p>
<h4 id="结论"><a class="header" href="#结论">结论</a></h4>
<p>相信大家看到现在，心中应该有一个结论了。首先，运行时之间的不兼容性，让我们必须提前选择一个运行时，并且在未来坚持用下去，那这个运行时就应该是最优秀、最成熟的那个，<code>tokio</code> 几乎成了不二选择，当然 <code>tokio</code> 也有自己的问题：更难上手和运行时之间的兼容性。</p>
<p>如果你只用 <code>tokio</code> ，那兼容性自然不是问题，至于难以上手，Rust 这么难，我们都学到现在了，何况区区一个异步运行时，在本书的帮忙下，这些都不再是个问题：）</p>
<h2 id="tokio简介"><a class="header" href="#tokio简介">tokio简介</a></h2>
<p>Tokio是一个纸醉金迷之地，只要有钱就可以为所欲为，哦，抱歉，走错片场了。<code>Tokio</code> 是 Rust 最优秀的异步运行时框架，它提供了写异步网络服务所需的几乎所有功能，不仅仅适用于大型服务器，还适用于小型嵌入式设备，它主要由以下组件构成：</p>
<ul>
<li>多线程版本的异步运行时，可以运行使用 <code>async/.await</code> 编写的代码</li>
<li>标准库中阻塞API的异步版本，例如<code>thread::sleep</code>会阻塞当前线程，<code>tokio</code>中就提供了相应的异步实现版本</li>
<li>构建异步编程所需的生态，甚至还提供了 <a href="https://github.com/tokio-rs/tracing"><code>tracing</code></a> 用于日志和分布式追踪， 提供 <a href="https://github.com/tokio-rs/console"><code>console</code></a> 用于 Debug 异步编程</li>
</ul>
<h3 id="优势"><a class="header" href="#优势">优势</a></h3>
<p>下面一起来看看使用 <code>tokio</code> 能给你提供哪些优势。</p>
<p><strong>高性能</strong></p>
<p>因为快所以快，前者是 Rust 快，后者是 <code>tokio</code> 快。 <code>tokio</code> 在编写时充分利用了 Rust 提供的各种零抽象和高性能特性，而且贯彻了 Rust 的牛逼思想：如果你选择手写代码，那么最好的结果就是跟 <code>tokio</code> 一样快！</p>
<p>以下是一张官方提供的性能参考图，大致能体现出 <code>tokio</code> 的性能之恐怖:
<img alt="tokio performance" src="tokio//img/tokio-01.png" class="center"  /></p>
<p><strong>高可靠</strong></p>
<p>Rust 语言的安全可靠性顺理成章的影响了 <code>tokio</code> 的可靠性，曾经有一个调查给出了令人乍舌的<a href="https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/">结论</a>：软件系统70%的高危漏洞都是由内存不安全性导致的。</p>
<p>在 Rust 提供的安全性之外，<code>tokio</code> 还致力于提供一致性的行为表现：无论你何时运行系统，它的预期表现和性能都是一致的，例如不会出现莫名其妙的请求延迟或响应时间大幅增加。</p>
<p><strong>简单易用</strong></p>
<p>通过 Rust 提供的 <code>async/await</code> 特性，编写异步程序的复杂性相比当初已经大幅降低，同时 <code>tokio</code> 还为我们提供了丰富的生态，进一步大幅降低了其复杂性。</p>
<p>同时 <code>tokio</code> 遵循了标准库的命名规则，让熟悉标准库的用户可以很快习惯于 <code>tokio</code> 的语法，再借助于 Rust 强大的类型系统，用户可以轻松地编写和交付正确的代码。</p>
<p><strong>使用灵活性</strong>
<code>tokio</code> 支持你灵活的定制自己想要的运行时，例如你可以选择多线程 + 任务盗取模式的复杂运行时，也可以选择单线程的轻量级运行时。总之，几乎你的每一种需求在 <code>tokio</code> 中都能寻找到支持(画外音：强大的灵活性需要一定的复杂性来换取，并不是免费的午餐)。</p>
<h3 id="劣势"><a class="header" href="#劣势">劣势</a></h3>
<p>虽然 <code>tokio</code> 对于大多数需要并发的项目都是非常适合的，但是确实有一些场景它并不适合使用:</p>
<ul>
<li>并行运行CPU密集型的任务，<code>tokio</code> 非常适合于IO密集型任务，这些IO任务的绝大多数时间都用于阻塞等待IO的结果，而不是刷刷刷的单烤CPU。如果你的应用是CPU密集型(例如并行计算)，建议使用 <a href="https://github.com/rayon-rs/rayon"><code>rayon</code></a>，当然，对于其中的IO任务部分，你依然可以混用 <code>tokio</code></li>
<li>读取大量的文件, 读取文件的瓶颈主要在于操作系统，因为OS没有提供异步文件读取接口，大量的并发并不会提升文件读取的并行性能，反而可能会造成不可忽视的性能损耗，因此建议使用线程(或线程池)的方式</li>
<li>发送HTTP请求，<code>tokio</code> 的优势是给予你并发处理大量任务的能力，对于这种轻量级 HTTP 请求场景，<code>tokio</code> 除了增加你的代码复杂性，并无法带来什么额外的优势。因此，对于这种场景，你可以使用 <a href="https://github.com/seanmonstar/reqwest"><code>reqwest</code></a> 库，它会更加简单易用。</li>
</ul>
<h2 id="总结-19"><a class="header" href="#总结-19">总结</a></h2>
<p>离开三方开源社区提供的异步运行时， <code>async/await</code> 什么都不是，甚至还不如一堆破铜烂铁，除非你选择根据自己的需求手撸一个。</p>
<p>而 <code>tokio</code> 就是那颗皇冠上的夜明珠，也是值得我们投入时间去深入学习的开源库，它的设计原理和代码实现都异常优秀，在之后的章节中，我们将对其进行深入学习和剖析，敬请期待。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokio初印象"><a class="header" href="#tokio初印象">tokio初印象</a></h1>
<p>又到了喜闻乐见的初印象环节，这个环节决定了你心中的那24盏灯最终是全绿还是全灭。</p>
<p>在本文中，我们将看看本专题的学习目标、<code>tokio</code>该怎么引入以及如何实现一个 <code>Hello Tokio</code> 项目，最终留灯还是灭灯的决定权留给各位看官。但我提前说好，如果你全灭了，但却找不到更好的，未来还是得回来真香 :P</p>
<h2 id="专题目标"><a class="header" href="#专题目标">专题目标</a></h2>
<p>通过 API 学项目无疑是无聊的，因此我们采用一个与众不同的方式：边学边练，在本专题的最后你将拥有一个 <code>redis</code> 客户端和服务端，当然不会实现一个完整版本的 <code>redis</code> ，只会提供基本的功能和部分常用的命令。</p>
<h4 id="mini-redis"><a class="header" href="#mini-redis">mini-redis</a></h4>
<p><code>redis</code> 的项目源码可以在<a href="https://github.com/sunface/rust-course/tree/main/pratice/mini-redis">这里访问</a>，本项目是从<a href="https://github.com/tokio-rs/mini-redis">官方地址</a> <code>fork</code> 而来，在未来会提供注释和文档汉化。</p>
<p>再次声明：该项目仅仅用于学习目的，因此它的文档注释非常全，但是它完全无法作为 <code>redis</code> 的替代品。</p>
<h2 id="环境配置"><a class="header" href="#环境配置">环境配置</a></h2>
<p>首先，我们假定你已经安装了 Rust 和相关的工具链，例如 <code>cargo</code>。其中 Rust 版本的最低要求是 <code>1.45.0</code>，建议使用最新版 <code>1.58</code>:</p>
<pre><code class="language-shell">sunfei@sunface $ rustc --version
rustc 1.58.0 (02072b482 2022-01-11)
</code></pre>
<p>接下来，安装 <code>mini-redis</code> 的服务器端，它可以用来测试我们后面将要实现的 <code>redis</code> 客户端：</p>
<pre><code class="language-shell">$ cargo install mini-redis
</code></pre>
<blockquote>
<p>如果下载失败，也可以通过<a href="https://github.com/sunface/rust-course/tree/main/pratice/mini-redis">这个地址</a>下载源码，然后在本地通过 <code>cargo run</code>运行。</p>
</blockquote>
<p>下载成功后，启动服务端:</p>
<pre><code class="language-shell">$ mini-redis-server
</code></pre>
<p>然后，再使用客户端测试下刚启动的服务端:</p>
<pre><code class="language-shell">$ mini-redis-cli set foo 1
OK
$ mini-redis-cli get foo  
&quot;1&quot;
</code></pre>
<p>不得不说，还挺好用的，先自我陶醉下 :) 此时，万事俱备，只欠东风，接下来是时候亮&quot;箭&quot;了：实现我们的 <code>Hello Tokio</code> 项目。</p>
<h2 id="hello-tokio"><a class="header" href="#hello-tokio">Hello Tokio</a></h2>
<p>与简单无比的 <code>Hello World</code> 有所不同(简单？还记得本书开头时，湖畔边的那个多国语言版本的<code>你好，世界</code>嘛~~)，<code>Hello Tokio</code> 它承载着&quot;非常艰巨&quot;的任务，那就是向刚启动的 <code>redis</code> 服务器写入一个 <code>key=hello, value=world</code> ，然后再读取出来，嗯，使用 <code>mini-redis</code> 客户端 :) </p>
<h4 id="分析未到代码先行"><a class="header" href="#分析未到代码先行">分析未到，代码先行</a></h4>
<p>在详细讲解之前，我们先来看看完整的代码，让大家有一个直观的印象。首先，创建一个新的 <code>Rust</code> 项目:</p>
<pre><code class="language-shell">$ cargo new my-redis
$ cd my-redis
</code></pre>
<p>然后在 <code>Cargo.toml</code> 中添加相关的依赖:</p>
<pre><code class="language-toml">[dependencies]
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }
mini-redis = &quot;0.4&quot;
</code></pre>
<p>接下来，使用以下代码替换 <code>main.rs</code> 中的内容：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use mini_redis::{client, Result};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // 建立与mini-redis服务器的连接
    let mut client = client::connect(&quot;127.0.0.1:6379&quot;).await?;

    // 设置 key: &quot;hello&quot; 和 值: &quot;world&quot;
    client.set(&quot;hello&quot;, &quot;world&quot;.into()).await?;

    // 获取&quot;key=hello&quot;的值
    let result = client.get(&quot;hello&quot;).await?;

    println!(&quot;从服务器端获取到结果={:?}&quot;, result);

    Ok(())
}
</code></pre></pre>
<p>不知道你之前启动的 <code>mini-redis-server</code> 关闭没有，如果关了，记得重新启动下，否则我们的代码就是意大利空气炮。</p>
<p>最后，运行这个项目:</p>
<pre><code class="language-shell">$ cargo run
从服务器端获取到结果=Some(b&quot;world&quot;)
</code></pre>
<p>Perfect, 代码成功运行，是时候来解释下其中蕴藏的至高奥秘了。</p>
<h2 id="原理解释"><a class="header" href="#原理解释">原理解释</a></h2>
<p>代码篇幅虽然不长，但是还是有不少值得关注的地方，接下来我们一起来看看。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut client = client::connect(&quot;127.0.0.1:6379&quot;).await?;
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/mini-redis/0.4.1/mini_redis/client/fn.connect.html"><code>client::connect</code></a> 函数由<code>mini-redis</code> 包提供，它使用异步的方式跟指定的远程 <code>IP</code> 地址建立 TCP 长连接，一旦连接建立成功，那 <code>clien</code> 的赋值初始化也将完成。</p>
<p>特别值得注意的是：虽然该连接是异步建立的，但是从代码本身来看，完全是<strong>同步的代码编写方式</strong>，唯一能说明异步的点就是 <code>.await</code>。</p>
<h4 id="什么是异步编程"><a class="header" href="#什么是异步编程">什么是异步编程</a></h4>
<p>大部分计算机程序都是按照代码编写的顺序来执行的：先执行第一行，然后第二行，以此类推(当然，还要考虑流程控制，例如循环)。当进行同步编程时，一旦程序遇到一个操作无法被立即完成，它就会进入阻塞状态，直到该操作完成为止。</p>
<p>因此同步编程非常符合我们人类的思维习惯，是一个顺其自然的过程，被几乎每一个程序员所喜欢(本来想说所有，但我不敢打包票，毕竟总有特立独行之士)。例如，当建立 TCP 连接时，当前线程会被阻塞，直到等待该连接建立完成，然后才往下继续进行。</p>
<p>而使用异步编程，无法立即完成的操作会被切到后台去等待，因此当前线程不会被阻塞，它会接着执行其它的操作。一旦之前的操作准备好可以继续执行后，它会通知执行器，然后执行器会调度它并从上次离开的点继续执行。但是大家想象下，如果没有使用 <code>await</code>，而是按照这个异步的流程使用通知 -&gt; 回调的方式实现，代码该多么的难写和难读！</p>
<p>好在 Rust 为我们提供了 <code>async/await</code> 的异步编程特性，让我们可以像写同步代码那样去写异步的代码，也让这个世界美好依旧。</p>
<h4 id="编译时绿色线程"><a class="header" href="#编译时绿色线程">编译时绿色线程</a></h4>
<p>一个函数可以通过<code>async fn</code>的方式被标记为异步函数:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mini_redis::Result;
use mini_redis::client::Client;
use tokio::net::ToSocketAddrs;

pub async fn connect&lt;T: ToSocketAddrs&gt;(addr: T) -&gt; Result&lt;Client&gt; {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>在上例中，<code>redis</code> 的连接函数 <code>connect</code> 实现如上，它看上去很像是一个同步函数，但是 <code>async fn</code> 出卖了它。
<code>async fn</code> 异步函数并不会直接返回值，而是返回一个 <code>Future</code>，顾名思义，该 <code>Future</code> 会在未来某个时间点被执行，然后最终获取到真实的返回值 <code>Result&lt;Client&gt;</code>。</p>
<blockquote>
<p>async/await 的原理就算大家不理解，也不妨碍使用 <code>tokio</code> 写出能用的服务，但是如果想要更深入的用好，强烈建议认真读下本书的 <a href="https://course.rs/async/intro.html"><code>async/await</code> 异步编程章节</a>，你会对 Rust 的异步编程有一个全新且深刻的认识。</p>
</blockquote>
<p>由于 <code>async</code> 会返回一个 <code>Future</code>，因此我们还需要配合使用 <code>.await</code> 来让该 <code>Future</code> 运行起来，最终获得返回值:</p>
<pre><pre class="playground"><code class="language-rust edition2021">async fn say_to_world() -&gt; String {
    String::from(&quot;hello, world&quot;)
}

#[tokio::main]
async fn main() {
    // 此处的函数调用是惰性的，并不会执行 `say_world()` 函数体中的代码
    let op = say_to_world();

    // 首先打印出 &quot;hello&quot;
    println!(&quot;hello&quot;);

    // 使用 `.await` 让 `say_world` 开始运行起来
    op.await;
}
</code></pre></pre>
<p>上面代码输出如下:</p>
<pre><code class="language-shell">hello
world
</code></pre>
<p>而大家可能很好奇 <code>async fn</code> 到底返回什么吧？它实际上返回的是一个实现了 <code>Future</code> 特征的匿名类型: <code>impl Future&lt;Output = String&gt;</code>。</p>
<h4 id="async-main"><a class="header" href="#async-main">async main</a></h4>
<p>在代码中，使用了一个与众不同的 <code>main</code> 函数 : <code>async fn main</code> ，而且是用 <code>#[tokio::main]</code> 属性进行了标记。异步 <code>main</code> 函数有以下意义：</p>
<ul>
<li><code>.await</code> 只能在 <code>async</code> 函数中使用，如果是以前的 <code>fn main</code>，那它内部是无法直接使用 <code>async</code> 函数的！这个会极大的限制了我们的使用场景</li>
<li>异步运行时本身需要初始化</li>
</ul>
<p>因此 <code>#[tokio::main]</code> 宏在将 <code>async fn main</code> 隐式的转换为 <code>fn main</code> 的同时还对整个异步运行时进行了初始化。例如以下代码:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[tokio::main]
async fn main() {
    println!(&quot;hello&quot;);
}
</code></pre></pre>
<p>将被转换成:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(async {
        println!(&quot;hello&quot;);
    })
}
</code></pre></pre>
<p>最终，Rust 编译器就愉快地执行这段代码了。</p>
<h2 id="cargo-feature"><a class="header" href="#cargo-feature">cargo feature</a></h2>
<p>在引入 <code>tokio</code> 包时，我们在 <code>Cargo.toml</code> 文件中添加了这么一行:</p>
<pre><code class="language-toml">tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }
</code></pre>
<p>里面有个 <code>features = [&quot;full&quot;]</code> 可能大家会比较迷惑，当然，关于它的具体解释在本书的 <code>[Cargo详解专题]</code> 有介绍，这里就简单进行说明，</p>
<p><code>Tokio</code> 有很多功能和特性，例如 <code>TCP</code>，<code>UDP</code>，<code>Unix sockets</code>，同步工具，多调度类型等等，不是每个应用都需要所有的这些特性。为了优化编译时间和最终生成可执行文件大小、内存占用大小，应用可以对这些特性进行可选引入。</p>
<p>而这里为了演示的方便，我们使用 <code>full</code> ，表示直接引入所有的特性。</p>
<h2 id="总结-20"><a class="header" href="#总结-20">总结</a></h2>
<p>大家对 <code>tokio</code> 的初印象如何？可否24灯全绿通过？</p>
<p>总之，<code>tokio</code> 做的事情其实是细雨润无声的，在大多数时候，我们并不能感觉到它的存在，但是它确实是异步编程中最重要的一环(或者之一)，深入了解它对我们的未来之路会有莫大的帮助。</p>
<p>接下来，正式开始 <code>tokio</code> 的学习之旅。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="创建异步任务"><a class="header" href="#创建异步任务">创建异步任务</a></h1>
<p>同志们，抓稳了，我们即将换挡提速，通向 <code>mini-redis</code> 服务端的高速之路已经开启。</p>
<p>不过在开始之前，先来做点收尾工作：上一章节中，我们实现了一个简易的 <code>mini-redis</code> 客户端并支持了 <code>SET</code>/<code>GET</code> 操作, 现在将该<a href="https://course.rs/tokio/getting-startted.html#%E5%88%86%E6%9E%90%E6%9C%AA%E5%88%B0%E4%BB%A3%E7%A0%81%E5%85%88%E8%A1%8C">代码</a>移动到 <code>example</code> 文件夹下，因为我们这个章节要实现的是服务器，后面可以用之前客户端示例对我们的服务器端进行测试:</p>
<pre><code class="language-shell">$ mkdir -p examples
$ mv src/main.rs examples/hello-redis.rs
</code></pre>
<p>然后再重新创建一个空的 <code>src/main.rs</code> 文件，至此换挡已经完成，提速正式开始。</p>
<h2 id="接收-sockets"><a class="header" href="#接收-sockets">接收 sockets</a></h2>
<p>作为服务器端，最基础的工作无疑是接收外部进来的 TCP 连接，可以通过 <code>tokio::net::TcpListene</code> 来完成。</p>
<blockquote>
<p>Tokio 中大多数类型的名称都和标准库中对应的同步类型名称相同，而且，如果没有特殊原因，Tokio 的 API 名称也和标准库保持一致，只不过用 <code>async fn</code> 取代 <code>fn</code> 来声明函数。</p>
</blockquote>
<p><code>TcpListener</code> 监听 <strong>6379</strong> 端口，然后通过循环来接收外部进来的连接，每个连接在处理完后会被关闭。对于目前来说，我们的任务很简单：读取命令、打印到标准输出 <code>stdout</code>，最后回复给客户端一个错误。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use tokio::net::{TcpListener, TcpStream};
use mini_redis::{Connection, Frame};

#[tokio::main]
async fn main() {
    // Bind the listener to the address
    // 监听指定地址，等待 TCP 连接进来
    let listener = TcpListener::bind(&quot;127.0.0.1:6379&quot;).await.unwrap();

    loop {
        // 第二个被忽略的项中包含有新连接的 `IP` 和端口信息
        let (socket, _) = listener.accept().await.unwrap();
        process(socket).await;
    }
}

async fn process(socket: TcpStream) {
    // `Connection` 对于 redis 的读写进行了抽象封装，因此我们读到的是一个一个数据帧frame(数据帧 = redis命令 + 数据)，而不是字节流
    // `Connection` 是在 mini-redis 中定义
    let mut connection = Connection::new(socket);

    if let Some(frame) = connection.read_frame().await.unwrap() {
        println!(&quot;GOT: {:?}&quot;, frame);

        // 回复一个错误
        let response = Frame::Error(&quot;unimplemented&quot;.to_string());
        connection.write_frame(&amp;response).await.unwrap();
    }
}
</code></pre></pre>
<p>现在运行我们的简单服务器 :</p>
<pre><code class="language-shel">cargo run
</code></pre>
<p>此时服务器会处于循环等待以接收连接的状态，接下来在一个新的终端窗口中启动上一章节中的 <code>redis</code> 客户端，由于相关代码已经放入 <code>examples</code> 文件夹下，因此我们可以使用 <code>-- example</code> 来指定运行该客户端示例:</p>
<pre><code class="language-shell">$ cargo run --example hello-redis
</code></pre>
<p>此时，客户端的输出是: <code>Error: &quot;unimplemented&quot;</code>, 同时服务器端打印出了客户端发来的由 <strong>redis 命令和数据</strong> 组成的数据帧: <code>GOT: Array([Bulk(b&quot;set&quot;), Bulk(b&quot;hello&quot;), Bulk(b&quot;world&quot;)])</code>。</p>
<h2 id="生成任务"><a class="header" href="#生成任务">生成任务</a></h2>
<p>上面的服务器，如果你仔细看，它其实一次只能接受和处理一条 TCP 连接，只有等当前的处理完并结束后，才能开始接收下一条连接。原因在于 <code>loop</code> 循环中的 <code>await</code> 会导致当前任务进入阻塞等待，也就是 <code>loop</code> 循环会被阻塞。</p>
<p>而这显然不是我们想要的，服务器能并发地处理多条连接的请求，才是正确的打开姿势，下面来看看如何实现真正的并发。</p>
<blockquote>
<p>关于并发和并行，在<a href="https://course.rs/advance/concurrency-with-threads/concurrency-parallelism.html">多线程章节中</a>有详细的解释</p>
</blockquote>
<p>为了并发的处理连接，需要为每一条进来的连接都生成( <code>spawn</code> )一个新的任务, 然后在该任务中处理连接:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use tokio::net::TcpListener;

#[tokio::main]
async fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:6379&quot;).await.unwrap();

    loop {
        let (socket, _) = listener.accept().await.unwrap();
        // 为每一条连接都生成一个新的任务，
        // `socket` 的所有权将被移动到新的任务中，并在那里进行处理
        tokio::spawn(async move {
            process(socket).await;
        });
    }
}
</code></pre></pre>
<h4 id="任务"><a class="header" href="#任务">任务</a></h4>
<p>一个 Tokio 任务是一个异步的绿色线程，它们通过 <code>tokio::spawn</code> 进行创建，该函数会返回一个 <code>JoinHandle</code> 类型的句柄，调用者可以使用该句柄跟创建的任务进行交互。</p>
<p><code>spawn</code> 函数的参数是一个 <code>async</code> 语句块，该语句块甚至可以返回一个值，然后调用者可以通过 <code>JoinHandle</code> 句柄获取该值:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[tokio::main]
async fn main() {
    let handle = tokio::spawn(async {
       10086
    });

    let out = handle.await.unwrap();
    println!(&quot;GOT {}&quot;, out);
}
</code></pre></pre>
<p>以上代码会打印出<code>GOT 10086</code>。实际上，上面代码中<code>.await</code> 会返回一个 <code>Result</code> ，若 <code>spawn</code> 创建的任务正常运行结束，则返回一个 <code>Ok(T)</code>的值，否则会返回一个错误 <code>Err</code>：例如任务内部发生了 <code>panic</code> 或任务因为运行时关闭被强制取消时。</p>
<p>任务是调度器管理的执行单元。<code>spawn</code>生成的任务会首先提交给调度器，然后由它负责调度执行。需要注意的是，执行任务的线程未必是创建任务的线程，任务完全有可能运行在另一个不同的线程上，而且任务在生成后，它还可能会在线程间被移动。</p>
<p>任务在 Tokio 中远比看上去要更轻量，例如创建一个任务仅仅需要一次64字节大小的内存分配。因此应用程序在生成任务上，完全不应该有任何心理负担，除非你在一台没那么好的机器上疯狂生成了几百万个任务。。。</p>
<h4 id="static-约束"><a class="header" href="#static-约束"><code>'static</code> 约束</a></h4>
<p>当使用 Tokio 创建一个任务时，该任务类型的生命周期必须时 <code>'static</code>。意味着，在任务中不能使用外部数据的引用:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use tokio::task;

#[tokio::main]
async fn main() {
    let v = vec![1, 2, 3];

    task::spawn(async {
        println!(&quot;Here's a vec: {:?}&quot;, v);
    });
}
</code></pre></pre>
<p>上面代码中，<code>spawn</code> 出的任务引用了外部环境中的变量 <code>v</code> ，导致以下报错:</p>
<pre><code class="language-console">error[E0373]: async block may outlive the current function, but
              it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:7:23
  |
7 |       task::spawn(async {
  |  _______________________^
8 | |         println!(&quot;Here's a vec: {:?}&quot;, v);
  | |                                        - `v` is borrowed here
9 | |     });
  | |_____^ may outlive borrowed value `v`
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:7:17
  |
7 |       task::spawn(async {
  |  _________________^
8 | |         println!(&quot;Here's a vector: {:?}&quot;, v);
9 | |     });
  | |_____^
help: to force the async block to take ownership of `v` (and any other
      referenced variables), use the `move` keyword
  |
7 |     task::spawn(async move {
8 |         println!(&quot;Here's a vec: {:?}&quot;, v);
9 |     });
  |
</code></pre>
<p>原因在于：默认情况下，变量并不是通过 <code>move</code> 的方式转移进 <code>async</code> 语句块的， <code>v</code> 变量的所有权依然属于 <code>main</code> 函数，因为任务内部的 <code>println!</code> 是通过借用的方式使用了 <code>v</code>，但是这种借用并不能满足 <code>'static</code> 生命周期的要求。</p>
<p>在报错的同时，Rust编译器还给出了相当有帮助的提示：为 <code>async</code> 语句块使用 <code>move</code> 关键字，这样就能将 <code>v</code> 的所有权从 <code>main</code> 函数转移到新创建的任务中。</p>
<p>但是 <code>move</code> 有一个问题，一个数据只能被一个任务使用，如果想要多个任务使用一个数据，就有些强人所难。不知道还有多少同学记得 <a href="tokio/../advance/smart-pointer/rc-arc.html"><code>Arc</code></a>，它可以轻松解决该问题，还是线程安全的。</p>
<p>在上面的报错中，还有一句很奇怪的信息<code>function requires argument type to outlive 'static</code>， 函数要求参数类型的生命周期必须比 <code>'static</code> 长，问题是 <code>'static</code> 已经活得跟整个程序一样久了，难道函数的参数还能活得更久？大家可能会觉得编译器秀逗了，毕竟其它语言编译器也有秀逗的时候:) </p>
<p>先别急着给它扣帽子，虽然我有时候也想这么做。。原因是它说的是类型必须活得比 <code>'static</code> 长，而不是值。当我们说一个值是 <code>'static</code> 时，意味着它将永远存活。这个很重要，因为编译器无法知道新创建的任务将存活多久，所以唯一的办法就是让任务永远存活。</p>
<p>实际上编译的这个报错在告诉我们函数的参数要满足以下约束：<code>T: 'static</code>。</p>
<p>我们一般用 <strong>T 被 'static 所约束</strong> 来描述 <code>T: 'static</code>，当然你也可以说<strong>T 类型比 <code>'static</code> 活得更久</strong> 或 <strong>T的值是 <code>'static</code></strong> ，事实上这三个是一个意思，都是说只要 <code>T: 'static</code>, 那它将永远活下去。 </p>
<p>反而是 <code>&amp;'static T</code> 它拥有一个不同的含义：使用<code>'static</code> 进行标注，但这个标注并不能让 <code>T</code> 永远活下去，仅仅是一个标注。</p>
<p>也就是说，一个类型 <code>T</code> 必须活得比 <code>'static</code> 更长，意味着它满足以下约束 <code>T: 'static</code></p>
<p>PS: 这一段内容，Tokio 的原文有些逻辑混乱，我已经尽可能的理清了作者想表达的含义, 同时补充了一些自己的理解，以让内容阅读起来更流畅 ：/</p>
<blockquote>
<p>一个关于 <code>'static</code> 生命周期的常见误解就是它将永远存活(跟整个程序活得一样久)，实际上并不是这样的。同样的，一个变量是 <code>'static</code> 并不意味着它存在内存泄漏的可能性。</p>
</blockquote>
<h4 id="send-约束"><a class="header" href="#send-约束">Send 约束</a></h4>
<p><code>tokio::spawn</code> 生成的任务必须实现 <code>Send</code> 特征，因为 Tokio 调度器会将任务在线程间进行移动，当这些任务在 <code>.await</code> 执行过程中发生阻塞时。</p>
<p><strong>一个任务要实现 <code>Send</code> 特征，那它在 <code>.await</code> 调用的过程中所持有的全部数据都必须实现 <code>Send</code> 特征</strong>。当 <code>.await</code> 调用发生阻塞时，任务会让出当前线程所有权给调度器，然后当任务准备好后，调度器会从上一次暂停的位置继续执行该任务。该流程能正确的工作，任务必须将<code>.await</code>之后使用的所有状态保存起来，这样才能在中断后恢复现场并继续执行。若这些状态实现了 <code>Send</code> 特征(可以在线程间安全地移动)，那任务自然也就可以在线程间安全地移动。</p>
<p>例如以下代码可以工作:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use tokio::task::yield_now;
use std::rc::Rc;

#[tokio::main]
async fn main() {
    tokio::spawn(async {
        // 语句块的使用强制了 `rc` 会在 `.await` 被调用前就被释放，
        // 因此 `rc` 并不会影响 `.await`的安全性
        {
            let rc = Rc::new(&quot;hello&quot;);
            println!(&quot;{}&quot;, rc);
        }

        // `rc` 的作用范围已经失效，因此当任务让出所有权给当前线程时，它无需作为状态被保存起来
        yield_now().await;
    });
}
</code></pre></pre>
<p>但是下面代码就不行：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use tokio::task::yield_now;
use std::rc::Rc;

#[tokio::main]
async fn main() {
    tokio::spawn(async {
        let rc = Rc::new(&quot;hello&quot;);


        // `rc` 在 `.await` 后还被继续使用，因此它必须被作为任务的状态保存起来
        yield_now().await;


        // 事实上，注释掉下面一行代码，依然会报错
        // 原因是：是否保存，不取决于 `rc` 是否被使用，而是取决于 `.await`在调用时是否仍然处于 `rc` 的作用域中
        println!(&quot;{}&quot;, rc);

        // rc 作用域在这里结束
    });
}
</code></pre></pre>
<p>这里有一个很重要的点，代码注释里有讲到，但是我们再重复一次： <code>rc</code> 是否会保存到任务状态中，取决于 <code>.await</code> 的调用是否处于它的作用域中，上面代码中，就算你注释掉 <code>println!</code> 函数，该报错依然会报错，因为 <code>rc</code> 的作用域直到 <code>async</code> 的末尾才结束！</p>
<p>下面是相应的报错，在下一章节，我们还会继续深入讨论该错误:</p>
<pre><code class="language-shell">error: future cannot be sent between threads safely
   --&gt; src/main.rs:6:5
    |
6   |     tokio::spawn(async {
    |     ^^^^^^^^^^^^ future created by async block is not `Send`
    | 
   ::: [..]spawn.rs:127:21
    |
127 |         T: Future + Send + 'static,
    |                     ---- required by this bound in
    |                          `tokio::task::spawn::spawn`
    |
    = help: within `impl std::future::Future`, the trait
    |       `std::marker::Send` is not  implemented for
    |       `std::rc::Rc&lt;&amp;str&gt;`
note: future is not `Send` as this value is used across an await
   --&gt; src/main.rs:10:9
    |
7   |         let rc = Rc::new(&quot;hello&quot;);
    |             -- has type `std::rc::Rc&lt;&amp;str&gt;` which is not `Send`
...
10  |         yield_now().await;
    |         ^^^^^^^^^^^^^^^^^ await occurs here, with `rc` maybe
    |                           used later
11  |         println!(&quot;{}&quot;, rc);
12  |     });
    |     - `rc` is later dropped here
</code></pre>
<h2 id="使用hashmap存储数据"><a class="header" href="#使用hashmap存储数据">使用HashMap存储数据</a></h2>
<p>现在，我们可以继续前进了，下面来实现 <code>process</code> 函数，它用于处理进入的命令。相应的值将被存储在 <code>HashMap</code> 中: 通过 <code>SET</code> 命令存值，通过 <code>GET</code> 命令来取值。</p>
<p>同时，我们将使用循环的方式在同一个客户端连接中处理多次连续的请求:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::TcpStream;
use mini_redis::{Connection, Frame};

async fn process(socket: TcpStream) {
    use mini_redis::Command::{self, Get, Set};
    use std::collections::HashMap;

    // 使用 hashmap 来存储 redis 的数据
    let mut db = HashMap::new();

    // `mini-redis` 提供的便利函数，使用返回的 `connection` 可以用于从 socket 中读取数据并解析为数据帧
    let mut connection = Connection::new(socket);

    // 使用 `read_frame` 方法从连接获取一个数据帧：一条redis命令 + 相应的数据
    while let Some(frame) = connection.read_frame().await.unwrap() {
        let response = match Command::from_frame(frame).unwrap() {
            Set(cmd) =&gt; {
                // 值被存储为 `Vec&lt;u8&gt;` 的形式
                db.insert(cmd.key().to_string(), cmd.value().to_vec());
                Frame::Simple(&quot;OK&quot;.to_string())
            }
            Get(cmd) =&gt; {
                if let Some(value) = db.get(cmd.key()) {
                    // `Frame::Bulk` 期待数据的类型是 `Bytes`， 该类型会在后面章节讲解，
                    // 此时，你只要知道 `&amp;Vec&lt;u8&gt;` 可以使用 `into()` 方法转换成 `Bytes` 类型
                    Frame::Bulk(value.clone().into())
                } else {
                    Frame::Null
                }
            }
            cmd =&gt; panic!(&quot;unimplemented {:?}&quot;, cmd),
        };

        // 将请求响应返回给客户端
        connection.write_frame(&amp;response).await.unwrap();
    }
}

// main 函数在之前已实现
<span class="boring">}
</span></code></pre></pre>
<p>使用 <code>cargo run</code> 运行服务器，然后再打开另一个终端窗口，运行 <code>hello-redis</code> 客户端示例: <code>cargo run --example hello-redis</code>。</p>
<p>Bingo，在看了这么多原理后，我们终于迈出了小小的第一步，并获取到了存在 <code>HashMap</code> 中的值: <code>got value from the server; result=Some(b&quot;world&quot;)</code>。</p>
<p>但是问题又来了：这些值无法在 TCP 连接中共享，如果另外一个用户连接上来并试图同时获取 <code>hello</code> 这个 <code>key</code>，他将一无所获。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="对抗编译检查"><a class="header" href="#对抗编译检查">对抗编译检查</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="幽灵数据"><a class="header" href="#幽灵数据">幽灵数据</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命周期-1"><a class="header" href="#生命周期-1">生命周期</a></h1>
<p>本章并不讲太多的概念，主要是用例子来引导大家去思考该如何对抗编译检查。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命周期声明的范围过大"><a class="header" href="#生命周期声明的范围过大">生命周期声明的范围过大</a></h1>
<p>在大多时候，Rust的生命周期你只要标识了，即可以通过编译，但是总是存在一些情况，会导致编译无法通过，本文就讲述这样一种情况：因为生命周期声明的范围过大，导致了编译无法通过，希望大家喜欢</p>
<h2 id="例子1-1"><a class="header" href="#例子1-1">例子1</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">struct Interface&lt;'a&gt; {
    manager: &amp;'a mut Manager&lt;'a&gt;
}

impl&lt;'a&gt; Interface&lt;'a&gt; {
    pub fn noop(self) {
        println!(&quot;interface consumed&quot;);
    }
}

struct Manager&lt;'a&gt; {
    text: &amp;'a str    
}

struct List&lt;'a&gt; {
    manager: Manager&lt;'a&gt;,
}

impl&lt;'a&gt; List&lt;'a&gt; {
    pub fn get_interface(&amp;'a mut self) -&gt; Interface {
        Interface {
            manager: &amp;mut self.manager
        }
    }
} 

fn main() {
    let mut list = List {
        manager: Manager {
            text: &quot;hello&quot;
        }
    };
    
    list.get_interface().noop();
    
    println!(&quot;Interface should be dropped here and the borrow released&quot;);
    
    // this fails because inmutable/mutable borrow
    // but Interface should be already dropped here and the borrow released
    use_list(&amp;list);
}

fn use_list(list: &amp;List) {
    println!(&quot;{}&quot;, list.manager.text);
}
</code></pre></pre>
<p>运行后报错：</p>
<pre><code class="language-console">error[E0502]: cannot borrow `list` as immutable because it is also borrowed as mutable // `list`无法被借用，因为已经被可变借用
  --&gt; src/main.rs:40:14
   |
34 |     list.get_interface().noop();
   |     ---- mutable borrow occurs here // 可变借用发生在这里
...
40 |     use_list(&amp;list);
   |              ^^^^^
   |              |
   |              immutable borrow occurs here // 新的不可变借用发生在这
   |              mutable borrow later used here // 可变借用在这里结束
</code></pre>
<p>这段代码看上去并不复杂，实际上难度挺高的，首先在直觉上，<code>list.get_interface()</code>借用的可变引用，按理来说应该在这行代码结束后，就归还了，为何能持续到<code>use_list(&amp;list)</code>后面呢？</p>
<p>这是因为我们在<code>get_interface</code>方法中声明的<code>lifetime</code>有问题，该方法的参数的生明周期是<code>'a</code>，而<code>List</code>的生命周期也是<code>'a</code>，说明该方法至少活得跟<code>List</code>一样久，再回到<code>main</code>函数中，<code>list</code>可以活到<code>main</code>函数的结束，因此<code>list.get_interface()</code>借用的可变引用也会活到<code>main</code>函数的结束，在此期间，自然无法再进行借用了。</p>
<p>要解决这个问题，我们需要为<code>get_interface</code>方法的参数给予一个不同于<code>List&lt;'a&gt;</code>的生命周期<code>'b</code>，最终代码如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Interface&lt;'b, 'a: 'b&gt; {
    manager: &amp;'b mut Manager&lt;'a&gt;
}

impl&lt;'b, 'a: 'b&gt; Interface&lt;'b, 'a&gt; {
    pub fn noop(self) {
        println!(&quot;interface consumed&quot;);
    }
}

struct Manager&lt;'a&gt; {
    text: &amp;'a str    
}

struct List&lt;'a&gt; {
    manager: Manager&lt;'a&gt;,
}

impl&lt;'a&gt; List&lt;'a&gt; {
    pub fn get_interface&lt;'b&gt;(&amp;'b mut self) -&gt; Interface&lt;'b, 'a&gt;
    where 'a: 'b {
        Interface {
            manager: &amp;mut self.manager
        }
    }
} 

fn main() {

    let mut list = List {
        manager: Manager {
            text: &quot;hello&quot;
        }
    };
    
    list.get_interface().noop();
    
    println!(&quot;Interface should be dropped here and the borrow released&quot;);
    
    // this fails because inmutable/mutable borrow
    // but Interface should be already dropped here and the borrow released
    use_list(&amp;list);
}

fn use_list(list: &amp;List) {
    println!(&quot;{}&quot;, list.manager.text);
}
</code></pre></pre>
<p>当然，咱还可以给生命周期给予更有意义的名称：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Interface&lt;'text, 'manager&gt; {
    manager: &amp;'manager mut Manager&lt;'text&gt;
}

impl&lt;'text, 'manager&gt; Interface&lt;'text, 'manager&gt; {
    pub fn noop(self) {
        println!(&quot;interface consumed&quot;);
    }
}

struct Manager&lt;'text&gt; {
    text: &amp;'text str    
}

struct List&lt;'text&gt; {
    manager: Manager&lt;'text&gt;,
}

impl&lt;'text&gt; List&lt;'text&gt; {
    pub fn get_interface&lt;'manager&gt;(&amp;'manager mut self) -&gt; Interface&lt;'text, 'manager&gt; {
        Interface {
            manager: &amp;mut self.manager
        }
    }
} 

fn main() {
    let mut list = List {
        manager: Manager {
            text: &quot;hello&quot;
        }
    };
    
    list.get_interface().noop();
    
    println!(&quot;Interface should be dropped here and the borrow released&quot;);
    
    // this fails because inmutable/mutable borrow
    // but Interface should be already dropped here and the borrow released
    use_list(&amp;list);
}

fn use_list(list: &amp;List) {
    println!(&quot;{}&quot;, list.manager.text);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命周期过大-02"><a class="header" href="#生命周期过大-02">生命周期过大-02</a></h1>
<p>继上篇文章后，我们再来看一段<strong>可能</strong>涉及生命周期过大导致的无法编译问题:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn bar(writer: &amp;mut Writer) {
    baz(writer.indent());
    writer.write(&quot;world&quot;);
}

fn baz(writer: &amp;mut Writer) {
    writer.write(&quot;hello&quot;);
}

pub struct Writer&lt;'a&gt; {
    target: &amp;'a mut String,
    indent: usize,
}

impl&lt;'a&gt; Writer&lt;'a&gt; {
    fn indent(&amp;'a mut self) -&gt; &amp;'a mut Self {
        &amp;mut Self {
            target: self.target,
            indent: self.indent + 1,
        }
    }

    fn write(&amp;mut self, s: &amp;str) {
        for _ in 0..self.indent {
            self.target.push(' ');
        }
        self.target.push_str(s);
        self.target.push('\n');
    }
}

fn main() {}
</code></pre></pre>
<p>报错如下：</p>
<pre><code class="language-console">error[E0623]: lifetime mismatch
 --&gt; src/main.rs:2:16
  |
1 | fn bar(writer: &amp;mut Writer) {
  |                -----------
  |                |
  |                these two types are declared with different lifetimes...
2 |     baz(writer.indent());
  |                ^^^^^^ ...but data from `writer` flows into `writer` here
</code></pre>
<p>WTF，这什么报错，之前都没有见过，而且很难理解，什么叫<code>writer</code>滑入了另一个<code>writer</code>？</p>
<p>别急，我们先来仔细看下代码，注意这一段：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; Writer&lt;'a&gt; {
    fn indent(&amp;'a mut self) -&gt; &amp;'a mut Self {
        &amp;mut Self {
            target: self.target,
            indent: self.indent + 1,
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>这里的生命周期定义说明<code>indent</code>方法使用的。。。等等！你的代码错了，你怎么能在一个函数中返回一个新创建实例的引用？！！最重要的是，编译器不提示这个错误，竟然提示一个莫名其妙看不懂的东东。</p>
<p>行，那我们先解决这个问题，将该方法修改为:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn indent(&amp;'a mut self) -&gt; Writer&lt;'a&gt; {
    Writer {
        target: self.target,
        indent: self.indent + 1,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>怀着惴惴这心，再一次运行程序，果不其然，编译器又朝我们扔了一坨错误：</p>
<pre><code class="language-console">error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     baz(writer.indent());
  |         ^^^^^^^^^^^^^^^
  |         |
  |         expected `&amp;mut Writer&lt;'_&gt;`, found struct `Writer`
  |         help: consider mutably borrowing here: `&amp;mut writer.indent()`
</code></pre>
<p>哦，这次错误很明显，因为<code>baz</code>需要<code>&amp;mut Writer</code>，但是咱们<code>writer.indent</code>返回了一个<code>Writer</code>，因此修改下即可:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar(writer: &amp;mut Writer) {
    baz(&amp;mut writer.indent());
    writer.write(&quot;world&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>这次总该成功了吧？再次心慌慌的运行编译器，哐：</p>
<pre><code class="language-console">error[E0623]: lifetime mismatch
 --&gt; src/main.rs:2:21
  |
1 | fn bar(writer: &amp;mut Writer) {
  |                -----------
  |                |
  |                these two types are declared with different lifetimes...
2 |     baz(&amp;mut writer.indent());
  |                     ^^^^^^ ...but data from `writer` flows into `writer` here
</code></pre>
<p>可恶，还是这个看不懂的错误，仔细检查了下代码，这次真的没有其他错误了，只能硬着头皮上。</p>
<p>大概的意思可以分析，生命周期范围不匹配，说明一个大一个小，然后一个<code>writer</code>中流入到另一个<code>writer</code>说明，两个<code>writer</code>的生命周期定义错了，既然这里提到了<code>indent</code>方法调用，那么我们再去仔细看一眼：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; Writer&lt;'a&gt; {
    fn indent(&amp;'a mut self) -&gt; Writer&lt;'a&gt; {
        Writer {
            target: self.target,
            indent: self.indent + 1,
        }
    }
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>好像有点问题，<code>indent</code>返回的<code>Writer</code>的生命周期和外面的<code>Writer</code>的生命周期一模一样，这很不合理，一眼就能看出前者远小于后者,那我们尝试着修改下<code>indent</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> fn indent&lt;'b&gt;(&amp;'b mut self) -&gt; Writer&lt;'b&gt; {
    Writer {
        target: self.target,
        indent: self.indent + 1,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Bang! 编译成功，不过稍等，回想下生命周期消除的规则，我们还可以实现的更优雅：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn bar(writer: &amp;mut Writer) {
    baz(&amp;mut writer.indent());
    writer.write(&quot;world&quot;);
}

fn baz(writer: &amp;mut Writer) {
    writer.write(&quot;hello&quot;);
}

pub struct Writer&lt;'a&gt; {
    target: &amp;'a mut String,
    indent: usize,
}

impl&lt;'a&gt; Writer&lt;'a&gt; {
    fn indent(&amp;mut self) -&gt; Writer {
        Writer {
            target: self.target,
            indent: self.indent + 1,
        }
    }

    fn write(&amp;mut self, s: &amp;str) {
        for _ in 0..self.indent {
            self.target.push(' ');
        }
        self.target.push_str(s);
        self.target.push('\n');
    }
}

fn main() {}
</code></pre></pre>
<p>至此，问题彻底解决，太好了，我感觉我又变强了。可是默默看了眼自己的头发，只能以<code>哎～</code>一声叹息结束本章内容。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="蠢笨编译器之循环生命周期"><a class="header" href="#蠢笨编译器之循环生命周期">蠢笨编译器之循环生命周期</a></h1>
<p>当涉及生命周期时，Rust编译器有时会变得不太聪明，如果再配合循环，蠢笨都不足以形容它，不信？那继续跟着我一起看看。</p>
<h2 id="循环中的生命周期错误"><a class="header" href="#循环中的生命周期错误">循环中的生命周期错误</a></h2>
<p>Talk is cheap, 一起来看个例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::{thread_rng, Rng};

#[derive(Debug, PartialEq)]
enum Tile {
    Empty,
}

fn random_empty_tile(arr: &amp;mut [Tile]) -&gt; &amp;mut Tile {
    loop {
        let i = thread_rng().gen_range(0..arr.len());
        let tile = &amp;mut arr[i];
        if Tile::Empty == *tile{
            return tile;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们来看看上面的代码中，<code>loop</code>循环有几个引用：</p>
<ul>
<li><code>arr.len()</code>, 一个不可变引用，生命周期随着函数调用的结束而结束</li>
<li><code>tile</code>是可变引用，生命周期在下次循环开始前会结束</li>
</ul>
<p>根据以上的分析，可以得出个初步结论：在同一次循环间各个引用生命周期互不影响，在两次循环间，引用也互不影响。</p>
<p>那就简单了，开心运行，开心。。。报错:</p>
<pre><code class="language-console">error[E0502]: cannot borrow `*arr` as immutable because it is also borrowed as mutable
  --&gt; src/main.rs:10:43
   |
8  | fn random_empty_tile(arr: &amp;mut [Tile]) -&gt; &amp;mut Tile {
   |                           - let's call the lifetime of this reference `'1`
9  |     loop {
10 |         let i = thread_rng().gen_range(0..arr.len());
   |                                           ^^^ immutable borrow occurs here
11 |         let tile = &amp;mut arr[i];
   |                    ----------- mutable borrow occurs here
12 |         if Tile::Empty == *tile{
13 |             return tile;
   |                    ---- returning this value requires that `arr[_]` is borrowed for `'1`

error[E0499]: cannot borrow `arr[_]` as mutable more than once at a time
  --&gt; src/main.rs:11:20
   |
8  | fn random_empty_tile(arr: &amp;mut [Tile]) -&gt; &amp;mut Tile {
   |                           - let's call the lifetime of this reference `'1`
...
11 |         let tile = &amp;mut arr[i];
   |                    ^^^^^^^^^^^ `arr[_]` was mutably borrowed here in the previous iteration of the loop
12 |         if Tile::Empty == *tile{
13 |             return tile;
   |                    ---- returning this value requires that `arr[_]` is borrowed for `'1`
</code></pre>
<p>不仅是错误，还是史诗级别的错误！无情刷屏了！只能想办法梳理下：</p>
<ol>
<li><code>arr.len()</code>报错，原因是它借用了不可变引用，但是在紧跟着的<code>&amp;mut arr[i]</code>中又借用了可变引用</li>
<li><code>&amp;mut arr[i]</code>报错，因为在上一次循环中，已经借用过同样的可变引用<code>&amp;mut arr[i]</code></li>
<li><code>tile</code>的生命周期跟<code>arr</code>不一致</li>
</ol>
<p>奇了怪了，跟我们之前的分析完全背道而驰，按理来说<code>arr.len()</code>的借用应该在调用后立刻结束，而不是持续到后面的代码行；同时可变借用<code>&amp;mut arr[i]</code>也应该随着每次循环的结束而结束，为什么会前后两次循环会因为同一处的引用而报错？</p>
<h2 id="尝试去掉中间变量"><a class="header" href="#尝试去掉中间变量">尝试去掉中间变量</a></h2>
<p>虽然报错复杂，不过可以看出，所有的错误都跟<code>tile</code>这个中间变量有关，我们试着移除它看看：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::{thread_rng, Rng};

#[derive(Debug, PartialEq)]
enum Tile {
    Empty,
}

fn random_empty_tile(arr: &amp;mut [Tile]) -&gt; &amp;mut Tile {
    loop {
        let i = thread_rng().gen_range(0..arr.len());
        if Tile::Empty == arr[i] {
            return &amp;mut arr[i];
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>见证奇迹的时刻，竟然编译通过了！到底发什么了什么？仅仅移除了中间变量，就编译通过了？是否可以大胆的猜测，因为中间变量，导致编译器变蠢了，因此无法正确的识别引用的生命周期。</p>
<h2 id="循环展开"><a class="header" href="#循环展开">循环展开</a></h2>
<p>如果不使用循环呢？会不会也有这样的错误？咱们试着把循环展开：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::{thread_rng, Rng};

#[derive(Debug, PartialEq)]
enum Tile {
    Empty,
}

fn random_empty_tile_2&lt;'arr&gt;(arr: &amp;'arr mut [Tile]) -&gt; &amp;'arr mut Tile {
    let len = arr.len();
 
    // First loop iteration
    {
        let i = thread_rng().gen_range(0..len);
        let tile = &amp;mut arr[i]; // Lifetime: 'arr
        if Tile::Empty == *tile {
            return tile;
        }
    } 
 
    // Second loop iteration
    {
        let i = thread_rng().gen_range(0..len);
        let tile = &amp;mut arr[i]; // Lifetime: 'arr
         if Tile::Empty == *tile {
            return tile;
        }
    }

    unreachable!()
} 
<span class="boring">}
</span></code></pre></pre>
<p>结果，编译器还是不给通过，报的错误几乎一样</p>
<h2 id="深层原因"><a class="header" href="#深层原因">深层原因</a></h2>
<p>令人沮丧的是，我找遍了网上，也没有具体的原因，大家都说这是编译器太笨导致的问题，但是关于深层的原因，也没人能说出个所有然。</p>
<p>因此，我无法在本文中给出为什么编译器会这么笨的真实原因，如果以后有结果，会在这里进行更新。</p>
<p>------2022年1月13日更新-------
兄弟们，我带着挖掘出的一些内容回来了，再来看段错误代码先：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    a: i32
}

impl A {
    fn one(&amp;mut self) -&gt; &amp;i32{
        self.a = 10;
        &amp;self.a
    }
    fn two(&amp;mut self) -&gt; &amp;i32 {
        loop {
            let k = self.one();
            if *k &gt; 10i32 {
                return k;
            }

            // 可能存在的剩余代码
            // ...
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们来逐步深入分析下：</p>
<ol>
<li>首先为<code>two</code>方法增加一下生命周期标识: <code>fn two&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a i32 { .. }</code>, 这里根据生命周期的<a href="fight-with-compiler/lifetime/../../advance/lifetime/basic.html#%E4%B8%89%E6%9D%A1%E6%B6%88%E9%99%A4%E8%A7%84%E5%88%99">消除规则</a>添加的</li>
<li>根据生命周期标识可知：<code>two</code>中返回的<code>k</code>的生命周期必须是<code>'a</code></li>
<li>根据第2条，又可知：<code>let k = self.one();</code>中对<code>self</code>的借用生命周期也是<code>'a</code></li>
<li>因为<code>k</code>的借用发生在<code>loop</code>循环内，因此它需要小于等于循环的生命周期，但是根据之前的推断，它又要大于等于函数的生命周期<code>'a</code>，而函数的生命周期又大于等于循环生命周期，</li>
</ol>
<p>由上可以推出：<code>let k = self.one();</code>中<code>k</code>的生命周期要大于等于循环的生命周期，又要小于等于循环的生命周期, 唯一满足条件的就是：<code>k</code>的生命周期等于循环生命周期。</p>
<p>但是我们的<code>two</code>方法在循环中对<code>k</code>进行了提前返回，编译器自然会认为存在其它代码，这会导致<code>k</code>的生命周期小于循环的生命周期。</p>
<p>怎么办呢？很简单：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn two(&amp;mut self) -&gt; &amp;i32 {
    loop {
        let k = self.one();
        return k;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>不要在<code>if</code>分支中返回<code>k</code>，而是直接返回，这样就让它们的生命周期相等了，最终可以顺利编译通过。</p>
<blockquote>
<p>如果一个引用值从函数的某个路径提前返回了，那么该借用必须要在函数的所有返回路径都合法</p>
</blockquote>
<h2 id="解决方法"><a class="header" href="#解决方法">解决方法</a></h2>
<p>虽然不能给出原因，但是我们可以看看解决办法，在上面，<strong>移除中间变量</strong>和<strong>消除代码分支</strong>都是可行的方法，还有一种方法就是将部分引用移到循环外面.</p>
<h4 id="引用外移"><a class="header" href="#引用外移">引用外移</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn random_empty_tile(arr: &amp;mut [Tile]) -&gt; &amp;mut Tile {
    let len = arr.len();
    let mut the_chosen_i = 0;
    loop {
        let i = rand::thread_rng().gen_range(0..len);
        let tile = &amp;mut arr[i];
        if Tile::Empty == *tile {
            the_chosen_i = i;
            break;
        }
    }
    &amp;mut arr[the_chosen_i]
}
<span class="boring">}
</span></code></pre></pre>
<p>在上面代码中，我们只在循环中保留一个可变引用，剩下的<code>arr.len</code>和返回值引用，都移到循环外面，顺利通过编译.</p>
<h2 id="一个更复杂的例子"><a class="header" href="#一个更复杂的例子">一个更复杂的例子</a></h2>
<p>再来看一个例子，代码会更复杂，但是原因几乎相同：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

enum Symbol {
    A,
}

pub struct SymbolTable {
    scopes: Vec&lt;Scope&gt;,
    current: usize,
}

struct Scope {
    parent: Option&lt;usize&gt;,
    symbols: HashMap&lt;String, Symbol&gt;,
}

impl SymbolTable {
    pub fn get_mut(&amp;mut self, name: &amp;String) -&gt; &amp;mut Symbol {
        let mut current = Some(self.current);

        while let Some(id) = current {
            let scope = self.scopes.get_mut(id).unwrap();
            if let Some(symbol) = scope.symbols.get_mut(name) {
                return symbol;
            }

            current = scope.parent;
        }

        panic!(&quot;Value not found: {}&quot;, name);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>运行后报错如下：</p>
<pre><code class="language-console">error[E0499]: cannot borrow `self.scopes` as mutable more than once at a time
  --&gt; src/main.rs:22:25
   |
18 |     pub fn get_mut(&amp;mut self, name: &amp;String) -&gt; &amp;mut Symbol {
   |                    - let's call the lifetime of this reference `'1`
...
22 |             let scope = self.scopes.get_mut(id).unwrap();
   |                         ^^^^^^^^^^^ `self.scopes` was mutably borrowed here in the previous iteration of the loop
23 |             if let Some(symbol) = scope.symbols.get_mut(name) {
24 |                 return symbol;
   |                        ------ returning this value requires that `self.scopes` is borrowed for `'1`
</code></pre>
<p>对于上述代码，只需要将返回值修改下，即可通过编译：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_mut(&amp;mut self, name: &amp;String) -&gt; &amp;mut Symbol {
    let mut current = Some(self.current);

    while let Some(id) = current {
        let scope = self.scopes.get_mut(id).unwrap();
        if scope.symbols.contains_key(name) {
            return self.scopes.get_mut(id).unwrap().symbols.get_mut(name).unwrap();
        }

        current = scope.parent;
    }

    panic!(&quot;Value not found: {}&quot;, name);
}
<span class="boring">}
</span></code></pre></pre>
<p>其中的关键就在于返回的时候，新建一个引用，而不是使用中间状态的引用。</p>
<h2 id="新编译器polonius"><a class="header" href="#新编译器polonius">新编译器Polonius</a></h2>
<p>针对现有编译器存在的各种问题，Rust团队正在研发一个全新的编译器，名曰<a href="https://github.com/rust-lang/polonius"><code>polonius</code></a>,但是目前它仍然处在开发阶段，如果想在自己项目中使用，需要在<code>rustc/RUSTFLAGS</code>中增加标志<code>-Zpolonius</code>，但是可能会导致编译速度变慢，或者引入一些新的编译错误。</p>
<h2 id="总结-21"><a class="header" href="#总结-21">总结</a></h2>
<p>编译器不是万能的，它也会迷茫，也会犯错。</p>
<p>因此我们在循环中使用引用类型时要格外小心，特别是涉及可变引用，这种情况下，最好的办法就是避免中间状态，或者在返回时避免使用中间状态。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="当闭包碰到特征对象1"><a class="header" href="#当闭包碰到特征对象1">当闭包碰到特征对象1</a></h1>
<p>特征对象是一个好东西，闭包也是一个好东西，但是如果两者你都想要时，可能就会火星撞地球，boom! 至于这两者为何会勾搭到一起？考虑一个常用场景：使用闭包作为回调函数. </p>
<h2 id="学习目标-1"><a class="header" href="#学习目标-1">学习目标</a></h2>
<p>如何使用闭包作为特征对象，并解决以下错误：<code>the parameter type </code>impl Fn(&amp;str) -&gt; Res<code> may not live long enough</code></p>
<h2 id="报错的代码"><a class="header" href="#报错的代码">报错的代码</a></h2>
<p>在下面代码中，我们通过闭包实现了一个简单的回调函数(错误代码已经标注)：</p>
<pre><pre class="playground"><code class="language-rust edition2021">pub struct Res&lt;'a&gt; {
    value: &amp;'a str,
}

impl&lt;'a&gt; Res&lt;'a&gt; {
    pub fn new(value: &amp;str) -&gt; Res {
        Res { value }
    }
}

pub struct Container&lt;'a&gt; {
    name: &amp;'a str,
    callback: Option&lt;Box&lt;dyn Fn(&amp;str) -&gt; Res&gt;&gt;,
}

impl&lt;'a&gt; Container&lt;'a&gt; {
    pub fn new(name: &amp;str) -&gt; Container {
        Container {
            name,
            callback: None,
        }
    }

    pub fn set(&amp;mut self, cb: impl Fn(&amp;str) -&gt; Res) {
        self.callback = Some(Box::new(cb));
    }
}

fn main() {
    let mut inl = Container::new(&quot;Inline&quot;);

    inl.set(|val| {
        println!(&quot;Inline: {}&quot;, val);
        Res::new(&quot;inline&quot;)
    });

    if let Some(cb) = inl.callback {
        cb(&quot;hello, world&quot;);
    }
}
</code></pre></pre>
<p>从第一感觉来说，报错属实不应该，因为我们连引用都没有用，生命周期都不涉及，怎么就报错了？在继续深入之前，先来观察下该闭包是如何被使用的：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>callback: Option&lt;Box&lt;dyn Fn(&amp;str) -&gt; Res&gt;&gt;,
<span class="boring">}
</span></code></pre></pre>
<p>众所周知，闭包跟哈姆雷特一样，每一个都有<a href="fight-with-compiler/lifetime/../../advance/functional-programing/closure.html#%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC">自己的类型</a>，因此我们无法通过类型标注的方式来声明一个闭包，那么只有一个办法，就是使用特征对象，因此上面代码中，通过<code>Box&lt;dyn Trait&gt;</code>的方式把闭包特征封装成一个特征对象。</p>
<h2 id="深入挖掘报错原因"><a class="header" href="#深入挖掘报错原因">深入挖掘报错原因</a></h2>
<p>事出诡异必有妖，那接下来我们一起去会会这只妖。</p>
<h4 id="特征对象的生命周期"><a class="header" href="#特征对象的生命周期">特征对象的生命周期</a></h4>
<p>首先编译器报错提示我们闭包活得不够久，那可以大胆推测，正因为使用了闭包作为特征对象，所以才活得不够久。因此首先需要调查下特征对象的生命周期。</p>
<p>首先给出结论：<strong>特征对象隐式的具有<code>'static</code>生命周期</strong>。</p>
<p>其实在Rust中，<code>'static</code>生命周期很常见，例如一个没有引用字段的结构体它其实也是<code>'static</code>。当<code>'static</code>用于一个类型时，该类型不能包含任何非<code>'static</code>引用字段，例如以下结构体：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    x : &amp;'a [u8]
};
<span class="boring">}
</span></code></pre></pre>
<p>除非<code>x</code>字段借用了<code>'static</code>的引用，否则<code>'a</code>肯定比<code>'static</code>要小，那么该结构体实例的生命周期肯定不是<code>'static</code>: <code>'a: 'static</code>的限制不会被满足(<a href="fight-with-compiler/lifetime/../../advance/lifetime/advance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BA%A6%E6%9D%9FHRTB">HRTB</a>)。</p>
<p>对于特征对象来说，它没有包含非<code>'static</code>的引用，因此它隐式的具有<code>'static</code>生命周期, <code>Box&lt;dyn Trait&gt;</code>就跟<code>Box&lt;dyn Trait + 'static&gt;</code>是等价的。</p>
<h4 id="static闭包的限制"><a class="header" href="#static闭包的限制">'static闭包的限制</a></h4>
<p>其实以上代码的错误很好解决，甚至编译器也提示了我们：</p>
<pre><code class="language-console">help: consider adding an explicit lifetime bound...: `impl Fn(&amp;str) -&gt; Res + 'static`
</code></pre>
<p>但是解决问题不是本文的目标，我们还是要继续深挖一下，如果闭包使用了<code>'static</code>会造成什么问题。</p>
<h5 id="1-无本地变量被捕获"><a class="header" href="#1-无本地变量被捕获">1. 无本地变量被捕获</a></h5>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>inl.set(|val| {
    println!(&quot;Inline: {}&quot;, val);
    Res::new(&quot;inline&quot;)
});
<span class="boring">}
</span></code></pre></pre>
<p>以上代码只使用了闭包中传入的参数，并没有本地变量被捕获，因此<code>'static</code>闭包一切OK。</p>
<h5 id="2-有本地变量被捕获"><a class="header" href="#2-有本地变量被捕获">2. 有本地变量被捕获</a></h5>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let local = &quot;hello&quot;.to_string();

// 编译错误： 闭包不是'static!
inl.set(|val| {
    println!(&quot;Inline: {}&quot;, val);
    println!(&quot;{}&quot;, local);
    Res::new(&quot;inline&quot;)
});
<span class="boring">}
</span></code></pre></pre>
<p>这里我们在闭包中捕获了本地环境变量<code>local</code>，因为<code>local</code>不是<code>'static</code>，那么闭包也不再是<code>'static</code>。</p>
<h5 id="3-将本地变量move进闭包"><a class="header" href="#3-将本地变量move进闭包">3. 将本地变量move进闭包</a></h5>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let local = &quot;hello&quot;.to_string();

inl.set(move |val| {
    println!(&quot;Inline: {}&quot;, val);
    println!(&quot;{}&quot;, local);
    Res::new(&quot;inline&quot;)
});

// 编译错误: local已经被移动到闭包中，这里无法再被借用
// println!(&quot;{}&quot;, local);
<span class="boring">}
</span></code></pre></pre>
<p>如上所示，你也可以选择将本地变量的所有权<code>move</code>进闭包中，此时闭包再次具有<code>'statci</code>生命周期</p>
<h5 id="4-非要捕获本地变量的引用"><a class="header" href="#4-非要捕获本地变量的引用">4. 非要捕获本地变量的引用？</a></h5>
<p>对于第2种情况，如果非要这么干，那<code>'static</code>肯定是没办法了，我们只能给予闭包一个新的生命周期:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Container&lt;'a, 'b&gt; {
    name: &amp;'a str,
    callback: Option&lt;Box&lt;dyn Fn(&amp;str) -&gt; Res + 'b&gt;&gt;,
}

impl&lt;'a, 'b&gt; Container&lt;'a, 'b&gt; {    
    pub fn new(name: &amp;str) -&gt; Container {
        Container {
            name,
            callback: None,
        }
    }

    pub fn set(&amp;mut self, cb: impl Fn(&amp;str) -&gt; Res + 'b) {
        self.callback = Some(Box::new(cb));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>肉眼可见，代码复杂度哐哐哐提升，不得不说<code>'static</code>真香！</p>
<p>友情提示：由此修改引发的一系列错误，需要你自行修复: ) (再次友情小提示，可以考虑把<code>main</code>中的<code>local</code>变量声明位置挪到<code>inl</code>声明位置之前)</p>
<h2 id="姗姗来迟的正确代码"><a class="header" href="#姗姗来迟的正确代码">姗姗来迟的正确代码</a></h2>
<p>其实，大家应该都知道该如何修改了，不过出于严谨，我们还是继续给出完整的正确代码:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn set(&amp;mut self, cb: impl Fn(&amp;str) -&gt; Res + 'static) {
<span class="boring">}
</span></code></pre></pre>
<p>可能大家觉得我重新定义了<code>完整</code>两个字，其实是我不想水篇幅:)</p>
<h2 id="总结-22"><a class="header" href="#总结-22">总结</a></h2>
<p>闭包和特征对象的相爱相杀主要原因就在于特征对象默认具备<code>'static</code>的生命周期，同时我们还对什么样的类型具备<code>'static</code>进行了简单的分析。</p>
<p>同时，如果一个闭包拥有<code>'static</code>生命周期，那闭包无法通过引用的方式来捕获本地环境中的变量。如果你想要非要捕获，只能使用非<code>'static</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="重复借用"><a class="header" href="#重复借用">重复借用</a></h1>
<p>本章讲述如何解决类似<code>cannot borrow *self as mutable because it is also borrowed as immutable</code>这种重复借用的错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="同时在函数内外使用引用导致的重复借用错误"><a class="header" href="#同时在函数内外使用引用导致的重复借用错误">同时在函数内外使用引用导致的重复借用错误</a></h1>
<p>本文将彻底解决一个困扰广大Rust用户已久的常见错误：因为在函数内外同时借用一个引用，导致了重复借用错误<code>cannot borrow *self as mutable because it is also borrowed as immutable</code>.</p>
<blockquote>
<p>本文大部分内容节选自<a href="https://www.zhihu.com/column/c_1454754106916806656">Rust陷阱系列</a>专题，由于借用是新手绕不过去的坎，因此将其提取出来形成一个新的系列</p>
</blockquote>
<h2 id="正确的代码"><a class="header" href="#正确的代码">正确的代码</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Test {
    a : u32,
    b : u32
}

impl Test {
    fn increase(&amp;mut self) {
        let mut a = &amp;mut self.a;
        let mut b = &amp;mut self.b;
        *b += 1;
        *a += 1;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这段代码是可以正常编译的，也许有读者会有疑问，<code>self</code>在这里被两个变量以可变的方式借用了，明明违反了Rust的所有权规则，为何它不会报错？</p>
<p>答案要从很久很久之前开始(啊哒~~~由于我太啰嗦，被正义群众来了一下，那咱现在开始长话短说，直接进入主题)。</p>
<h4 id="正确代码为何不报错"><a class="header" href="#正确代码为何不报错">正确代码为何不报错？</a></h4>
<p>虽然从表面来看，<code>a</code>和<code>b</code>都可变引用了<code>self</code>，但是Rust的编译器在很多时候都足够聪明，它发现我们其实仅仅引用了同一个结构体中的不同字段，因此完全可以将其的借用权分离开来。</p>
<p>因此，虽然我们不能同时对整个结构体进行可变引用，但是我们可以分别对结构体中的不同字段进行可变引用，当然，一个字段至多也只能存在一个可变引用，这个最基本的所有权规则还是不能违反的。变量<code>a</code>引用结构体字段<code>a</code>，变量<code>b</code>引用结构体字段<code>b</code>，从底层来说，这种方式也不会造成两个可变引用指向了同一块内存。</p>
<p>至此，正确代码我们已经挖掘完毕，再来看看重构后的错误代码。</p>
<h2 id="重构后的错误代码"><a class="header" href="#重构后的错误代码">重构后的错误代码</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Test {
    a : u32,
    b : u32
}

impl Test {

    fn increase_a (&amp;mut self) {
        self.a += 1;
    }

    fn increase(&amp;mut self) {
        let b = &amp;mut self.b;
        self.increase_a();
        *b += 1;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>果然不正义的代码就是不好看，但是邪恶的它更强了吗？</p>
<pre><code class="language-console">error[E0499]: cannot borrow `*self` as mutable more than once at a time
  --&gt; src/main.rs:14:9
   |
13 |         let b = &amp;mut self.b;
   |                 ----------- first mutable borrow occurs here
14 |         self.increase_a();
   |         ^^^^ second mutable borrow occurs here
15 |         *b += 1;
   |         ------- first borrow later used here
</code></pre>
<p>嗯，最开始提到的错误，它终于出现了。</p>
<h2 id="大聪明编译器"><a class="header" href="#大聪明编译器">大聪明编译器</a></h2>
<p>为什么？明明之前还是正确的代码，就因为放入函数中就报错了？我们先从一个简单的理解谈起，当然这个理解也是浮于表面的，等会会深入分析真实的原因。</p>
<p>之前讲到Rust编译器挺聪明，可以识别到引用到不同的结构体字段，因此不会报错。但是现在这种情况下，编译器又不够聪明了，一旦放入函数中，编译器将无法理解我们对<code>self</code>的使用：它仅仅用到了一个字段，而不是整个结构体。 </p>
<p>因此它会简单的认为，这个结构体作为一个整体被可变借用了，产生两个可变引用，一个引用整个结构体，一个引用了结构体字段<code>b</code>，这两个引用存在重叠的部分，最终导致编译错误。</p>
<h2 id="被冤枉的编译器"><a class="header" href="#被冤枉的编译器">被冤枉的编译器</a></h2>
<p>在工作生活中，我们无法理解甚至错误的理解一件事，有时是因为层次不够导致的。同样，对于本文来说，也是因为我们对编译器的所知不够，才冤枉了它，还给它起了一个屈辱的“大聪明”外号。</p>
<h4 id="深入分析"><a class="header" href="#深入分析">深入分析</a></h4>
<blockquote>
<p>如果只改变相关函数的实现而不改变它的签名，那么不会影响编译的结果</p>
</blockquote>
<p>何为相关函数？当函数<code>a</code>调用了函数<code>b</code>，那么<code>b</code>就是<code>a</code>的相关函数。</p>
<p>上面这句是一条非常重要的编译准则，意思是，对于编译器来说，只要函数签名没有变，那么任何函数实现的修改都不会影响已有的编译结果(前提是函数实现没有错误- , -)。</p>
<p>以前面的代码为例：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn increase_a (&amp;mut self) {
    self.a += 1;
}

fn increase(&amp;mut self) {
    let b = &amp;mut self.b;
    self.increase_a();
    *b += 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>虽然<code>increase_a</code>在函数实现中没有访问<code>self.b</code>字段，但是它的签名允许它访问<code>b</code>，因此违背了借用规则。事实上，该函数有没有访问<code>b</code>不重要，<strong>因为编译器在这里只关心签名，签名存在可能性，那么就立刻报出错误</strong>。</p>
<p>为何会有这种编译器行为，主要有两个原因：</p>
<ol>
<li>一般来说，我们希望编译器有能力独立的编译每个函数，而无需深入到相关函数的内部实现，因为这样做会带来快得多的编译速度。</li>
<li>如果没有这种保证，那么在实际项目开发中，我们会特别容易遇到各种错误。 假设我们要求编译器不仅仅关注相关函数的签名，还要深入其内部关注实现，那么由于Rust严苛的编译规则，当你修改了某个函数内部实现的代码后，可能会引起使用该函数的其它函数的各种错误！对于大型项目来说，这几乎是不可接受的！</li>
</ol>
<p>然后，我们的借用类型这么简单，编译器有没有可能针对这种场景，在现有的借用规则之外增加特殊规则？答案是否定的，由于Rust语言的设计哲学：特殊规则的加入需要慎之又慎，而我们的这种情况其实还蛮好解决的，因此编译器不会为此新增规则。</p>
<h2 id="解决办法"><a class="header" href="#解决办法">解决办法</a></h2>
<p>在深入分析中，我们提到一条重要的规则，要影响编译行为，就需要更改相关函数的签名，因此可以修改<code>increate_a</code>的签名:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn increase_a (a :&amp;mut u32) {
    *a += 1;
}

fn increase(&amp;mut self) {
    let b = &amp;mut self.b;
    Test::increase_a(&amp;mut self.a);
    *b += 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>此时，<code>increase_a</code>这个相关函数，不再使用<code>&amp;mut self</code>作为签名，而是获取了结构体中的字段<code>a</code>，此时编译器又可以清晰的知道：函数<code>increase_a</code>和变量<code>b</code>分别引用了结构体中的不同字段，因此可以编译通过。</p>
<p>当然，除了修改相关函数的签名，你还可以修改调用者的实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn increase(&amp;mut self) {
    self.increase_a();
    self.b += 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>在这里，我们不再单独声明变量<code>b</code>，而是直接调用<code>self.b+=1</code>进行递增，根据借用生命周期<a href="https://course.rs/advance/lifetime/advance.html#nllnon-lexical-lifetime">NLL</a>的规则，第一个可变借用<code>self.increase_a()</code>的生命周期随着方法调用的结束而结束，那么就不会影响<code>self.b += 1</code>中的借用。</p>
<h2 id="cpu模拟例子"><a class="header" href="#cpu模拟例子">CPU模拟例子</a></h2>
<p>我们再来看一个例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::HashMap;

struct Cpu {
    pc: u16,
    cycles: u32,
    opcodes: HashMap&lt;u8, Opcode&gt;,
}

struct Opcode {
    size: u16,
    cycles: u32,
}

impl Cpu {
    fn new() -&gt; Cpu {
        Cpu {
            pc: 0,
            cycles: 0,
            opcodes: HashMap::from([
                (0x00, Opcode::new(1, 7)),
                (0x01, Opcode::new(2, 6))
            ]),
        }
    }

    fn tick(&amp;mut self) {
        let address = self.pc as u8;
        let opcode = &amp;self.opcodes[&amp;address];
        
        step(&amp;mut self, opcode);
    }


}

fn step(cpu : &amp;mut Cpu, opcode: &amp;Opcode) {
   
}

impl Opcode {
    fn new(size: u16, cycles: u32) -&gt; Opcode {
        Opcode { size, cycles }
    }
}

fn main() {
    let mut cpu = Cpu::new();
    cpu.tick();
}
</code></pre></pre>
<h2 id="总结-23"><a class="header" href="#总结-23">总结</a></h2>
<p>知其然知其所以然，要彻底解决借用导致的编译错误，我们就必须深入了解其原理，心中有剑则手中无&quot;贱&quot;。 </p>
<p>上面的例子就留给读者朋友自己去解决，相信你以后在遇到这种常见问题时，会更加游刃有余。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="智能指针引起的重复借用错误"><a class="header" href="#智能指针引起的重复借用错误">智能指针引起的重复借用错误</a></h1>
<p>本文将彻底解决一个困扰广大Rust用户已久的常见错误： 当智能指针和结构体一起使用时导致的借用错误: <code>cannot borrow</code>mut_s<code> as mutable because it is also borrowed as immutable</code>.</p>
<p>相信看过<a href="https://www.zhihu.com/column/c_1461712984854335488">&lt;&lt;对抗Rust编译检查系列&gt;&gt;</a>的读者都知道结构体中的不同字段可以独立借用吧？</p>
<h2 id="结构体中的字段借用"><a class="header" href="#结构体中的字段借用">结构体中的字段借用</a></h2>
<p>不知道也没关系，我们这里再简单回顾一下:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Test {
    a : u32,
    b : u32
}

impl Test {
    fn increase(&amp;mut self) {
        let mut a = &amp;mut self.a;
        let mut b = &amp;mut self.b;
        *b += 1;
        *a += 1;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这段代码看上去像是重复借用了<code>&amp;mut self</code>,违反了Rust的借用规则，实际上在聪明的Rust编译器面前，这都不是事。它能发现我们其实借用了目标结构体的不同字段，因此完全可以将其借用权分离开来。</p>
<p>因此，虽然我们不能同时对整个结构体进行多次可变借用，但是我们可以分别对结构体中的不同字段进行可变借用，当然，一个字段至多也只能存在一个可变借用，这个最基本的所有权规则还是不能违反的。变量<code>a</code>引用结构体字段<code>a</code>，变量<code>b</code>引用结构体字段<code>b</code>，从底层来说，这种方式也不会造成两个可变引用指向了同一块内存。</p>
<h2 id="refcell-1"><a class="header" href="#refcell-1">RefCell</a></h2>
<p>如果你还不知道RefCell，可以看看<a href="https://zhuanlan.zhihu.com/p/453727091">这篇文章</a>，当然不看也行，简而言之，RefCell能够实现：</p>
<ul>
<li>将借用规则从编译期推迟到运行期，但是并不会饶过借用规则，当不符合时，程序直接<code>panic</code></li>
<li>实现内部可变性：简单来说，对一个不可变的值进行可变借用，然后修改内部的值</li>
</ul>
<h2 id="被refcell包裹的结构体"><a class="header" href="#被refcell包裹的结构体">被RefCell包裹的结构体</a></h2>
<p>既然了解了结构体的借用规则和<code>RefCell</code>, 我们来看一段结合了两者的代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use std::io::Write;

struct Data {
    string: String,
}

struct S {
    data: Data,
    writer: Vec&lt;u8&gt;,
}

fn write(s: RefCell&lt;S&gt;) {
    let mut mut_s = s.borrow_mut();
    let str = &amp;mut_s.data.string;
    mut_s.writer.write(str.as_bytes());
}
<span class="boring">}
</span></code></pre></pre>
<p>以上代码从<code>s</code>中可变借用出结构体<code>S</code>，随后又对结构体中的两个字段进行了分别借用，按照之前的规则这段代码应该顺利通过编译：</p>
<pre><code class="language-console">error[E0502]: cannot borrow `mut_s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:16:5
   |
15 |     let str = &amp;mut_s.data.string;
   |                ----- immutable borrow occurs here
16 |     mut_s.writer.write(str.as_bytes());
   |     ^^^^^              --- immutable borrow later used here
   |     |
   |     mutable borrow occurs here
</code></pre>
<p>只能说，还好它报错了，否则本篇文章已经可以结束。。。错误很简单，首先对结构体<code>S</code>的<code>data</code>字段进行了不可变借用，其次又对<code>writer</code>字段进行了可变借用，这个符合之前的规则：对结构体不同字段分开借用，为何报错了？</p>
<h2 id="深入分析-1"><a class="header" href="#深入分析-1">深入分析</a></h2>
<p>第一感觉，问题是出在<code>borrow_mut</code>方法返回的类型上，先来看看:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn borrow_mut(&amp;self) -&gt; RefMut&lt;'_, T&gt;
<span class="boring">}
</span></code></pre></pre>
<p>可以看出，该方法并没有直接返回我们的结构体，而是一个<code>RefMut</code>类型，而要使用该类型，需要经过编译器为我们做一次隐式的<code>Deref</code>转换，编译器展开后的代码大概如下:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefMut;
use std::ops::{Deref, DerefMut};

fn write(s: RefCell&lt;S&gt;) {
    let mut mut_s: RefMut&lt;S&gt; = s.borrow_mut();
    let str = &amp;Deref::deref(&amp;mut_s).data.string;
    DerefMut::deref_mut(&amp;mut mut_s).writer.write(str.as_bytes());
}
<span class="boring">}
</span></code></pre></pre>
<p>可以看出，对结构体字段的调用，实际上经过一层函数，一层函数！？我相信你应该想起了什么，是的，在<a href="https://zhuanlan.zhihu.com/p/451920390/edit">上一篇文章</a>中讲过类似的问题， 大意就是<strong>编译器对于函数往往只会分析签名，并不关心内部到底如何使用结构体</strong>。</p>
<p>而上面的<code>&amp;Deref::deref(&amp;mut_s)</code>和<code>DerefMut::deref_mut(&amp;mut mut_s)</code>函数，签名全部使用的是结构体，并不是结构体中的某一个字段，因此对于编译器来说，该结构体明显是被重复借用了！</p>
<h2 id="解决方法-1"><a class="header" href="#解决方法-1">解决方法</a></h2>
<p>因此要解决这个问题，我们得把之前的展开形式中的<code>Deref::deref</code>消除掉，这样没有了函数签名，编译器也将不再懒政。</p>
<p>既然两次<code>Deref::deref</code>调用都是对智能指针的自动<code>Deref</code>，那么可以提前手动的把它<code>Deref</code>了，只做一次！</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn write(s: RefCell&lt;S&gt;) {
    let mut mut_s = s.borrow_mut();
    let mut tmp = &amp;mut *mut_s; // Here
    let str = &amp;tmp.data.string;
    tmp.writer.write(str.as_bytes());
}
<span class="boring">}
</span></code></pre></pre>
<p>以上代码通过<code>*</code>对<code>mut_s</code>进行了解引用，获得结构体，然后又对结构体进行了可变借用<code>&amp;mut</code>，最终赋予<code>tmp</code>变量，那么该变量就持有了我们的结构体的可变引用，而不再是持有一个智能指针。</p>
<p>此后对<code>tmp</code>的使用就回归到文章开头的那段代码：分别借用结构体的不同字段，成功通过编译！</p>
<h4 id="展开代码"><a class="header" href="#展开代码">展开代码</a></h4>
<p>我们再来模拟编译器对正确的代码进行一次展开:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefMut;
use std::ops::DerefMut;

fn write(s: RefCell&lt;S&gt;) {
    let mut mut_s: RefMut&lt;S&gt; = s.borrow_mut();
    let tmp: &amp;mut S = DerefMut::deref_mut(&amp;mut mut_s);
    let str = &amp;tmp.data.string;
    tmp.writer.write(str.as_bytes());
}
<span class="boring">}
</span></code></pre></pre>
<p>可以看出，此时对结构体的使用不再有<code>DerefMut::deref</code>的身影，我们成功消除了函数边界对编译器的影响！</p>
<h2 id="不仅仅是refcell"><a class="header" href="#不仅仅是refcell">不仅仅是RefCell</a></h2>
<p>事实上，除了RefCell外，还有不少会导致这种问题的智能指针，当然原理都是互通的，我们这里就不再进行一一深入讲解，只简单列举下：</p>
<ul>
<li><code>Box</code></li>
<li><code>MutexGuard</code>(来源于Mutex)</li>
<li><code>PeekMut</code>(来源于BinaryHeap)</li>
<li><code>RwLockWriteGuard</code>(来源于RwLock)</li>
<li><code>String</code></li>
<li><code>Vec</code></li>
<li><code>Pin</code></li>
</ul>
<h2 id="一个练习"><a class="header" href="#一个练习">一个练习</a></h2>
<p>下面再来一个练习巩固一下，强烈建议大家按照文章的思路进行分析和解决：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::rc::Rc;
use std::cell::RefCell;

pub struct Foo {
    pub foo1: Vec&lt;bool&gt;,
    pub foo2: Vec&lt;i32&gt;,
}
fn main() {
    let foo_cell = Rc::new(RefCell::new(Foo {
        foo1: vec![true, false],
        foo2: vec![1, 2]
        
    }));
 
    let borrow = foo_cell.borrow_mut();
    let foo1 = &amp;borrow.foo1;
    // 下面代码会报错,因为`foo1`和`foo2`发生了重复借用
    borrow.foo2.iter_mut().enumerate().for_each(|(idx, foo2)| {
        if foo1[idx] {
            *foo2 *= -1;
        }
    });
}
</code></pre></pre>
<h2 id="总结-24"><a class="header" href="#总结-24">总结</a></h2>
<p>当结构体的引用穿越函数边界时，我们要格外小心，因为编译器只会对函数签名进行检查，并不关心内部到底用了结构体的哪个字段，当签名都使用了结构体时，会立即报错。</p>
<p>而智能指针由于隐式解引用<code>Deref</code>的存在，导致了两次<code>Deref</code>时都让结构体穿越了函数边界<code>Deref::deref</code>，结果造成了重复借用的错误。</p>
<p>解决办法就是提前对智能指针进行手动解引用，然后对内部的值进行借用后，再行使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型未限制"><a class="header" href="#类型未限制">类型未限制</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust陷阱系列"><a class="header" href="#rust陷阱系列">Rust陷阱系列</a></h1>
<p>本章收录一些Rust常见的陷阱，一不小心就会坑你的那种(当然，这不是Rust语言的问题，而是一些边边角角知识点)。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for循环中使用外部数组"><a class="header" href="#for循环中使用外部数组">for循环中使用外部数组</a></h1>
<p>一般来说，<code>for</code>循环能做到的，<code>while</code>也可以，反之亦然，但是有一种情况，还真不行，先来看代码:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1,2,3];

for i in 0..v.len() {
    v.push(i);
    println!(&quot;{:?}&quot;,v);
}
<span class="boring">}
</span></code></pre></pre>
<p>我们的目的是创建一个无限增长的数组，往里面插入<code>0..</code>(看不懂该表达式的同学请查阅https://course.rs)的数值序列。</p>
<p>看起来上面代码可以完成，因为随着数组不停增长，<code>v.len()</code>也会不停变大，但是事实上真的如此吗？</p>
<pre><code class="language-console">[1, 2, 3, 0]
[1, 2, 3, 0, 1]
[1, 2, 3, 0, 1, 2]
</code></pre>
<p>输出很清晰的表明，只新插入了三个元素：<code>0..=2</code>，刚好是<code>v</code>的初始长度。</p>
<p>这是因为：<strong>在for循环中,<code>v.len</code>只会在循环伊始之时进行求值，之后就一直使用该值</strong>。</p>
<p>行，问题算是清楚了，那该如何解决呢，我们可以使用<code>while</code>循环，该循环与<code>for</code>相反，每次都会重新求值：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1,2,3];

let mut i = 0;
while i &lt; v.len() {
    v.push(i);
    i+=1;
    println!(&quot;{:?}&quot;,v);
}
<span class="boring">}
</span></code></pre></pre>
<p>友情提示，在你运行上述代码时，千万要及时停止，否则会<code>Boom</code> - 炸翻控制台。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线程类型导致的栈溢出"><a class="header" href="#线程类型导致的栈溢出">线程类型导致的栈溢出</a></h1>
<p>在Rust中，我们不太容易遇到栈溢出，因为默认栈还挺大的，而且大的数据往往存在堆上(动态增长)，但是一旦遇到该如何处理？先来看段代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span>#![feature(test)]
<span class="boring">fn main() {
</span>extern crate test;

#[cfg(test)]
mod tests {
    use test::Bencher;

    #[bench]
    fn it_works(b: &amp;mut Bencher) {
        b.iter(|| { let stack = [[[0.0; 2]; 512]; 512]; });
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>以上代码是一个测试模块，它在堆上生成了一个数组<code>stack</code>，初步看起来数组挺大的，先尝试运行下<code>cargo test</code>:</p>
<blockquote>
<p>你很可能会遇到<code>#![feature(test)]</code>错误，因为该特性目前只存在<code>Rust Nightly</code>版本上，具体解决方法见<a href="https://course.rs/appendix/rust-version.html#%E5%9C%A8%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E4%BD%BF%E7%94%A8rust-nightly">Rust语言圣经</a></p>
</blockquote>
<pre><code class="language-console">running 1 test

thread 'tests::it_works' has overflowed its stack
fatal runtime error: stack overflow
</code></pre>
<p>Bang，很不幸，遇到了百年一遇的栈溢出错误，再来试试<code>cargo bench</code>，竟然通过了测试，这是什么原因？为何<code>cargo test</code>和<code>cargo bench</code>拥有完全不同的行为？这就要从Rust的栈原理讲起。</p>
<p>首先看看<code>stack</code>数组，它的大小是<code>8 × 2 × 512 × 512 = 4 MiB</code>，嗯，很大，崩溃也正常(读者说，正常，只是作者你不太正常。。).</p>
<p>其次，<code>cargo test</code>和<code>cargo bench</code>，前者运行在一个新创建的线程上，而后者运行在<strong>main线程上</strong>.</p>
<p>最后，<code>main</code>线程由于是老大，所以资源比较多，拥有令其它兄弟艳羡不已的<code>8MB</code>栈大小，而其它新线程只有区区<code>2MB</code>栈大小(取决于操作系统,<code>linux</code>是<code>2MB</code>,其它的可能更小)，再对比我们的<code>stack</code>大小，不崩溃就奇怪了。</p>
<p>因此，你现在明白，为何<code>cargo test</code>不能运行，而<code>cargo bench</code>却可以欢快运行。</p>
<p>如果实在想要增大栈的默认大小，以通过该测试，你可以这样运行:<code>RUST_MIN_STACK=8388608 cargo test</code>,结果如下：</p>
<pre><code class="language-console">running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Bingo, 成功了,最后再补充点测试的背景知识:</p>
<blockquote>
<p>cargo test为何使用新线程？因为它需要并行的运行测试用例，与之相反，cargo bench只需要顺序的执行，因此main线程足矣</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="算术溢出导致的panic"><a class="header" href="#算术溢出导致的panic">算术溢出导致的panic</a></h1>
<p>在Rust中，溢出后的数值被截断是很正常的:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u16 = 65535;
let v = x as u8;
println!(&quot;{}&quot;, v)
<span class="boring">}
</span></code></pre></pre>
<p>最终程序会输出<code>255</code>, 因此大家可能会下意识地就觉得算数操作在Rust中只会导致结果的不正确，并不会导致异常。但是实际上，如果是因为算术操作符导致的溢出，就会让整个程序panic:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x: u8 = 10;

    let v = x + u8::MAX;
    println!(&quot;{}&quot;, v)
}
</code></pre></pre>
<p>输出结果如下:</p>
<pre><code class="language-console">thread 'main' panicked at 'attempt to add with overflow', src/main.rs:5:13
</code></pre>
<p>那么当我们确实有这种需求时，该如何做呢？可以使用Rust提供的<code>checked_xxx</code>系列方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x: u8 = 10;

    let v = x.checked_add(u8::MAX).unwrap_or(0);
    println!(&quot;{}&quot;, v)
}
</code></pre></pre>
<p>也许你会觉得本章内容其实算不上什么陷阱，但是在实际项目快速迭代中，越是不起眼的地方越是容易出错：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let v = production_rate_per_hour(5);
    println!(&quot;{}&quot;, v);
}

pub fn production_rate_per_hour(speed: u8) -&gt; f64 {
    let cph: u8 = 221;
    match speed {
        1..=4 =&gt; (speed * cph) as f64,
        5..=8 =&gt; (speed * cph) as f64 * 0.9,
        9..=10 =&gt; (speed * cph) as f64 * 0.77,
        _ =&gt; 0 as f64,
    }
}

pub fn working_items_per_minute(speed: u8) -&gt; u32 {
    (production_rate_per_hour(speed) / 60 as f64) as u32
}
</code></pre></pre>
<p>上述代码中，<code>speed * cph</code>就会直接panic:</p>
<pre><code class="language-console">thread 'main' panicked at 'attempt to multiply with overflow', src/main.rs:10:18
</code></pre>
<p>是不是还藏的挺隐蔽的？因此大家在Rust中做数学运算时，要多留一个心眼，免得上了生产才发现问题所在。或者，你也可以做好单元测试:)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="闭包上奇怪的生命周期"><a class="header" href="#闭包上奇怪的生命周期">闭包上奇怪的生命周期</a></h1>
<p>Rust一道独特的靓丽风景就是生命周期，也是反复折磨新手的最大黑手，就连老手，可能一不注意就会遇到一些生命周期上的陷阱，例如闭包上使用引用。</p>
<h2 id="一段简单的代码"><a class="header" href="#一段简单的代码">一段简单的代码</a></h2>
<p>先来看一段简单的代码:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fn_elision(x: &amp;i32) -&gt; &amp;i32 { x } 
let closure_slision = |x: &amp;i32| -&gt; &amp;i32 { x };
<span class="boring">}
</span></code></pre></pre>
<p>乍一看，这段代码比古天乐还平平无奇，能有什么问题呢？来，走两圈试试：</p>
<pre><code class="language-console">error: lifetime may not live long enough 
  --&gt; src/main.rs:39:39
   |
39 |     let closure = |x: &amp;i32| -&gt; &amp;i32 { x }; // fails
   |                       -        -      ^ returning this value requires that `'1` must outlive `'2`
   |                       |        |
   |                       |        let's call the lifetime of this reference `'2`
   |                       let's call the lifetime of this reference `'1`
</code></pre>
<p>咦？竟然报错了，明明两个一模一样功能的函数，一个正常编译，一个却报错，错误原因是编译器无法推测返回的引用和传入的引用谁活得更久！</p>
<p>真的是非常奇怪的错误，学过<a href="https://github.com/sunface/rust-course/blob/main/src/advance/lifetime/basic.md">Rust生命周期</a>的读者应该都记得这样一条生命周期消除规则: <strong>如果函数参数中只有一个引用类型，那该引用的生命周期会被自动分配给所有的返回引用</strong>。我们当前的情况完美符合，<code>function</code>函数的顺利编译通过，就充分说明了问题。</p>
<p>那为何闭包就出问题了？</p>
<h2 id="一段复杂的代码"><a class="header" href="#一段复杂的代码">一段复杂的代码</a></h2>
<p>为了验证闭包无法应用生命周期消除规则，再来看一个复杂一些的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::marker::PhantomData;

trait Parser&lt;'a&gt;: Sized + Copy {
    fn parse(&amp;self, tail: &amp;'a str) -&gt; &amp;'a str {
        tail
    }
    fn wrap(self) -&gt; Wrapper&lt;'a, Self&gt; {
        Wrapper {
            parser: self,
            marker: PhantomData,
        }
    }
}

#[derive(Copy, Clone)]
struct T&lt;'x&gt; {
    int: &amp;'x i32,
}

impl&lt;'a, 'x&gt; Parser&lt;'a&gt; for T&lt;'x&gt; {}

struct Wrapper&lt;'a, P&gt;
where
    P: Parser&lt;'a&gt;,
{
    parser: P,
    marker: PhantomData&lt;&amp;'a ()&gt;,
}

fn main() {
    // Error.
    let closure_wrap = |parser: T| parser.wrap();

    // No error.
    fn parser_wrap(parser: T&lt;'_&gt;) -&gt; Wrapper&lt;'_, T&lt;'_&gt;&gt; {
        parser.wrap()
    }
}
</code></pre></pre>
<p>该例子之所以这么复杂，纯粹是为了证明闭包上生命周期会失效，读者大大轻拍:) 编译后，不出所料的报错了：</p>
<pre><code class="language-console">error: lifetime may not live long enough
  --&gt; src/main.rs:32:36
   |
32 |     let closure_wrap = |parser: T| parser.wrap();
   |                         ------   - ^^^^^^^^^^^^^ returning this value requires that `'1` must outlive `'2`
   |                         |        |
   |                         |        return type of closure is Wrapper&lt;'_, T&lt;'2&gt;&gt;
   |                         has type `T&lt;'1&gt;`
</code></pre>
<h2 id="深入调查"><a class="header" href="#深入调查">深入调查</a></h2>
<p>一模一样的报错，说明在这种情况下，生命周期的消除规则也没有生效，看来事情确实不简单，我眉头一皱，决定深入调查，最后还真翻到了一些讨论，经过整理后，大概分享给大家。</p>
<p>首先给出一个结论：<strong>这个问题，可能很难被解决，建议大家遇到后，还是老老实实用正常的函数，不要秀闭包了</strong>。</p>
<p>对于函数的生命周期而言，它的消除规则之所以能生效是因为它的生命周期完全体现在签名的引用类型上，在函数体中无需任何体现:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fn_elision(x: &amp;i32) -&gt; &amp;i32 {..}
<span class="boring">}
</span></code></pre></pre>
<p>因此编译器可以做各种编译优化，也很容易根据参数和返回值进行生命周期的分析，最终得出消除规则。</p>
<p>可是闭包，并没有函数那么简单，它的生命周期分散在参数和闭包函数体中(主要是它没有确切的返回值签名)：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let closure_slision = |x: &amp;i32| -&gt; &amp;i32 { x };
<span class="boring">}
</span></code></pre></pre>
<p>编译器就必须深入到闭包函数体中，去分析和推测生命周期，复杂度因此极具提升：试想一下，编译器该如何从复杂的上下文中分析出参数引用的生命周期和闭包体中生命周期的关系？</p>
<p>由于上述原因(当然，实际情况复杂的多)，Rust语言开发者其实目前是有意为之，针对函数和闭包实现了两种不同的生命周期消除规则。</p>
<h2 id="总结-25"><a class="header" href="#总结-25">总结</a></h2>
<p>虽然我言之凿凿，闭包的生命周期无法解决，但是未来谁又知道呢。最大的可能性就是之前开头那种简单的场景，可以被自动识别和消除。</p>
<p>总之，如果有这种需求，还是像古天乐一样做一个平平无奇的男人，老老实实使用函数吧.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="失效的可变性"><a class="header" href="#失效的可变性">失效的可变性</a></h1>
<p>众所周知Rust是一门安全性非常强的系统级语言，其中，显式的设置变量可变性，是安全性的重要组成部分。按理来说，变量可变不可变在设置时就已经决定了，但是你遇到过可变变量在某些情况失效，变成不可变吗？</p>
<p>先来看段正确的代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct A {
    f1: u32,
    f2: u32,
    f3: u32
}

#[derive(Debug)]
struct B&lt;'a&gt; {
    f1: u32,
    a: &amp;'a mut A,
}

fn main() {
    let mut a: A = A{ f1: 0, f2: 1, f3: 2 };
    // b不可变
    let b: B = B{ f1: 3, a: &amp;mut a };
    // 但是b中的字段a可以变
    b.a.f1 += 1;
    
    println!(&quot;b is {:?} &quot;, &amp;b);
}
</code></pre></pre>
<p>在这里，虽然变量<code>b</code>被设置为不可变，但是<code>b</code>的其中一个字段<code>a</code>被设置为可变的结构体，因此我们可以通过<code>b.a.f1 += 1</code>来修改<code>a</code>的值。</p>
<p>也许有人还不知道这种部分可变性的存在，不过没关系，因为马上就不可变了：) </p>
<ul>
<li>结构体可变时，里面的字段都是可变的，例如<code>&amp;mut a</code></li>
<li>结构体不可变时，里面的某个字段可以单独设置为可变，例如<code>b.a</code></li>
</ul>
<p>在理解了上面两条简单规则后，来看看下面这段代码:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct A {
    f1: u32,
    f2: u32,
    f3: u32
}

#[derive(Debug)]
struct B&lt;'a&gt; {
    f1: u32,
    a: &amp;'a mut A,
}


impl B&lt;'_&gt; {
    // this will not work
    pub fn changeme(&amp;self) {
        self.a.f1 += 1;
    }
}

fn main() {
    let mut a: A = A{ f1: 0, f2: 1, f3: 2 };
    // b is immutable
    let b: B = B{ f1: 3, a: &amp;mut a };
    b.changeme();
    
    println!(&quot;b is {:?} &quot;, &amp;b);
}
</code></pre></pre>
<p>这段代码，仅仅做了一个小改变，不再直接修改<code>b.a</code>，而是通过调用<code>b</code>上的方法去修改其中的<code>a</code>，按理说不会有任何区别。因此我预言：通过方法调用跟直接调用不应该有任何区别，运行验证下：</p>
<pre><code class="language-console">error[E0594]: cannot assign to `self.a.f1`, which is behind a `&amp;` reference
  --&gt; src/main.rs:18:9
   |
17 |     pub fn changeme(&amp;self) {
   |                     ----- help: consider changing this to be a mutable reference: `&amp;mut self`
18 |         self.a.f1 += 1;
   |         ^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be written
</code></pre>
<p>啪，又被打脸了。我说我是大意了，没有闪，大家信不？反正马先生应该是信的:D</p>
<h2 id="简单分析"><a class="header" href="#简单分析">简单分析</a></h2>
<p>观察第一个例子，我们调用的<code>b.a</code>实际上是用<code>b</code>的值直接调用的，在这种情况下，由于所有权规则，编译器可以认定，只有一个可变引用指向了<code>a</code>，因此这种使用是非常安全的。</p>
<p>但是，在第二个例子中，<code>b</code>被藏在了<code>&amp;</code>后面，根据所有权规则，同时可能存在多个<code>b</code>的借用，那么就意味着可能会存在多个可变引用指向<code>a</code>,因此编译器就拒绝了这段代码。</p>
<p>事实上如果你将第一段代码的调用改成:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b: &amp;B = &amp;B{ f1: 3, a: &amp;mut a };
b.a.f1 += 1;
<span class="boring">}
</span></code></pre></pre>
<p>一样会报错！</p>
<h2 id="一个练习-1"><a class="header" href="#一个练习-1">一个练习</a></h2>
<p>结束之前再来一个练习，稍微有点绕，大家品味品味：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct A {
    f1: u32,
    f2: u32,
    f3: u32
}

#[derive(Debug)]
struct B&lt;'a&gt; {
    f1: u32,
    a: &amp;'a mut A,
}

fn main() {
    let mut a: A = A{ f1: 0, f2: 1, f3: 2 };
    let b: B = B{ f1: 3, a: &amp;mut a };
    b.a.f1 += 1;
    a.f1 = 10;
    
    println!(&quot;b is {:?} &quot;, &amp;b);
}
</code></pre></pre>
<p>小提示：这里<code>b.a.f1 += 1</code>和<code>a.f1 = 10</code>只能有一个存在，否则就会报错。</p>
<h2 id="总结-26"><a class="header" href="#总结-26">总结</a></h2>
<p>根据之前的观察和上面的小提示，可以得出一个结论：<strong>可变性的真正含义是你对目标对象的独占修改权</strong>。在实际项目中，偶尔会遇到比上述代码更复杂的可变性情况，记住这个结论，有助于我们拨云见日，直达本质。</p>
<p>学习，就是不断接近和认识事物本质的过程，对于Rust语言的学习亦是如此。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码重构导致的可变借用错误"><a class="header" href="#代码重构导致的可变借用错误">代码重构导致的可变借用错误</a></h1>
<p>相信大家都听说过<strong>重构一时爽，一直重构一直爽</strong>的说法，私以为这种说法是很有道理的，不然技术团队绩效从何而来？但是，在Rust中，重构可能就不是那么爽快的事了，不信？咱们来看看。</p>
<h2 id="欣赏下报错"><a class="header" href="#欣赏下报错">欣赏下报错</a></h2>
<p>很多时候，错误也是一种美，但是当这种错误每天都能见到时(呕):</p>
<pre><code class="language-css">error[E0499]: cannot borrow `*self` as mutable more than once at a time
</code></pre>
<p>虽然这一类错误长得一样，但是我这里的错误可能并不是大家常遇到的那些妖艳错误，废话不多说，一起来看看。</p>
<h2 id="重构前的正确代码"><a class="header" href="#重构前的正确代码">重构前的正确代码</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Test {
    a : u32,
    b : u32
}

impl Test {
    fn increase(&amp;mut self) {
        let mut a = &amp;mut self.a;
        let mut b = &amp;mut self.b;
        *b += 1;
        *a += 1;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这段代码是可以正常编译的，也许有读者会有疑问，<code>self</code>在这里被两个变量以可变的方式借用了，明明违反了Rust的所有权规则，为何它不会报错？</p>
<p>答案要从很久很久之前开始(啊哒~~~由于我太啰嗦，被正义群众来了一下，那咱现在开始长话短说，直接进入主题)。</p>
<h4 id="正确代码为何不报错-1"><a class="header" href="#正确代码为何不报错-1">正确代码为何不报错？</a></h4>
<p>虽然从表面来看，<code>a</code>和<code>b</code>都可变引用了<code>self</code>，但是Rust的编译器在很多时候都足够聪明，它发现我们其实仅仅引用了同一个结构体中的不同字段，因此完全可以将其的借用权分离开来。</p>
<p>因此，虽然我们不能同时对整个结构体进行可变引用，但是我们可以分别对结构体中的不同字段进行可变引用，当然，一个字段至多也只能存在一个可变引用，这个最基本的所有权规则还是不能违反的。变量<code>a</code>引用结构体字段<code>a</code>，变量<code>b</code>引用结构体字段<code>b</code>，从底层来说，这种方式也不会造成两个可变引用指向了同一块内存。</p>
<p>至此，正确代码我们已经挖掘完毕，再来看看重构后的错误代码。</p>
<h2 id="重构后的错误代码-1"><a class="header" href="#重构后的错误代码-1">重构后的错误代码</a></h2>
<p>由于领导说我们这个函数没办法复用，那就敷衍一下呗：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Test {
    a : u32,
    b : u32
}

impl Test {

    fn increase_a (&amp;mut self) {
        self.a += 1;
    }

    fn increase(&amp;mut self) {
        let b = &amp;mut self.b;
        self.increase_a();
        *b += 1;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>既然领导说了，咱照做，反正他也没说怎么个复用法，咱就来个简单的，把<code>a</code>的递增部分复用下。</p>
<p>代码说实话。。。更丑了，但是更强了吗？</p>
<pre><code class="language-console">error[E0499]: cannot borrow `*self` as mutable more than once at a time
  --&gt; src/main.rs:14:9
   |
13 |         let b = &amp;mut self.b;
   |                 ----------- first mutable borrow occurs here
14 |         self.increase_a();
   |         ^^^^ second mutable borrow occurs here
15 |         *b += 1;
   |         ------- first borrow later used here
</code></pre>
<p>嗯，最开始提到的错误，它终于出现了。</p>
<h2 id="大聪明编译器-1"><a class="header" href="#大聪明编译器-1">大聪明编译器</a></h2>
<p>为什么？明明之前还是正确的代码，就因为放入函数中就报错了？我们先从一个简单的理解谈起，当然这个理解也是浮于表面的，等会会深入分析真实的原因。</p>
<p>之前讲到Rust编译器挺聪明，可以识别到引用到不同的结构体字段，因此不会报错。但是现在这种情况下，编译器又不够聪明了，一旦放入函数中，编译器将无法理解我们对<code>self</code>的使用：它仅仅用到了一个字段，而不是整个结构体。 </p>
<p>因此它会简单的认为，这个结构体作为一个整体被可变借用了，产生两个可变引用，一个引用整个结构体，一个引用了结构体字段<code>b</code>，这两个引用存在重叠的部分，最终导致编译错误。</p>
<h2 id="被冤枉的编译器-1"><a class="header" href="#被冤枉的编译器-1">被冤枉的编译器</a></h2>
<p>在工作生活中，我们无法理解甚至错误的理解一件事，有时是因为层次不够导致的。同样，对于本文来说，也是因为我们对编译器的所知不够，才冤枉了它，还给它起了一个屈辱的“大聪明”外号。</p>
<h4 id="深入分析-2"><a class="header" href="#深入分析-2">深入分析</a></h4>
<blockquote>
<p>如果只改变相关函数的实现而不改变它的签名，那么不会影响编译的结果</p>
</blockquote>
<p>何为相关函数？当函数<code>a</code>调用了函数<code>b</code>，那么<code>b</code>就是<code>a</code>的相关函数。</p>
<p>上面这句是一条非常重要的编译准则，意思是，对于编译器来说，只要函数签名没有变，那么任何函数实现的修改都不会影响已有的编译结果(前提是函数实现没有错误- , -)。</p>
<p>以前面的代码为例：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn increase_a (&amp;mut self) {
    self.a += 1;
}

fn increase(&amp;mut self) {
    let b = &amp;mut self.b;
    self.increase_a();
    *b += 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>虽然<code>increase_a</code>在函数实现中没有访问<code>self.b</code>字段，但是它的签名允许它访问<code>b</code>，因此违背了借用规则。事实上，该函数有没有访问<code>b</code>不重要，<strong>因为编译器在这里只关心签名，签名存在可能性，那么就立刻报出错误</strong>。</p>
<p>为何会有这种编译器行为，主要有两个原因：</p>
<ol>
<li>一般来说，我们希望编译器有能力独立的编译每个函数，而无需深入到相关函数的内部实现，因为这样做会带来快得多的编译速度。</li>
<li>如果没有这种保证，那么在实际项目开发中，我们会特别容易遇到各种错误。 假设我们要求编译器不仅仅关注相关函数的签名，还要深入其内部关注实现，那么由于Rust严苛的编译规则，当你修改了某个函数内部实现的代码后，可能会引起使用该函数的其它函数的各种错误！对于大型项目来说，这几乎是不可接受的！</li>
</ol>
<p>然后，我们的借用类型这么简单，编译器有没有可能针对这种场景，在现有的借用规则之外增加特殊规则？答案是否定的，由于Rust语言的设计哲学：特殊规则的加入需要慎之又慎，而我们的这种情况其实还蛮好解决的，因此编译器不会为此新增规则。</p>
<h2 id="解决办法-1"><a class="header" href="#解决办法-1">解决办法</a></h2>
<p>在深入分析中，我们提到一条重要的规则，要影响编译行为，就需要更改相关函数的签名，因此可以修改<code>increate_a</code>的签名:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn increase_a (a :&amp;mut u32) {
    *a += 1;
}

fn increase(&amp;mut self) {
    let b = &amp;mut self.b;
    Test::increase_a(&amp;mut self.a);
    *b += 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>此时，<code>increase_a</code>这个相关函数，不再使用<code>&amp;mut self</code>作为签名，而是获取了结构体中的字段<code>a</code>，此时编译器又可以清晰的知道：函数<code>increase_a</code>和变量<code>b</code>分别引用了结构体中的不同字段，因此可以编译通过。</p>
<p>当然，除了修改相关函数的签名，你还可以修改调用者的实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn increase(&amp;mut self) {
    self.increase_a();
    self.b += 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>在这里，我们不再单独声明变量<code>b</code>，而是直接调用<code>self.b+=1</code>进行递增，根据借用生命周期<a href="https://course.rs/advance/lifetime/advance.html#nllnon-lexical-lifetime">NLL</a>的规则，第一个可变借用<code>self.increase_a()</code>的生命周期随着方法调用的结束而结束，那么就不会影响<code>self.b += 1</code>中的借用。</p>
<h2 id="闭包中的例子"><a class="header" href="#闭包中的例子">闭包中的例子</a></h2>
<p>再来看一个使用了闭包的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::runtime::Runtime;

struct Server {
    number_of_connections : u64
}

impl Server {
    pub fn new() -&gt; Self {
        Server { number_of_connections : 0}
    }

    pub fn increase_connections_count(&amp;mut self) {
        self.number_of_connections += 1;
    }
}

struct ServerRuntime {
    runtime: Runtime,
    server: Server
}

impl ServerRuntime {
    pub fn new(runtime: Runtime, server: Server) -&gt; Self {
        ServerRuntime { runtime, server }
    }

    pub fn increase_connections_count(&amp;mut self) {
        self.runtime.block_on(async {
            self.server.increase_connections_count()
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>代码中使用了<code>tokio</code>，在<code>increase_connections_count</code>函数中启动了一个异步任务，并且等待它的完成。这个函数中分别引用了<code>self</code>中的不同字段:<code>runtime</code>和<code>server</code>，但是可能因为闭包的原因，编译器没有像本文最开始的例子中那样聪明，并不能识别这两个引用仅仅引用了同一个结构体的不同部分，因此报错了：</p>
<pre><code class="language-console">error[E0501]: cannot borrow `self.runtime` as mutable because previous closure requires unique access
  --&gt; the_little_things\src\main.rs:28:9
   |
28 |            self.runtime.block_on(async {
   |  __________^____________--------_______-
   | |          |            |
   | | _________|            first borrow later used by call
   | ||
29 | ||             self.server.increase_connections_count()
   | ||             ---- first borrow occurs due to use of `self` in generator
30 | ||         })
   | ||_________-^ second borrow occurs here
   | |__________|
   |            generator construction occurs here
</code></pre>
<h4 id="解决办法-2"><a class="header" href="#解决办法-2">解决办法</a></h4>
<p>解决办法很粗暴，既然编译器不能理解闭包中的引用是不同的，那么我们就主动告诉它:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn increase_connections_count(&amp;mut self) {
    let runtime = &amp;mut self.runtime;
    let server = &amp;mut self.server;
    runtime.block_on(async {
        server.increase_connections_count()
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>上面通过变量声明的方式，在闭包外声明了两个变量分别引用结构体<code>self</code>的不同字段，这样一来，编译器就不会那么笨，编译顺利通过。</p>
<p>你也可以这么写：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn increase_connections_count(&amp;mut self) {
    let ServerRuntime { runtime, server } = self;
    runtime.block_on(async {
        server.increase_connections_count()
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>当然，如果难以解决，还有一个笨办法，那就是将<code>server</code>和<code>runtime</code>分离开来，不要放在一个结构体中。</p>
<h2 id="总结-27"><a class="header" href="#总结-27">总结</a></h2>
<p>心中有剑，手中无剑，是武学至高境界。</p>
<p>本文列出的那条编译规则，在未来就将是大家心中的那把剑，当这些心剑招式足够多时，量变产生质变，终将天下无敌。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="不太勤快的迭代器"><a class="header" href="#不太勤快的迭代器">不太勤快的迭代器</a></h1>
<p>迭代器，在Rust中是一个非常耀眼的存在，它光鲜亮丽，它让Rust大道至简，它备受用户的喜爱。可是，它也是懒惰的，不信？一起来看看。</p>
<h2 id="for循环-vs-迭代器"><a class="header" href="#for循环-vs-迭代器">for循环 vs 迭代器</a></h2>
<p>在迭代器学习中，我们提到过迭代器在功能上可以替代循环，性能上略微优于循环(避免边界检查),安全性上优于循环，因此在Rust中，迭代器往往都是更优的选择，前提是迭代器得发挥作用。</p>
<p>在下面代码中，分别是使用<code>for</code>循环和迭代器去生成一个<code>HashMap</code>。</p>
<p>使用循环:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::HashMap;
#[derive(Debug)]
struct Account {
    id: u32,
}

fn main() {
    let accounts = [Account { id: 1 }, Account { id: 2 }, Account { id: 3 }];

    let mut resolvers = HashMap::new();
    for a in accounts {
        resolvers.entry(a.id).or_insert(Vec::new()).push(a);
    }
    
    println!(&quot;{:?}&quot;,resolvers);
}
</code></pre></pre>
<p>使用迭代器:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut resolvers = HashMap::new();
accounts.into_iter().map(|a| {
    resolvers
        .entry(a.id)
        .or_insert(Vec::new())
        .push(a);
});
println!(&quot;{:?}&quot;,resolvers);
<span class="boring">}
</span></code></pre></pre>
<h4 id="预料之外的结果"><a class="header" href="#预料之外的结果">预料之外的结果</a></h4>
<p>两端代码乍一看(很多时候我们快速浏览代码的时候，不会去细看)都很正常, 运行下试试:</p>
<ul>
<li><code>for</code>循环很正常，输出<code>{2: [Account { id: 2 }], 1: [Account { id: 1 }], 3: [Account { id: 3 }]}</code></li>
<li>迭代器很。。。不正常，输出了一个<code>{}</code>, 黑人问号<code>? ?</code> <strong>?</strong></li>
</ul>
<p>在继续深挖之前，我们先来简单回顾下迭代器。</p>
<h2 id="回顾下迭代器"><a class="header" href="#回顾下迭代器">回顾下迭代器</a></h2>
<p>在迭代器章节中，我们曾经提到过，迭代器的<a href="pitfalls/../advance/functional-programing/iterator.html#%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8">适配器</a>分为两种：消费者适配器和迭代器适配器，前者用来将一个迭代器变为指定的集合类型，往往通过<code>collect</code>实现；后者用于生成一个新的迭代器，例如上例中的<code>map</code>。</p>
<p>还提到过非常重要的一点: <strong>迭代器适配器都是懒惰的，只有配合消费者适配器使用时，才会进行求值</strong>.</p>
<h2 id="懒惰是根因"><a class="header" href="#懒惰是根因">懒惰是根因</a></h2>
<p>在我们之前的迭代器示例中，只有一个迭代器适配器<code>map</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>accounts.into_iter().map(|a| {
    resolvers
        .entry(a.id)
        .or_insert(Vec::new())
        .push(a);
});
<span class="boring">}
</span></code></pre></pre>
<p>首先, <code>accounts</code>被拿走所有权后转换成一个迭代器，其次该迭代器通过<code>map</code>方法生成一个新的迭代器，最后，在此过程中没有以类如<code>collect</code>的消费者适配器收尾。</p>
<p>因此在上述过程中，<code>map</code>完全是懒惰的，它没有做任何事情，它在等一个消费者适配器告诉它：赶紧起床，任务可以开始了，它才会开始行动。</p>
<p>自然，我们的插值计划也失败了。</p>
<blockquote>
<p>事实上，IDE和编译器都会对这种代码给出警告：iterators are lazy and do nothing unless consumed</p>
</blockquote>
<h2 id="解决办法-3"><a class="header" href="#解决办法-3">解决办法</a></h2>
<p>原因非常清晰，如果读者还有疑惑，建议深度下上面给出的迭代器链接，我们这里就不再赘述。</p>
<p>下面列出三种合理的解决办法：</p>
<ol>
<li>不再使用迭代器适配器<code>map</code>，改成<code>for_each</code>:</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut resolvers = HashMap::new();
accounts.into_iter().for_each(|a| {
    resolvers
        .entry(a.id)
        .or_insert(Vec::new())
        .push(a);
});
<span class="boring">}
</span></code></pre></pre>
<p>但是，相关的文档也友善的提示了我们，除非作为链式调用的收尾，否则更建议使用<code>for</code>循环来处理这种情况。哎，忙忙碌碌，又回到了原点，不禁让人感叹：天道有轮回。</p>
<ol start="2">
<li>使用消费者适配器<code>collect</code>来收尾，将<code>map</code>产生的迭代器收集成一个集合类型:</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let resolvers: HashMap&lt;_, _&gt; = accounts
.into_iter()
.map(|a| (a.id, a))
.collect();
<span class="boring">}
</span></code></pre></pre>
<p>嗯，还挺简洁，挺<code>rusty</code>.</p>
<ol start="3">
<li>使用<code>fold</code>，语义表达更强:</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let resolvers = account.into_iter().fold(HashMap::new(), |mut resolvers, a|{
    resolvers.entry(a.id).or_insert(Vec::new).push(a);
    resolvers
});
<span class="boring">}
</span></code></pre></pre>
<h2 id="总结-28"><a class="header" href="#总结-28">总结</a></h2>
<p>在使用迭代器时，要清晰的认识到需要用到的方法是迭代型还是消费型适配器，如果一个调用链中没有以消费型适配器结尾，就需要打起精神了，也许，不远处就是一个陷阱在等你跳:)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="奇怪的序列xy"><a class="header" href="#奇怪的序列xy">奇怪的序列x..y</a></h1>
<p>@todo</p>
<p>https://www.reddit.com/r/rust/comments/rrgxr0/a_critique_of_rusts_range_types/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="无处不在的迭代器"><a class="header" href="#无处不在的迭代器">无处不在的迭代器</a></h1>
<p>Rust的迭代器无处不在，直至你在它上面栽了跟头，经过深入调查才发现：哦，原来是迭代器的锅。不信的话，看看这个报错你能想到是迭代器的问题吗: <code>borrow of moved value: words</code>.</p>
<h2 id="报错的代码-1"><a class="header" href="#报错的代码-1">报错的代码</a></h2>
<p>以下的代码非常简单，用来统计文本中字词的数量，并打印出来：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = &quot;hello world&quot;;
    let mut words = s.split(&quot; &quot;);
    let n = words.count();
    println!(&quot;{:?}&quot;,words);
}
</code></pre></pre>
<p>四行代码，行云流水，一气呵成，且看成效：</p>
<pre><code class="language-console">error[E0382]: borrow of moved value: `words`
   --&gt; src/main.rs:5:21
    |
3   |     let mut words = s.split(&quot; &quot;);
    |         --------- move occurs because `words` has type `std::str::Split&lt;'_, &amp;str&gt;`, which does not implement the `Copy` trait
4   |     let n = words.count();
    |                   ------- `words` moved due to this method call
5   |     println!(&quot;{:?}&quot;,words);
    |                     ^^^^^ value borrowed here after move
</code></pre>
<p>世事难料，我以为只有的生命周期、闭包才容易背叛革命，没想到一个你浓眉大眼的<code>count</code>方法也背叛革命。从报错来看，是因为<code>count</code>方法拿走了<code>words</code>的所有权，来看看签名：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn count(self) -&gt; usize
<span class="boring">}
</span></code></pre></pre>
<p>从签名来看，编译器的报错是正确的，但是为什么？为什么一个简单的标准库<code>count</code>方法就敢拿走所有权？</p>
<h2 id="迭代器回顾"><a class="header" href="#迭代器回顾">迭代器回顾</a></h2>
<p>在<a href="pitfalls/../advance/functional-programing/iterator.html#%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8">迭代器</a>章节中，我们曾经学习过两个概念：迭代器适配器和消费者适配器，前者用于对迭代器中的元素进行操作，最终生成一个新的迭代器，例如<code>map</code>、<code>filter</code>等方法；而后者用于消费掉迭代器，最终产生一个结果，例如<code>collect</code>方法, 一个典型的示例如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}
</span></code></pre></pre>
<p>在其中，我们还提到一个细节，消费者适配器会拿走迭代器的所有权，那么这个是否与我们最开始碰到的问题有关系？</p>
<h2 id="深入调查-1"><a class="header" href="#深入调查-1">深入调查</a></h2>
<p>要解释这个问题，必须要找到<code>words</code>是消费者适配器的证据，因此我们需要深入源码进行查看。</p>
<p>其实。。也不需要多深，只要进入<code>words</code>的源码，就能看出它属于<code>Iterator</code>特征，那说明<code>split</code>方法产生了一个迭代器？再来看看：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn split&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; Split&lt;'a, P&gt;
where
    P: Pattern&lt;'a&gt;,
//An iterator over substrings of this string slice, separated by characters matched by a pattern.
<span class="boring">}
</span></code></pre></pre>
<p>还真是，从代码注释来看，<code>Split</code>就是一个迭代器类型，用来迭代被分隔符隔开的子字符串集合。</p>
<p>真相大白了，<code>split</code>产生一个迭代器，而<code>count</code>方法是一个消费者适配器，用于消耗掉前者产生的迭代器，最终生成字词统计的结果。</p>
<p>本身问题不复杂，但是在<strong>解决方法上，可能还有点在各位客官的意料之外</strong>，且看下文。</p>
<h2 id="最rusty的解决方法"><a class="header" href="#最rusty的解决方法">最rusty的解决方法</a></h2>
<p>你可能会想用<code>collect</code>来解决这个问题，先收集成一个集合，然后进行统计。当然此方法完全可行，但是很不<code>rusty</code>(很符合rust规范、潮流的意思)，以下给出最<code>rusty</code>的解决方案：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let words = s.split(&quot;,&quot;);
let n = words.clone().count();
<span class="boring">}
</span></code></pre></pre>
<p>在继续之前，我得先找一个地方藏好，因为俺有一个感觉，烂西红柿正在铺天盖地的呼啸而来，伴随而来的是读者的正义呵斥：
<strong>你管<code>clone</code>叫最好、最<code>rusty</code>的解决方法？？</strong></p>
<p>大家且听我慢慢道来，事实上，在Rust中<code>clone</code>不总是性能低下的代名词，因为<code>clone</code>的行为完全取决于它的具体实现。</p>
<h4 id="迭代器的clone代价"><a class="header" href="#迭代器的clone代价">迭代器的<code>clone</code>代价</a></h4>
<p>对于迭代器而言，它其实并不需要持有数据才能进行迭代，事实上它包含一个引用，该引用指向了保存在堆上的数据，而迭代器自身的结构是保存在栈上。</p>
<p>因此对迭代器的<code>clone</code>仅仅是复制了一份栈上的简单结构，性能非常高效，例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Split&lt;'a, T: 'a, P&gt;
where
    P: FnMut(&amp;T) -&gt; bool,
{
    // Used for `SplitWhitespace` and `SplitAsciiWhitespace` `as_str` methods
    pub(crate) v: &amp;'a [T],
    pred: P,
    // Used for `SplitAsciiWhitespace` `as_str` method
    pub(crate) finished: bool,
}

impl&lt;T, P&gt; Clone for Split&lt;'_, T, P&gt;
where
    P: Clone + FnMut(&amp;T) -&gt; bool,
{
    fn clone(&amp;self) -&gt; Self {
        Split { v: self.v, pred: self.pred.clone(), finished: self.finished }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>以上代码实现了对<code>Split</code>迭代器的克隆，可以看出，底层的的数组<code>self.v</code>并没有被克隆而是简单的复制了一个引用，依然指向了底层的数组<code>&amp;[T]</code>，因此这个克隆非常高效。</p>
<h2 id="总结-29"><a class="header" href="#总结-29">总结</a></h2>
<p>看起来是无效借用导致的错误，实际上是迭代器被消费了导致的问题，这说明Rust编译器虽然会告诉你错误原因，但是这个原因不总是根本原因。我们需要一双慧眼和勤劳的手，来挖掘出这个宝藏，最后为己所用。</p>
<p>同时，克隆在Rust中也并不总是<strong>bad guy</strong>的代名词，有的时候我们可以大胆去使用，当然前提是了解你的代码场景和具体的<code>clone</code>实现，这样你也能像文中那样作出非常<code>rusty</code>的选择。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线程间传递消息导致主线程无法结束"><a class="header" href="#线程间传递消息导致主线程无法结束">线程间传递消息导致主线程无法结束</a></h1>
<p>本篇陷阱较短，主要解决新手在多线程间传递消息时可能会遇到的一个问题：主线程会一直阻塞，无法结束。</p>
<p>Rust标准库中提供了一个消息通道，非常好用，也相当简单明了，但是但是在使用起来还是可能存在坑：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc;
fn main() {

    use std::thread;
    
    let (send, recv) = mpsc::channel();
    let num_threads = 3;
    for i in 0..num_threads {
        let thread_send = send.clone();
        thread::spawn(move || {
            thread_send.send(i).unwrap();
            println!(&quot;thread {:?} finished&quot;, i);
        });
    }
    
    for x in recv {
        println!(&quot;Got: {}&quot;, x);
    }
    println!(&quot;finished iterating&quot;);
}
</code></pre></pre>
<p>以上代码看起来非常正常，运行下试试:</p>
<pre><code class="language-console">thread 0 finished
thread 1 finished
Got: 0
Got: 1
thread 2 finished
Got: 2
</code></pre>
<p>奇怪，主线程竟然卡死了，最后一行<code> println!(&quot;finished iterating&quot;);</code>一直没有被输出。</p>
<p>其实，上面的描述有问题，主线程并不是卡死，而是<code>for</code>循环并没有结束，至于<code>for</code>循环不结束的原因是消息通道没有被关闭。</p>
<p>回忆一下Rust消息通道关闭的两个条件：所有发送者全部被<code>drop</code>或接收者被<code>drop</code>，由于<code>for</code>循环还在使用接收者，因为后者条件无法被满足，那么只能发送者全部被<code>drop</code>，才能让例子中的消息通道关闭。</p>
<p>来分析下代码，每一个子线程都从<code>send</code>获取了一个拷贝，然后该拷贝在子线程结束时自动被<code>drop</code>，看上去没问题啊。等等，好像<code>send</code>本身并没有被<code>drop</code>，因为<code>send</code>要等到<code>main</code>函数结束才会被<code>drop</code>，那么代码就陷入了一个尴尬的境地：<code>main</code>函数要结束需要<code>for</code>循环结束，<code>for</code>循环结束需要<code>send</code>被<code>drop</code>，而<code>send</code>要被<code>drop</code>需要<code>main</code>函数结束。。。</p>
<p>破局点只有一个，那就是主动<code>drop</code>掉<code>send</code>，这个简单，使用<code>std::mem::drop</code>函数即可，得益于<code>prelude</code>，我们只需要使用<code>drop</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc;
fn main() {

    use std::thread;
    
    let (send, recv) = mpsc::channel();
    let num_threads = 3;
    for i in 0..num_threads {
        let thread_send = send.clone();
        thread::spawn(move || {

            thread_send.send(i).unwrap();
            println!(&quot;thread {:?} finished&quot;, i);
        });
    }
    
    drop(send);
    for x in recv { 
        println!(&quot;Got: {}&quot;, x);
    }
    println!(&quot;finished iterating&quot;);
}
</code></pre></pre>
<p>此时再运行，主线程将顺利结束。</p>
<h2 id="总结-30"><a class="header" href="#总结-30">总结</a></h2>
<p>本文总结了一个新手在使用消息通道时常见的错误，那就是忘记处理创建通道时得到的发送者，最后由于该发送者的存活导致通道无法被关闭，最终主线程阻塞，造成程序错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust最佳实践"><a class="header" href="#rust最佳实践">Rust最佳实践</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="日常开发三方库精选"><a class="header" href="#日常开发三方库精选">日常开发三方库精选</a></h1>
<p>对计算机、编程、架构的理解决定一个程序员的上限，而工具则决定了他的下限，三尺森寒利剑在手，问世间谁敢一战。</p>
<p>本文就分门别类的精心挑选了一些非常适合日常开发使用的三方库，同时针对优缺点、社区活跃等进行了评价，同一个类别的库，按照<strong>推荐度优先级降序排列</strong>，希望大家能喜欢。</p>
<blockquote>
<p>本文节选自<a href="https://fancy.rs">Fancy Rust</a>, 一个Rust酷库推荐项目, 里面精选了各个领域的好项目，无论是学习还是工作使用，都能助你一臂之力。</p>
</blockquote>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ul>
<li>日常开发常用的Rust库: 
<ul>
<li><a href="practice/third-party-libs.html#webhttp">Web/HTTP</a>,  <a href="practice/third-party-libs.html#SQL%E5%AE%A2%E6%88%B7%E7%AB%AF">SQL客户端</a>, <a href="practice/third-party-libs.html#NoSql%E5%AE%A2%E6%88%B7%E7%AB%AF">NoSql客户端</a>， <a href="practice/third-party-libs.html#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE">网络通信协议</a>, <a href="practice/third-party-libs.html#%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">异步网络编程</a></li>
<li><a href="practice/third-party-libs.html#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0">服务发现</a>, <a href="practice/third-party-libs.html#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a>, <a href="practice/third-party-libs.html#%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">搜索引擎</a></li>
<li><a href="practice/third-party-libs.html#%E7%BC%96%E8%A7%A3%E7%A0%81">编解码</a>, <a href="practice/third-party-libs.html#Email">Email</a>, <a href="practice/third-party-libs.html#%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E6%A8%A1%E7%89%88">常用正则模版</a></li>
<li><a href="practice/third-party-libs.html#%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7">日志监控</a>, <a href="practice/third-party-libs.html#%E4%BB%A3%E7%A0%81Debug">代码Debug</a>, <a href="practice/third-party-libs.html#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">性能优化</a></li>
</ul>
</li>
<li><a href="practice/third-party-libs.html#%E7%B2%BE%E9%80%89%E4%B8%AD%E6%96%87%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99">精选中文学习资料</a></li>
<li><a href="practice/third-party-libs.html#%E7%B2%BE%E9%80%89Rust%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE">精选Rust开源项目</a></li>
</ul>
<h2 id="日常开发常用rust库"><a class="header" href="#日常开发常用rust库">日常开发常用Rust库</a></h2>
<h3 id="webhttp"><a class="header" href="#webhttp">Web/HTTP</a></h3>
<ul>
<li>
<p>HTTP客户端</p>
<ul>
<li><a href="https://github.com/seanmonstar/reqwest">reqwest</a>  一个简单又强大的HTTP客户端，<code>reqwest</code>是目前使用最多的HTTP库 </li>
</ul>
</li>
<li>
<p>Web框架</p>
<ul>
<li><a href="https://github.com/tokio-rs/axum">axum</a>  基于Tokio和Hyper打造，模块化设计较好，目前口碑很好，值得使用Ergonomic and modular web framework built with Tokio, Tower, and Hyper</li>
<li><a href="https://github.com/SergioBenitez/Rocket">Rocket</a>  功能强大，API简单的Web框架，但是主要开发者目前因为个人原因无法进行后续开发，未来存在不确定性</li>
<li><a href="https://github.com/actix/actix-web">actix-web</a>  性能极高的Web框架，就是团队内部有些问题，未来存在一定的不确定性</li>
<li>总体来说，上述三个web框架都有很深的用户基础，其实都可以选用，如果让我推荐，顺序如下: <code>axum</code> &gt; <code>Rocket</code> &gt; <code>actix-web</code>。 不过如果你不需要多么完善的web功能，只需要一个性能极高的http库，那么<code>actix-web</code>是非常好的选择，它的性能非常非常非常高！</li>
</ul>
</li>
</ul>
<h3 id="日志监控"><a class="header" href="#日志监控">日志监控</a></h3>
<ul>
<li>日志
[<a href="https://crates.io/keywords/log">crates.io</a>] [<a href="https://github.com/search?q=rust+log">github</a>]
<ul>
<li><a href="https://github.com/tokio-rs/tracing">tokio-rs/tracing</a>  强大的日志框架，同时还支持OpenTelemetry格式，无缝打通未来的监控</li>
<li><a href="https://github.com/rust-lang/log">rust-lang/log</a>  官方日志库，事实上的API标准, 但是三方库未必遵循</li>
<li><a href="https://github.com/estk/log4rs">estk/log4rs</a>  模仿JAVA <code>logback</code>和<code>log4j</code>实现的日志库, 可配置性较强</li>
<li>在其它文章中，也许会推荐slog，但是我们不推荐，一个是因为近半年未更新，一个是<code>slog</code>自己也推荐使用<code>tracing</code>。</li>
</ul>
</li>
<li>监控
<ul>
<li><a href="https://github.com/open-telemetry/opentelemetry-rust">OpenTelemetry</a>  <code>OpenTelemetry</code>是现在非常火的可观测性解决方案，提供了协议、API、SDK等核心工具，用于收集监控数据，最后将这些metrics/logs/traces数据写入到<code>prometheus</code>, <code>jaeger</code>等监控平台中。最主要是，它后台很硬，后面有各大公司作为背书，未来非常看好！</li>
<li><a href="https://github.com/vectordotdev/vector">vectordotdev/vector</a>  一个性能很高的数据采集agent，采集本地的日志、监控等数据，发送到远程的kafka、jaeger等数据下沉端，它最大的优点就是能从多种数据源(包括Opentelemetry)收集数据，然后推送到多个数据处理或者存储等下沉端。</li>
</ul>
</li>
</ul>
<h3 id="sql客户端"><a class="header" href="#sql客户端">SQL客户端</a></h3>
<ul>
<li>
<p>通用</p>
<ul>
<li><a href="https://github.com/launchbadge/sqlx">launchbadge/sqlx</a> 异步实现、高性能、纯Rust代码的SQL库，支持<code>PostgreSQL</code>, <code>MySQL</code>, <code>SQLite</code>,和 <code>MSSQL</code>.</li>
</ul>
</li>
<li>
<p>ORM</p>
<ul>
<li><a href="https://github.com/rbatis/rbatis">rbatis/rbatis</a>  国内团队开发的ORM，异步、性能高、简单易上手</li>
<li><a href="https://github.com/diesel-rs/diesel">diesel-rs/diesel</a>  安全、扩展性强的Rust ORM库，支持<code>Mysql</code>、<code>Postgre</code>、<code>SqlLite</code></li>
</ul>
</li>
<li>
<p>Mysql</p>
<ul>
<li><a href="https://github.com/blackbeam/rust-mysql-simple">blackbeam/rust-mysql-simple</a>  纯Rust实现的Mysql驱动,提供连接池</li>
<li><a href="https://github.com/blackbeam/mysql_async">blackbeam/mysql_async</a>  基于Tokio实现的异步Mysql驱动</li>
<li>上面两个都是一个团队出品，前者文档更全、star更多，建议使用前者</li>
</ul>
</li>
<li>
<p>Postgre</p>
<ul>
<li><a href="https://github.com/sfackler/rust-postgres">sfackler/rust-postgres</a> 纯Rust实现的Postgre客户端</li>
</ul>
</li>
<li>
<p>Sqlite</p>
<ul>
<li><a href="https://github.com/rusqlite/rusqlite">rusqlite</a> 用于<a href="https://www.sqlite.org/index.html">Sqlite3</a>的Rust客户端</li>
</ul>
</li>
</ul>
<h3 id="nosql客户端"><a class="header" href="#nosql客户端">NoSql客户端</a></h3>
<ul>
<li>
<p>Redis</p>
<ul>
<li><a href="https://github.com/mitsuhiko/redis-rs">mitsuhiko/redis-rs</a> 虽然最近更新不太活跃，但是它依然是最好的redis客户端，说实话，我期待更好的，可能这也是Rust生态的未来可期之处吧</li>
</ul>
</li>
<li>
<p>Canssandra</p>
<ul>
<li><a href="https://github.com/krojew/cdrs-tokio">krojew/cdrs-tokio</a> [<a href="https://crates.io/crates/cdrs-tokio">cdrs-tokio</a>] 生产可用的Cassandra客户端，异步、纯Rust实现，就是个人项目 + star较少，未来不确定会不会不维护</li>
<li><a href="https://github.com/scylladb/scylla-rust-driver">scylla-rust-driver</a>  ScyllaDB提供的官方库，支持cql协议，由于背靠大山，未来非常可期</li>
</ul>
</li>
<li>
<p>MongoDB</p>
<ul>
<li><a href="https://github.com/mongodb/mongo-rust-driver">mongodb/mongo-rust-driver</a> 官方MongoDB客户端，闭着眼睛选就对了</li>
</ul>
</li>
</ul>
<h3 id="分布式"><a class="header" href="#分布式">分布式</a></h3>
<h4 id="服务发现"><a class="header" href="#服务发现">服务发现</a></h4>
<ul>
<li><a href="https://github.com/luncj/etcd-rs">luncj/etcd-rs</a> 异步实现的Rust etcd客户端，优点是有一定的文档、作者较为活跃,意味着你提问题他可能会回答，不过，如果你不放心，还是考虑使用HTTP的方式访问ETCD</li>
</ul>
<h4 id="消息队列"><a class="header" href="#消息队列">消息队列</a></h4>
<ul>
<li>Kafka
<ul>
<li><a href="https://github.com/fede1024/rust-rdkafka">fede1024/rust-rdkafka</a>  Rust Kafka客户端，基于C版本的Kafka库[librdkafka]实现，文档较全、功能较为全面</li>
<li><a href="https://github.com/kafka-rust/kafka-rust">kafka-rust/kafka-rust</a>  相比上一个库，它算是纯Rust实现，文档还行，支持Kafka0.8.2及以后的版本，但是对于部分0.9版本的特性还不支持。同时有一个问题：最初的作者不维护了，转给了现在的作者，但是感觉好像也不是很活跃</li>
</ul>
</li>
<li>Nats
<ul>
<li><a href="https://github.com/nats-io/nats.rs">nats-io/nats.rs</a> Nats官方提供的客户端</li>
</ul>
</li>
</ul>
<h3 id="网络通信协议"><a class="header" href="#网络通信协议">网络、通信协议</a></h3>
<ul>
<li>Websocket
<ul>
<li><a href="https://github.com/snapview/tokio-tungstenite">snapview/tokio-tungstenite</a> 更适合Web应用使用的生产级Websocket库，它是异步非阻塞的，基于基于下下面的<code>tungstenite-rs</code>库和tokio实现</li>
<li><a href="https://github.com/websockets-rs/rust-websocket">rust-websocket</a>  老牌Websocket库，提供了客户端和服务器端实现，但是。。。很久没更新了</li>
<li><a href="https://github.com/snapview/tungstenite-rs">snapview/tungstenite-rs</a> 轻量级的Websocket流实现，该库更偏底层，例如，你可以用来构建其它网络库</li>
</ul>
</li>
<li>gRPC
<ul>
<li><a href="https://github.com/hyperium/tonic">hyperium/tonic</a> 纯Rust实现的gRPC客户端和服务器端，支持async/await异步调用，文档和示例较为清晰</li>
<li><a href="https://github.com/tikv/grpc-rs">tikv/grpc-rs</a> 国产开源之光Tidb团队出品的gRPC框架, 基于C的代码实现, 就是最近好像不是很活跃</li>
<li>其实这两个实现都很优秀，把<code>tonic</code>放在第一位，主要是因为它是纯Rust实现，同时社区也更为活跃，但是并不代表它比<code>tikv</code>的更好！</li>
</ul>
</li>
<li>QUIC
<ul>
<li><a href="https://github.com/cloudflare/quiche">cloudflare/quiche</a> 大名鼎鼎<code>cloudflare</code>提供的QUIC实现，据说在公司内部重度使用，有了大规模生产级别的验证，非常值得信任，同时该库还实现了HTTP/3</li>
<li><a href="https://github.com/quinn-rs/quinn">quinn-rs/quinn</a> 提供异步API调用，纯Rust实现，同时提供了几个有用的网络库</li>
</ul>
</li>
<li>MQTT
<ul>
<li><a href="https://github.com/bytebeamio/rumqtt">bytebeamio/rumqtt</a>  MQTT3.1.1/5协议库，同时实现了客户端与服务器端broker</li>
<li><a href="https://github.com/ntex-rs/ntex-mqtt">ntex-rs/ntex-mqtt</a>  客户端与服务端框架，支持MQTT3.1.1与5协议</li>
<li><a href="https://github.com/eclipse/paho.mqtt.rust">eclipse/paho.mqtt.rust</a>  老牌MQTT框架，对MQTT支持较全, 其它各语言的实现也有</li>
</ul>
</li>
</ul>
<h3 id="异步网络编程"><a class="header" href="#异步网络编程">异步网络编程</a></h3>
<ul>
<li><a href="https://github.com/tokio-rs/tokio">tokio-rs/tokio</a> 最火的异步网络库，除了复杂上手难度高一些外，没有其它大的问题。同时tokio团队提供了多个非常优秀的Rust库，整个生态欣欣向荣，用户认可度很高</li>
<li><a href="https://async.rs/">async-std</a> 跟标准库API很像的异步网络库，相对简单易用，但是貌似开发有些停滞，还有就是功能上不够完善。但是对于普通用户来说，这个库非常值得一试，它在功能和简单易用上取得了很好的平衡</li>
<li><a href="https://github.com/actix/actix">actix</a> 基于Actor模型的异步网络库，但这个库的开发貌似已经停滞，他们团队一直在专注于<code>actix-web</code>的开发</li>
<li><a href="https://github.com/tokio-rs/mio">mio</a> 严格来说，MIO与之前三个不是同一个用途的，MIO = Meta IO，是一个底层IO库，往往用于构建其它网络库，当然如果你对应用网络性能有非常极限的要求， 可以考虑它，因为它的层次比较低，所带来的抽象负担小，所以性能损耗小</li>
<li>如果你要开发生产级别的项目，我推荐使用<code>tokio</code>，稳定可靠，功能丰富，控制粒度细；自己的学习项目或者没有那么严肃的开源项目，我推荐<code>async-std</code>，简单好用，值得学习；当你确切知道需要Actor网络模型时，就用<code>actix</code></li>
</ul>
<h3 id="搜索引擎"><a class="header" href="#搜索引擎">搜索引擎</a></h3>
<ul>
<li>
<p>ElasticSearch客户端</p>
<ul>
<li><a href="https://github.com/elastic/elasticsearch-rs">elastic/elasticsearch</a> 官方es客户端，目前第三方的基本都处于停滞状态，所以不管好坏，用呗</li>
</ul>
</li>
<li>
<p>Rust搜索引擎</p>
<ul>
<li><a href="https://github.com/quickwit-inc/tantivy">Tantivy</a> Tantivy是Rust实现的本地搜索库，功能对标<code>lucene</code>，如果你不需要分布式，那么引入tantivy作为自己本地Rust服务的一个搜索，是相当不错的选择，该库作者一直很活跃，而且最近还创立了搜索引擎公司，感觉大有作为. 该库的优点在于纯Rust实现，性能高(lucene的2-3倍)，资源占用低(对比java自然不是一个数量级)，社区活跃。</li>
</ul>
</li>
<li>
<p>Rust搜索平台</p>
<ul>
<li><a href="https://github.com/quickwit-inc/quickwit">quickwit</a> 对标ElasticSearch，一个通用目的的分布式搜索平台，目前还在起步阶段(0.2版本)，未来非常可期，目前还不建议使用</li>
<li><a href="https://github.com/meilisearch/MeiliSearch">MeiliSearch</a> 虽然也是一个搜索平台，但是并不是通用目的的，<code>MeiliSearch</code>目标是为终端用户提供边输入边提示的即刻搜索功能，因此是一个轻量级搜索平台，不适用于数据量大时的搜索目的。总之，如果你需要在网页端或者APP为用户提供一个搜索条，然后支持输入容错、前缀搜索时，就可以使用它。</li>
<li></li>
</ul>
</li>
</ul>
<h3 id="代码debug"><a class="header" href="#代码debug">代码Debug</a></h3>
<ul>
<li>GDB
<ul>
<li><a href="https://github.com/cs01/gdbgui">gdbgui</a>  提供浏览器支持的gdb debug工具，支持C，C++，Rust和Go.</li>
</ul>
</li>
<li>LLDB
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB</a> — 专门为VSCode设计的LLDB Debug扩展</li>
</ul>
</li>
</ul>
<h3 id="性能优化"><a class="header" href="#性能优化">性能优化</a></h3>
<ul>
<li><a href="https://github.com/bheisler/criterion.rs">bheisler/criterion.rs</a> 比官方提供的benchmark库更好，目前已经成为事实上标准的性能测试工具</li>
<li><a href="https://github.com/koute/bytehound">Bytehound</a> Linux下的内存分析工具，可以用来分析：内存泄漏、内存分配、调用栈追踪，甚至它还有一个浏览器UI! 懂的人都懂，性能测试工具的UI服务是多么稀缺和珍贵！</li>
<li><a href="https://github.com/llogiq/flame">llogiq/flame</a> 专为Rust打造的火焰图分析工具，可以告诉你程序在哪些代码上花费的时间过多，非常适合用于代码性能瓶颈的分析。与<code>perf</code>不同，<code>flame</code>库允许你自己定义想要测试的代码片段，只需要在代码前后加上相应的指令即可，非常好用</li>
<li><a href="https://github.com/sharkdp/hyperfine">sharkdp/hyperfine</a> 一个命令行benchmark工具，支持任意shell命令，支持缓存清除、预热、多次运行统计分析等，尽量保证结果的准确性</li>
</ul>
<h3 id="编解码"><a class="header" href="#编解码">编解码</a></h3>
<ul>
<li><a href="https://github.com/serde-rs/serde">Serde</a> 一个超高性能的通用序列化/反序列化框架，可以跟多种协议的库联合使用，实现统一编解码格式</li>
<li>CSV
<ul>
<li><a href="https://github.com/BurntSushi/rust-csv">BurntSushi/rust-csv</a> 高性能CSV读写库，支持<a href="https://github.com/serde-rs/serde">Serde</a></li>
</ul>
</li>
<li>JSON
<ul>
<li><a href="https://github.com/serde-rs/json">serde-rs/json</a> 快到上天的JSON库，也是Rust事实上的标准JSON库，你也可以使用它的大哥<a href="https://github.com/serde-rs/serde">serde</a>，一个更通用的序列化/反序列化库</li>
</ul>
</li>
<li>MsgPack
<ul>
<li><a href="https://github.com/3Hren/msgpack-rust">3Hren/msgpack-rust</a> 纯Rust实现的MessagePack编解码协议</li>
</ul>
</li>
<li>ProtocolBuffers
<ul>
<li><a href="https://github.com/tokio-rs/prost">tokio-rs/prost</a> tokio出品，基本都属精品，此库也不例外，简单易用，文档详细</li>
<li><a href="https://github.com/stepancheg/rust-protobuf">stepancheg/rust-protobuf</a> 纯Rust实现</li>
</ul>
</li>
<li>TOML
<ul>
<li><a href="https://github.com/alexcrichton/toml-rs">alexcrichton/toml-rs</a> TOML编码/解码，可以配合<code>serde</code>使用</li>
</ul>
</li>
<li>XML
<ul>
<li><a href="https://github.com/tafia/quick-xml">tafia/quick-xml</a> 高性能XML库，可以配合<code>serde</code>使用，文档较为详细</li>
</ul>
</li>
<li>YAML
<ul>
<li><a href="https://github.com/dtolnay/serde-yaml">dtolnay/serde-yaml</a> 使用<code>serde</code>编解码<code>YAML</code>格式的数据</li>
</ul>
</li>
</ul>
<h3 id="email"><a class="header" href="#email">Email</a></h3>
<ul>
<li><a href="https://github.com/lettre/lettre">lettre/lettre</a> — Rust SMTP库</li>
</ul>
<h3 id="常用正则模版"><a class="header" href="#常用正则模版">常用正则模版</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一些写代码的技巧"><a class="header" href="#一些写代码的技巧">一些写代码的技巧</a></h1>
<h2 id="如何获知变量类型或者函数的返回类型-1"><a class="header" href="#如何获知变量类型或者函数的返回类型-1">如何获知变量类型或者函数的返回类型</a></h2>
<p>有几种常用的方式:</p>
<ul>
<li>第一种是查询标准库或者三方库文档，搜索<code>File</code>，然后找到它的<code>open</code>方法，但是此处更推荐第二种方法:</li>
<li>在[Rust IDE]章节，我们推荐了<code>VSCode</code> IED和<code>rust-analyze</code>插件，如果你成功安装的话，那么就可以在<code>VScode</code>中很方便的通过代码跳转的方式查看代码，同时<code>rust-analyze</code>插件还会对代码中的类型进行标注，非常方便好用！</li>
<li>你还可以尝试故意标记一个错误的类型，然后让编译器告诉你:</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f: u32 = File::open(&quot;hello.txt&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>错误提示如下：</p>
<pre><code class="language-console">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
             found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最佳实践"><a class="header" href="#最佳实践">最佳实践</a></h1>
<p>https://www.reddit.com/r/rust/comments/rgjsbt/whats_your_top_rust_tip_crate_tool_other_for/</p>
<p>https://www.reddit.com/r/rust/comments/rnmmqz/question_how_to_keep_code_dry_when_many_similar/</p>
<p>https://www.reddit.com/r/rust/comments/rrgho1/what_is_the_recommended_way_to_use_a_library/</p>
<h2 id="最佳开发流程workflow"><a class="header" href="#最佳开发流程workflow">最佳开发流程workflow</a></h2>
<p>cargo watch
https://www.reddit.com/r/rust/comments/rxrkbo/what_is_your_workflow_when_working_with_rust/</p>
<h2 id="测试文件组织结构"><a class="header" href="#测试文件组织结构">测试文件组织结构</a></h2>
<p>https://www.reddit.com/r/rust/comments/rsuhnn/need_a_piece_of_advice_about_organising_tests/</p>
<h2 id="git备份"><a class="header" href="#git备份">git备份</a></h2>
<p>https://github.com/tkellogg/dura</p>
<h2 id="code-cover"><a class="header" href="#code-cover">code cover</a></h2>
<p>https://docs.codecov.com/docs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="值得学习的源代码"><a class="header" href="#值得学习的源代码">值得学习的源代码</a></h1>
<p>https://www.reddit.com/r/rust/comments/rxfx85/good_rust_source_code/</p>
<p>https://www.reddit.com/r/rust/comments/rx8rom/rust_projects_where_you_learnt_a_ton_of_stuff/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust代码风格"><a class="header" href="#rust代码风格">Rust代码风格</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命名规范"><a class="header" href="#命名规范">命名规范</a></h1>
<p>基本的Rust命名规范在<a href="https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md">RFC 430</a>中有描述.</p>
<p>通常，对于&quot;type-level&quot;的构造Rust倾向于使用驼峰命名,而对于'value-level'的构造使用蛇形命名。详情如下:</p>
<table><thead><tr><th>条目</th><th>惯例</th></tr></thead><tbody>
<tr><td>包Crates</td><td><a href="https://github.com/rust-lang/api-guidelines/issues/29">unclear</a></td></tr>
<tr><td>模块Modules</td><td><code>snake_case</code></td></tr>
<tr><td>类型Types</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>特征Traits</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>枚举项</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>函数Functions</td><td><code>snake_case</code></td></tr>
<tr><td>方法Methods</td><td><code>snake_case</code></td></tr>
<tr><td>通用构造器General constructors</td><td><code>new</code> or <code>with_more_details</code></td></tr>
<tr><td>转换构造器Conversion constructors</td><td><code>from_some_other_type</code></td></tr>
<tr><td>宏Macros</td><td><code>snake_case!</code></td></tr>
<tr><td>局部变量Local variables</td><td><code>snake_case</code></td></tr>
<tr><td>静态类型Statics</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr>
<tr><td>常量Constants</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr>
<tr><td>类型参数Type parameters</td><td><code>UpperCamelCase</code>, 通常使用一个大写字母: <code>T</code></td></tr>
<tr><td>生命周期Lifetimes</td><td>通常使用小写字母: <code>'a</code>, <code>'de</code>, <code>'src</code></td></tr>
<tr><td>Features</td><td><a href="https://github.com/rust-lang/api-guidelines/issues/101">unclear</a> but see <a href="practice/style-guide/naming.html#c-feature">C-FEATURE</a></td></tr>
</tbody></table>
<p>对于驼峰命名法, 复合词的缩略形式我们认为是一个单独的词语，所以只对首字母进行大写: 使用<code>Uuid</code>而不是<code>UUID</code>, <code>Usize</code>而不是<code>USize</code>, <code>Stdin</code>而不是<code>StdIn</code>.对于蛇形命名法，缩略词用全小写: <code>is_xid_start</code>.</p>
<p>对于蛇形命名(包括全大写的<code>SCREAMING_SNAKE_CASE</code>), 除了最后一部分，其它部分的词语都不能由单个字母组成：
<code>btree_map</code>而不是<code>b_tree_map</code>, <code>PI_2</code>而不是<code>PI2</code>.</p>
<p>包名不应该使用<code>-rs</code>或者<code>-rust</code>作为后缀，因为每一个包都是Rust写的，因此这种多余的注释其实没有任何意义。</p>
<h2 id="特征命名"><a class="header" href="#特征命名">特征命名</a></h2>
<p>特征的名称应该使用动词，而不是形容词或者名词，例如<code>Print</code>和<code>Draw</code>明显好于<code>Printable</code>和<code>Drawable</code>。</p>
<h2 id="类型转换要遵守as_-to_-into_命名惯例c-conv"><a class="header" href="#类型转换要遵守as_-to_-into_命名惯例c-conv">类型转换要遵守<code>as_</code>, <code>to_</code>, <code>into_</code>命名惯例(C-CONV)</a></h2>
<p>类型转换应该通过方法调用的方式实现，其中的前缀规则如下：</p>
<table><thead><tr><th>方法前缀</th><th>性能开销</th><th>所有权改变</th></tr></thead><tbody>
<tr><td><code>as_</code></td><td>Free</td><td>borrowed -&gt; borrowed</td></tr>
<tr><td><code>to_</code></td><td>Expensive</td><td>borrowed -&gt; borrowed<br>borrowed -&gt; owned (non-Copy types)<br>owned -&gt; owned (Copy types)</td></tr>
<tr><td><code>into_</code></td><td>Variable</td><td>owned -&gt; owned (non-Copy types)</td></tr>
</tbody></table>
<p>For example:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes"><code>str::as_bytes()</code></a> 把<code>str</code>变成UTF-8字节数组, 性能开销是0. 其中输入是一个借用的<code>&amp;str</code>，输出也是一个借用的<code>&amp;str</code>.</li>
<li><a href="https://doc.rust-lang.org/std/path/struct.Path.html#method.to_str"><code>Path::to_str</code></a> 会执行一次昂贵的UTF-8字节数组检查，输入和输出都是借用的。对于这种情况，如果把方法命名为<code>as_str</code>是不正确的，因为这个方法的开销还挺大.</li>
<li><a href="https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase"><code>str::to_lowercase()</code></a>在调用过程中会遍历字符串的字符，且可能会分配新的内存对象.输入是一个借用的<code>str</code>，输出是一个有独立所有权的<code>String</code></li>
<li><a href="https://doc.rust-lang.org/std/string/struct.String.html#method.into_bytes"><code>String::into_bytes()</code></a>返回<code>String</code>底层的<code>Vec&lt;u8&gt;</code>数组，转换本身是零消耗的。该方法获取<code>String</code>的所有权，然后返回一个新的有独立所有权的<code>Vec&lt;u8&gt;</code></li>
</ul>
<p>当一个单独的值被某个类型所包装时，访问该类型的内部值应通过<code>into_inner()</code>方法来访问。例如将一个缓冲区值包装为<a href="https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner"><code>BufReader</code></a>类型，还有<a href="https://docs.rs/flate2/0.2.19/flate2/read/struct.GzDecoder.html#method.into_inner"><code>GzDecoder</code></a>、<a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.into_inner"><code>AtomicBool</code></a>等，都是这种类型。</p>
<p>如果<code>mut</code>限定符在返回类型中出现，那么在命名上也应该体现出来。例如，<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.as_mut_slice"><code>Vec::as_mut_slice</code></a> 就说明它返回了一个mut切片，在这种情况下<code>as_mut_slice</code>比<code>as_slice_mut</code>更适合。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 返回类型是一个mut切片.
fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T];
<span class="boring">}
</span></code></pre></pre>
<h5 id="标准库中的一些例子"><a class="header" href="#标准库中的一些例子">标准库中的一些例子</a></h5>
<ul>
<li><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.as_ref"><code>Result::as_ref</code></a></li>
<li><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.as_ptr"><code>RefCell::as_ptr</code></a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.to_vec"><code>slice::to_vec</code></a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.into_iter"><code>Option::into_iter</code></a></li>
</ul>
<h2 id="读访问器getter的名称遵循rust的命名规范c-getter"><a class="header" href="#读访问器getter的名称遵循rust的命名规范c-getter">读访问器(Getter)的名称遵循Rust的命名规范(C-GETTER)</a></h2>
<p>除了少数例外，在Rust代码中<code>get</code>前缀不用于getter。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct S {
    first: First,
    second: Second,
}

impl S {
    // 而不是get_first
    pub fn first(&amp;self) -&gt; &amp;First {
        &amp;self.first
    }

    // 而不是get_first_mut, get_mut_first, or mut_first.
    pub fn first_mut(&amp;mut self) -&gt; &amp;mut First {
        &amp;mut self.first
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>至于上文提到的少数例外，如下：当有且仅有一个值能被getter所获取时，才使用<code>get</code>前缀。例如，
<a href="https://doc.rust-lang.org/std/cell/struct.Cell.html#method.get"><code>Cell::get</code></a>能直接访问到<code>Cell</code>中的内容。</p>
<p>有些getter会在过程中执行运行时检查，那么我们就可以考虑添加<code>_unchecked</code>getter函数，这个函数虽然不安全，但是往往具有更高的性能，
典型的例子如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get(&amp;self, index: K) -&gt; Option&lt;&amp;V&gt;;
fn get_mut(&amp;mut self, index: K) -&gt; Option&lt;&amp;mut V&gt;;
unsafe fn get_unchecked(&amp;self, index: K) -&gt; &amp;V;
unsafe fn get_unchecked_mut(&amp;mut self, index: K) -&gt; &amp;mut V;
<span class="boring">}
</span></code></pre></pre>
<h3 id="标准库示例"><a class="header" href="#标准库示例">标准库示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/io/struct.Cursor.html#method.get_mut"><code>std::io::Cursor::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ptr/struct.Unique.html#method.get_mut"><code>std::ptr::Unique::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html#method.get_mut"><code>std::sync::PoisonError::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.get_mut"><code>std::sync::atomic::AtomicBool::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/hash_map/struct.OccupiedEntry.html#method.get_mut"><code>std::collections::hash_map::OccupiedEntry::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked"><code>&lt;[T]&gt;::get_unchecked</code></a></li>
</ul>
<h2 id="一个集合上的方法如果返回迭代器需遵循命名规则iter-iter_mut-into_iter-c-iter"><a class="header" href="#一个集合上的方法如果返回迭代器需遵循命名规则iter-iter_mut-into_iter-c-iter">一个集合上的方法，如果返回迭代器，需遵循命名规则：<code>iter</code>, <code>iter_mut</code>, <code>into_iter</code> (C-ITER)</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn iter(&amp;self) -&gt; Iter             // Iter implements Iterator&lt;Item = &amp;U&gt;
fn iter_mut(&amp;mut self) -&gt; IterMut  // IterMut implements Iterator&lt;Item = &amp;mut U&gt;
fn into_iter(self) -&gt; IntoIter     // IntoIter implements Iterator&lt;Item = U&gt;
<span class="boring">}
</span></code></pre></pre>
<p>上面的规则适用于同构性的数据集合。与之相反，<code>str</code>类型是一个utf8字节数组切片，与同构性集合有一点微妙的差别，它可以认为是字节集合，也可以认为是字符集合，因此它提供了<a href="https://doc.rust-lang.org/std/primitive.str.html#method.bytes"><code>str::bytes</code></a>去遍历字节，还有<a href="https://doc.rust-lang.org/std/primitive.str.html#method.chars"><code>str::chars</code></a>去遍历字符，而并没有直接定义<code>iter</code>等方法。</p>
<p>上述规则只适用于方法，并不适用于函数。例如<code>url</code>包的<a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html"><code>percent_encode</code></a>函数返回一个迭代器用于遍历百分比编码(<a href="https://en.wikipedia.org/wiki/Percent-encoding">Percent encoding</a>)的字符串片段. 在这种情况下，使用<code>iter</code>/<code>iter_mut</code>/<code>into_iter</code>诸如此类的函数命名无法表达任何具体的含义。</p>
<h3 id="标准库示例-1"><a class="header" href="#标准库示例-1">标准库示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter"><code>Vec::iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut"><code>Vec::iter_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter"><code>Vec::into_iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter"><code>BTreeMap::iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter_mut"><code>BTreeMap::iter_mut</code></a></li>
</ul>
<h2 id="迭代器的类型应该与产生它的方法名相匹配c-iter-ty"><a class="header" href="#迭代器的类型应该与产生它的方法名相匹配c-iter-ty">迭代器的类型应该与产生它的方法名相匹配(C-ITER-TY)</a></h2>
<p>例如形如<code>into_iter()</code>的方法应该返回一个<code>IntoIter</code>类型，与之相似，其它任何返回迭代器的方法也应该遵循这种命名惯例。</p>
<p>上述规则主要应用于方法，但是经常对于函数也适用。例如上文提到的url包中的<a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html"><code>percent_encode</code></a>函数，返回了一个[<code>PercentEncode</code>]类型.</p>
<p>特别是，当这些类型跟包名前缀一起使用时，将具备非常清晰的含义，例如<a href="https://doc.rust-lang.org/std/vec/struct.IntoIter.html"><code>vec::IntoIter</code></a>.</p>
<h3 id="标准库示例-2"><a class="header" href="#标准库示例-2">标准库示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter"><code>Vec::iter</code></a> returns <a href="https://doc.rust-lang.org/std/slice/struct.Iter.html"><code>Iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut"><code>Vec::iter_mut</code></a> returns <a href="https://doc.rust-lang.org/std/slice/struct.IterMut.html"><code>IterMut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter"><code>Vec::into_iter</code></a> returns <a href="https://doc.rust-lang.org/std/vec/struct.IntoIter.html"><code>IntoIter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.keys"><code>BTreeMap::keys</code></a> returns <a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Keys.html"><code>Keys</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.values"><code>BTreeMap::values</code></a> returns <a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Values.html"><code>Values</code></a></li>
</ul>
<p><a id="c-feature"></a></p>
<h2 id="cargo-feature的名称不应该包含占位词c-feature"><a class="header" href="#cargo-feature的名称不应该包含占位词c-feature">Cargo Feature的名称不应该包含占位词(C-FEATURE)</a></h2>
<p>不要在<a href="http://doc.crates.io/manifest.html#the-features-section">Cargo feature</a>中包含无法传达任何意义的词，例如<code>use-abc</code>或<code>with-abc</code>，直接命名为<code>abc</code>即可。</p>
<p>一个典型的例子就是：一个包对标准库有可选性的依赖。标准的写法如下：</p>
<pre><code class="language-toml"># 在Cargo.toml中

[features]
default = [&quot;std&quot;]
std = []
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 在我们自定义的lib.rs中

#![cfg_attr(not(feature = &quot;std&quot;), no_std)]
<span class="boring">}
</span></code></pre></pre>
<p>除了<code>std</code>之外，不要使用任何<code>ust-std</code>或者<code>with-std</code>等自以为很有创造性的名称。</p>
<h2 id="命名要使用一致性的词序c-word-order"><a class="header" href="#命名要使用一致性的词序c-word-order">命名要使用一致性的词序(C-WORD-ORDER)</a></h2>
<p>这是一些标准库中的错误类型:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/env/struct.JoinPathsError.html"><code>JoinPathsError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/str/struct.ParseBoolError.html"><code>ParseBoolError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/char/struct.ParseCharError.html"><code>ParseCharError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/num/struct.ParseFloatError.html"><code>ParseFloatError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/mpsc/enum.RecvTimeoutError.html"><code>RecvTimeoutError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/path/struct.StripPrefixError.html"><code>StripPrefixError</code></a></li>
</ul>
<p>它们都使用了<code>谓语-宾语-错误</code>的词序，如果我们想要表达一个网络地址无法分析的错误，由于词序一致性的原则，命名应该如下<code>ParseAddrError</code>,而不是<code>AddrParseError</code>。</p>
<p>词序和个人习惯有很大关系，想要注意的是，你可以选择合适的词序，但是要在包的范畴内保持一致性，就如标准库中的包一样。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码风格todo"><a class="header" href="#代码风格todo">代码风格(todo)</a></h1>
<p>https://www.reddit.com/r/rust/comments/rlsatb/generically_working_with_futuressinkstream/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码标记"><a class="header" href="#代码标记">代码标记</a></h1>
<p>unimplemented!() todo!()</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clippy"><a class="header" href="#clippy">Clippy</a></h1>
<p>https://www.reddit.com/r/rust/comments/s62xu0/inspect_enum_variant_size_differences/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进阶类型转换"><a class="header" href="#进阶类型转换">进阶类型转换</a></h1>
<p>Rust是强类型语言，同时也是强安全语言，因此这些决定了Rust的类型转换注定比一般语言要更困难，再加上Rust的繁多的类型和类型转换特征，用于很难对这块内容了若指掌，因此我们专门整了一个专题来讨论Rust中那些不太容易的类型转换, 容易的请看<a href="converse/../basic/converse.html">这一章</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整数转换为枚举"><a class="header" href="#整数转换为枚举">整数转换为枚举</a></h1>
<p>在Rust中，从枚举到整数的转换很容易，但是反过来，就没那么容易，甚至部分实现还挺邪恶, 例如使用<code>transmute</code>。</p>
<h2 id="一个真实场景的需求"><a class="header" href="#一个真实场景的需求">一个真实场景的需求</a></h2>
<p>在实际场景中，从枚举到整数的转换有时还是非常需要的，例如你有一个枚举类型，然后需要从外面穿入一个整数，用于控制后续的流程走向，此时就需要用整数去匹配相应的枚举(你也可以用整数匹配整数-, -，看看会不会被喷)。</p>
<p>既然有了需求，剩下的就是看看该如何实现，这篇文章的水远比你想象的要深，且看八仙过海各显神通。</p>
<h2 id="c语言的实现"><a class="header" href="#c语言的实现">C语言的实现</a></h2>
<p>对于C语言来说，万物皆邪恶，因此我们不讨论安全，只看实现，不得不说很简洁：</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;

enum atomic_number {
    HYDROGEN = 1,
    HELIUM = 2,
    // ...
    IRON = 26,
};

int main(void)
{
    enum atomic_number element = 26;

    if (element == IRON) {
        printf(&quot;Beware of Rust!\n&quot;);
    }

    return 0;
}
</code></pre>
<p>但是在Rust中，以下代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum MyEnum {
    A = 1,
    B,
    C,
}

fn main() {
    // 将枚举转换成整数，顺利通过
    let x = MyEnum::C as i32;

    // 将整数转换为枚举，失败
    match x {
        MyEnum::A =&gt; {}
        MyEnum::B =&gt; {}
        MyEnum::C =&gt; {}
        _ =&gt; {}
    }
}
</code></pre></pre>
<p>就会报错: <code>MyEnum::A =&gt; {} mismatched types, expected i32, found enum MyEnum</code>。</p>
<h2 id="使用三方库"><a class="header" href="#使用三方库">使用三方库</a></h2>
<p>首先可以想到的肯定是三方库，毕竟Rust的生态目前已经发展的很不错，类似的需求总是有的，这里我们先使用<code>num-traits</code>和<code>num-derive</code>来试试。</p>
<p>在<code>Cargo.toml</code>中引入：</p>
<pre><code class="language-toml">[dependencies]
num-traits = &quot;0.2.14&quot;
num-derive = &quot;0.3.3&quot;
</code></pre>
<p>代码如下:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use num_derive::FromPrimitive;    
use num_traits::FromPrimitive;

#[derive(FromPrimitive)]
enum MyEnum {
    A = 1,
    B,
    C,
}

fn main() {
    let x = 2;

    match FromPrimitive::from_i32(x) {
        Some(MyEnum::A) =&gt; println!(&quot;Got A&quot;),
        Some(MyEnum::B) =&gt; println!(&quot;Got B&quot;),
        Some(MyEnum::C) =&gt; println!(&quot;Got C&quot;),
        None            =&gt; println!(&quot;Couldn't convert {}&quot;, x),
    }
}
</code></pre></pre>
<p>除了上面的库，还可以使用一个较新的库: <a href="https://github.com/illicitonion/num_enum"><code>num_enums</code></a>。</p>
<h2 id="tryfrom--宏"><a class="header" href="#tryfrom--宏">TryFrom + 宏</a></h2>
<p>在Rust1.34后，可以实现<code>TryFrom</code>特征来做转换:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::TryFrom;

impl TryFrom&lt;i32&gt; for MyEnum {
    type Error = ();

    fn try_from(v: i32) -&gt; Result&lt;Self, Self::Error&gt; {
        match v {
            x if x == MyEnum::A as i32 =&gt; Ok(MyEnum::A),
            x if x == MyEnum::B as i32 =&gt; Ok(MyEnum::B),
            x if x == MyEnum::C as i32 =&gt; Ok(MyEnum::C),
            _ =&gt; Err(()),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>以上代码定义了从<code>i32</code>到<code>MyEnum</code>的转换，接着就可以使用<code>TryInto</code>来实现转换：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::convert::TryInto;

fn main() {
    let x = MyEnum::C as i32;

    match x.try_into() {
        Ok(MyEnum::A) =&gt; println!(&quot;a&quot;),
        Ok(MyEnum::B) =&gt; println!(&quot;b&quot;),
        Ok(MyEnum::C) =&gt; println!(&quot;c&quot;),
        Err(_) =&gt; eprintln!(&quot;unknown number&quot;),
    }
}
</code></pre></pre>
<p>但是上面的代码有个问题，你需要为每个枚举成员都实现一个转换分支，非常麻烦。好在可以使用宏来简化，自动根据枚举的定义来实现<code>TryFrom</code>特征:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! back_to_enum {
    ($(#[$meta:meta])* $vis:vis enum $name:ident {
        $($(#[$vmeta:meta])* $vname:ident $(= $val:expr)?,)*
    }) =&gt; {
        $(#[$meta])*
        $vis enum $name {
            $($(#[$vmeta])* $vname $(= $val)?,)*
        }

        impl std::convert::TryFrom&lt;i32&gt; for $name {
            type Error = ();

            fn try_from(v: i32) -&gt; Result&lt;Self, Self::Error&gt; {
                match v {
                    $(x if x == $name::$vname as i32 =&gt; Ok($name::$vname),)*
                    _ =&gt; Err(()),
                }
            }
        }
    }
}

back_to_enum! {
    enum MyEnum {
        A = 1,
        B,
        C,
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="邪恶之王stdmemtransmute"><a class="header" href="#邪恶之王stdmemtransmute">邪恶之王std::mem::transmute</a></h2>
<p><strong>这个方法原则上并不推荐，但是有其存在的意义，如果要使用，你需要清晰的知道自己为什么使用</strong>。</p>
<p>在之前的类型转换章节，我们提到过非常邪恶的<a href="converse/../basic/converse.html#%E5%8F%98%E5%BD%A2%E8%AE%B0(Transmutes)"><code>transmute</code>转换</a>，其实，当你知道数值一定不会超过枚举的范围时(例如枚举成员对应1，2，3，传入的整数也在这个范围内)，就可以使用这个方法完成变形。</p>
<blockquote>
<p>最好使用#[repr(..)]来控制底层类型的大小，免得本来需要i32，结果传入i64，最终内存无法对齐，产生奇怪的结果</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">#[repr(i32)]
enum MyEnum {
    A = 1, B, C
}

fn main() {
    let x = MyEnum::C;
    let y = x as i32;
    let z: MyEnum = unsafe { ::std::mem::transmute(y) };

    // match the enum that came from an int
    match z {
        MyEnum::A =&gt; { println!(&quot;Found A&quot;); }
        MyEnum::B =&gt; { println!(&quot;Found B&quot;); }
        MyEnum::C =&gt; { println!(&quot;Found C&quot;); }
    }
}
</code></pre></pre>
<p>既然是邪恶之王，当然得有真本事，无需标准库、也无需unstable的Rust版本，我们就完成了转换！awesome!??</p>
<h2 id="总结-31"><a class="header" href="#总结-31">总结</a></h2>
<p>本文列举了常用(其实差不多也是全部了，还有一个unstable特性没提到)的从整数转换为枚举的方式，推荐度按照出现的先后顺序递减。</p>
<p>但是推荐度最低，不代表它就没有出场的机会，只要使用边界清晰，一样可以大方光彩，例如最后的<code>transmute</code>函数.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="复杂错误索引"><a class="header" href="#复杂错误索引">复杂错误索引</a></h1>
<p>读者可以在本章中通过错误前缀来索引查询相应的解决方案，简单的错误并不在本章的内容范畴之内。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="所有权和借用-1"><a class="header" href="#所有权和借用-1">所有权和借用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命周期-todo"><a class="header" href="#生命周期-todo">生命周期 todo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo"><a class="header" href="#cargo">cargo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常用命令"><a class="header" href="#常用命令">常用命令</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="项目结构"><a class="header" href="#项目结构">项目结构</a></h1>
<h2 id="main函数的正确位置"><a class="header" href="#main函数的正确位置">main函数的正确位置</a></h2>
<p>目前发现部分人会搞不懂main函数应该放在哪个文件中，结果导致编译器报错：找不到main函数</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargotoml和cargolock"><a class="header" href="#cargotoml和cargolock">Cargo.toml和Cargo.lock</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="依赖管理"><a class="header" href="#依赖管理">依赖管理</a></h1>
<h2 id="依赖升级"><a class="header" href="#依赖升级">依赖升级</a></h2>
<p>Minor note about your second point: You can use cargo update to update versions of transitive dependencies in your Cargo.lock when applicable; the very nice cargo-edit crate provides a cargo upgrade command which does the same for your Cargo.toml. If you use VSCode, I can also recommend the &quot;crates&quot; extension which shows available updates inline in your Cargo.toml.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="构建缓存"><a class="header" href="#构建缓存">构建缓存</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="版本管理"><a class="header" href="#版本管理">版本管理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工作空间"><a class="header" href="#工作空间">工作空间</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条件编译条件依赖"><a class="header" href="#条件编译条件依赖">条件编译、条件依赖</a></h1>
<h2 id="通过featre来实现不同的derive"><a class="header" href="#通过featre来实现不同的derive">通过featre来实现不同的derive</a></h2>
<p>比如有一个类型，我们希望在不同包引用它的时候，派生引用不同的特征，可以这么做：</p>
<p>在<code>Cargo.toml</code>中定义新的<code>feature</code>:</p>
<pre><code class="language-toml">[features]
sqlx = []
</code></pre>
<p>在类型定义处：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(feature = &quot;sqlx&quot;, derive(sqlx::Type)]
#[derive(Debug, PartialEq, Deserialize, Serialize, strum_macros::EnumString)]
pub enum Role {Owner,Admin,User,}
<span class="boring">}
</span></code></pre></pre>
<p>在希望派生<code>sqlx</code>的包：</p>
<pre><code class="language-toml">your_shared_crate = { version = &quot;0.0.1&quot;, features = [&quot;sqlx&quot;] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manifest"><a class="header" href="#manifest">manifest</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义构建脚本"><a class="header" href="#自定义构建脚本">自定义构建脚本</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-profile"><a class="header" href="#cargo-profile">Cargo profile</a></h1>
<h2 id="custom-profiles-rust-1570"><a class="header" href="#custom-profiles-rust-1570">custom profiles (rust 1.57.0)</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试"><a class="header" href="#测试">测试</a></h1>
<p>cargo test -- --test-threads=1</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h1>
<p>https://www.reddit.com/r/rust/comments/rln220/question_prevent_racing_in_unit_tests/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集成测试"><a class="header" href="#集成测试">集成测试</a></h1>
<p>https://www.reddit.com/r/rust/comments/s9zs5c/how_do_you_debug_a_rust_library_after_compilation/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="性能测试"><a class="header" href="#性能测试">性能测试</a></h1>
<h2 id="benchmark迷一般的性能结果"><a class="header" href="#benchmark迷一般的性能结果">benchmark迷一般的性能结果</a></h2>
<p>代码如下</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span>#![feature(test)]

<span class="boring">fn main() {
</span>extern crate test;

fn fibonacci_u64(number: u64) -&gt; u64 {
    let mut last: u64 = 1;
    let mut current: u64 = 0;
    let mut buffer: u64;
    let mut position: u64 = 1;

    return loop {
        if position == number {
            break current;
        }

        buffer = last;
        last = current;
        current = buffer + current; 
        position += 1;
    };
}
#[cfg(test)]
mod tests {
    use super::*;
    use test::Bencher;

    #[test]
    fn it_works() {
       assert_eq!(fibonacci_u64(1), 0); 
       assert_eq!(fibonacci_u64(2), 1); 
       assert_eq!(fibonacci_u64(12), 89); 
       assert_eq!(fibonacci_u64(30), 514229); 
    }

    #[bench]
    fn bench_u64(b: &amp;mut Bencher) {
        b.iter(|| {
            for i in 100..200 {
                fibonacci_u64(i);
            }
        });
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>通过<code>cargo bench</code>运行后，得到一个难以置信的结果：<code>test tests::bench_u64 ... bench: 0 ns/iter (+/- 0)</code>, 难道Rust已经到达量子计算机级别了？</p>
<p>其实，原因藏在<code>LLVM</code>中: <code>LLVM</code>认为<code>fibonacci_u64</code>函数调用的结果没有使用，同时也认为该函数没有任何副作用(造成其它的影响，例如修改外部变量、访问网络等), 因此它有理由把这个函数调用优化掉！</p>
<p>解决很简单，使用Rust标准库中的<a href="https://doc.rust-lang.org/std/hint/fn.black_box.html"><code>black_box</code></a>函数:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 100..200 {
    black_box(fibonacci_u64(black_box(i)));
}
<span class="boring">}
</span></code></pre></pre>
<p>通过这个函数，告诉编译器，尽量少的做优化，此时LLVM就不会再自作主张了:)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="持续集成"><a class="header" href="#持续集成">持续集成</a></h1>
<h2 id="github-ci"><a class="header" href="#github-ci">github ci</a></h2>
<p>https://github.com/julianandrews/sgf-render/blob/master/.github/workflows/build.yml</p>
<pre><code class="language-yml">name: build
on:
  workflow_dispatch: {}
jobs:
  build:
    name: build
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        build: [linux, macos, windows]
        include:
        - build: linux
          os: ubuntu-18.04
          rust: nightly
          target: x86_64-unknown-linux-musl
          archive-name: sgf-render-linux.tar.gz
        - build: macos
          os: macos-latest
          rust: nightly
          target: x86_64-apple-darwin
          archive-name: sgf-render-macos.tar.gz
        - build: windows
          os: windows-2019
          rust: nightly-x86_64-msvc
          target: x86_64-pc-windows-msvc
          archive-name: sgf-render-windows.7z
      fail-fast: false

    steps:
    - name: Checkout repository
      uses: actions/checkout@v2

    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: ${{ matrix.rust }}
        profile: minimal
        override: true
        target: ${{ matrix.target }}

    - name: Build binary
      run: cargo build --verbose --release --target ${{ matrix.target }}
      env:
        RUST_BACKTRACE: 1

    - name: Strip binary (linux and macos)
      if: matrix.build == 'linux' || matrix.build == 'macos'
      run: strip &quot;target/${{ matrix.target }}/release/sgf-render&quot;

    - name: Build archive
      shell: bash
      run: |
        mkdir archive
        cp LICENSE README.md archive/
        cd archive
        if [ &quot;${{ matrix.build }}&quot; = &quot;windows&quot; ]; then
          cp &quot;../target/${{ matrix.target }}/release/sgf-render.exe&quot; ./
          7z a &quot;${{ matrix.archive-name }}&quot; LICENSE README.md sgf-render.exe
        else
          cp &quot;../target/${{ matrix.target }}/release/sgf-render&quot; ./
          tar -czf &quot;${{ matrix.archive-name }}&quot; LICENSE README.md sgf-render
        fi
    - name: Upload archive
      uses: actions/upload-artifact@v1
      with:
        name: ${{ matrix.archive-name }}
        path: archive/${{ matrix.archive-name }}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常见特征解析"><a class="header" href="#常见特征解析">常见特征解析</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型转换frominto"><a class="header" href="#类型转换frominto">类型转换From/Into</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asref-asmut"><a class="header" href="#asref-asmut">AsRef, AsMut</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrow-borrowmut-toowned"><a class="header" href="#borrow-borrowmut-toowned">Borrow, BorrowMut, ToOwned</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deref和引用隐式转换"><a class="header" href="#deref和引用隐式转换">Deref和引用隐式转换</a></h1>
<p><code>Deref</code> 是解引用操作符<code>*</code>的特征，比如 *v。</p>
<p>一般理解，<code>*v</code>操作，是<code>&amp;v</code>的反向操作，是为了获取<code>&amp;v</code>指针指向的堆上对象。</p>
<h2 id="强制隐式转换"><a class="header" href="#强制隐式转换">强制隐式转换</a></h2>
<p>Deref最神奇、最好用的地方并不在本身<code>解引</code>这个意义上，Rust的设计者在它之上附加了一个特性：强制隐式转换，这才是它神奇之处。</p>
<p>这种隐式转换的规则为：</p>
<p>一个类型为<code>T</code>的对象<code>foo</code>，如果T: Deref&lt;Target=U&gt;，那么，相关<code>foo</code>的引用<code>&amp;foo</code>在应用的时候会自动转换<code>&amp;U</code>。</p>
<p>粗看这条规则，貌似有点类似于<code>AsRef</code>，而跟<code>解引</code>似乎风马牛不相及, 实际里面里面有些玄妙之处。</p>
<p>Rust编译器会在做<code>*v</code>操作的时候，自动先把<code>v</code>做引用归一化操作，即转换成内部通用引用的形式<code>&amp;v</code>，整个表达式就变成 <code>*&amp;v</code>。这里面有两种情况：</p>
<ol>
<li>把智能指针（比如在库中定义的，Box, Rc, Arc, Cow 等），去掉壳，转成内部标准形式<code>&amp;v</code>；</li>
<li>把多重<code>&amp;</code> （比如：<code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;v</code>），简化成<code>&amp;v</code>（通过插入足够数量的<code>*</code>进行解引）。
所以，它实际上在解引用之前做了一个引用的归一化操作。</li>
</ol>
<p>为什么要转呢？ 因为编译器设计的能力是，只能够对 &amp;v 这种引用进行解引用。其它形式的它不认识，所以要做引用归一化操作。</p>
<p>使用引用进行过渡也是为了能够防止不必要的拷贝。</p>
<p>下面举一些例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn foo(s: &amp;str) {
        // borrow a string for a second
    }

    // String implements Deref&lt;Target=str&gt;
    let owned = &quot;Hello&quot;.to_string();

    // therefore, this works:
    foo(&amp;owned);
<span class="boring">}
</span></code></pre></pre>
<p>因为<code>String</code>实现了<code>Deref&lt;Target=str&gt;</code>。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::rc::Rc;

    fn foo(s: &amp;str) {
        // borrow a string for a second
    }

    // String implements Deref&lt;Target=str&gt;
    let owned = &quot;Hello&quot;.to_string();
    let counted = Rc::new(owned);

    // therefore, this works:
    foo(&amp;counted);
<span class="boring">}
</span></code></pre></pre>
<p>因为<code>Rc&lt;T&gt;</code>实现了<code>Deref&lt;Target=T&gt;</code>。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn foo(s: &amp;[i32]) {
        // borrow a slice for a second
    }

    // Vec&lt;T&gt; implements Deref&lt;Target=[T]&gt;
    let owned = vec![1, 2, 3];

    foo(&amp;owned);
<span class="boring">}
</span></code></pre></pre>
<p>因为<code>Vec&lt;T&gt;</code> 实现了<code>Deref&lt;Target=[T]&gt;</code>。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct Foo;

    impl Foo {
        fn foo(&amp;self) { println!(&quot;Foo&quot;); }
    }

    let f = &amp;&amp;Foo;

    f.foo();
    (&amp;f).foo();
    (&amp;&amp;f).foo();
    (&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;f).foo();
<span class="boring">}
</span></code></pre></pre>
<p>上面那几种函数的调用，效果是一样的。</p>
<p>这种<code>Deref</code>涉及的隐式转换，实际上是Rust中仅有的类型隐式转换，设计它的目的，是为了简化程序的书写，让代码不至于过于繁琐。把人从无尽的类型细节中解脱出来，让书写 Rust 代码变成一件快乐的事情。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="写时拷贝cow"><a class="header" href="#写时拷贝cow">写时拷贝Cow</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eq"><a class="header" href="#eq">Eq</a></h1>
<p>The rules for == and friends in Rust are a bit complicated. Consider some type T that implements Eq:</p>
<ul>
<li>You can always compare objects of type T. The comparison will be notionally done as if by reference, meaning there will be no move or copy involved.</li>
<li>You can always compare references to objects of type T. The objects must match in &quot;reference depth&quot;: &amp;&amp;a == &amp;&amp;a is OK, &amp;a == &amp;&amp;a is not. Dereferences count here: &amp;<em>&amp;&amp;a == &amp;&amp;</em>&amp;a is OK.</li>
<li>Some types — for example, String — have a Deref implementation. This will play a role in comparisons because they are &quot;auto-derefed&quot;. For example, if s is a String then s == &quot;x&quot; is OK, because s will automatically be treated as &amp;str for comparison purposes.</li>
</ul>
<p>In general, you can't dereference a string literal. A string literal is of type <code>&amp;'static str</code>. If you dereference it you get a str, which is unsized and thus really hard to work with.</p>
<p>However, <code>==</code> and friends are special. From the Rust Reference Manual:</p>
<blockquote>
<p>Unlike the arithmetic and logical operators above, these operators implicitly take shared borrows of their operands, evaluating them in place expression context:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a == b;
// is equivalent to
::std::cmp::PartialEq::eq(&amp;a, &amp;b);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>This means that the operands don't have to be moved out of.
So when you write <code>*&quot;s&quot; == *&quot;t&quot;</code> it is treated as</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>::std::cmp::PartialEq::eq(&amp;*&quot;s&quot;, &amp;*&quot;t&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>and thus works even though it looks like it shouldn't.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="深入内存"><a class="header" href="#深入内存">深入内存</a></h1>
<p>部分内容借鉴了Rust in action和Rust高级编程</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="指针和引用todo"><a class="header" href="#指针和引用todo">指针和引用(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="未初始化内存"><a class="header" href="#未初始化内存">未初始化内存</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存分配todo"><a class="header" href="#内存分配todo">内存分配(todo)</a></h1>
<p>https://www.reddit.com/r/rust/comments/s4pknf/investigating_memory_allocations_in_rust/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存布局todo"><a class="header" href="#内存布局todo">内存布局(todo)</a></h1>
<p>https://www.reddit.com/r/rust/comments/rwta4h/why_arent_rust_structs_laid_out_in_memory_like_c/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="虚拟内存"><a class="header" href="#虚拟内存">虚拟内存</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web应用开发-todo"><a class="header" href="#web应用开发-todo">Web应用开发 todo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编解码与序列化-todo"><a class="header" href="#编解码与序列化-todo">编解码与序列化 todo</a></h1>
<h2 id="多次序列化产出同一结果"><a class="header" href="#多次序列化产出同一结果">多次序列化产出同一结果</a></h2>
<p>https://www.reddit.com/r/rust/comments/rrizq5/is_serdejson_serialization_deterministic/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="面向对象"><a class="header" href="#面向对象">面向对象</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oo所需的特性"><a class="header" href="#oo所需的特性">OO所需的特性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计模式"><a class="header" href="#设计模式">设计模式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macro"><a class="header" href="#macro">macro</a></h1>
<p>https://www.reddit.com/r/rust/comments/s3mm8m/macro_hygiene/</p>
<div style="break-before: page; page-break-before: always;"></div><p>https://www.reddit.com/r/rust/comments/rjumsg/any_good_resources_for_learning_rust_macros/</p>
<p>https://www.reddit.com/r/rust/comments/roaofg/procedural_macros_parsing_custom_syntax/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance"><a class="header" href="#performance">performance</a></h1>
<h2 id="how-do-i-profile-a-rust-web-application-in-production"><a class="header" href="#how-do-i-profile-a-rust-web-application-in-production">How do I profile a Rust web application in production?</a></h2>
<p>https://www.reddit.com/r/rust/comments/rupcux/how_do_i_profile_a_rust_web_application_in/</p>
<p>https://zhuanlan.zhihu.com/p/191655266</p>
<h2 id="内存对齐"><a class="header" href="#内存对齐">内存对齐</a></h2>
<p>https://www.reddit.com/r/rust/comments/s793x7/force_4byte_memory_alignment/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust所有权转移时发生了奇怪的深拷贝"><a class="header" href="#rust所有权转移时发生了奇怪的深拷贝">Rust所有权转移时发生了奇怪的深拷贝</a></h1>
<p>深拷贝可以说是Rust性能优化的禁忌之词，但是在最不该发生深拷贝的地方却发生了, 本文带领大家来深入分析下原因。</p>
<p>在所有权章节中，我们详细介绍过<a href="https://course.rs/basic/ownership/ownership.html#%E8%BD%AC%E7%A7%BB%E6%89%80%E6%9C%89%E6%9D%83">所有权转移(move)</a>, 里面提到过一个重点：当类型实现<code>Copy</code>特征时，不会转移所有权，而是直接对值进行拷贝：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 1;
    let y = x;
    // 不会报错
    println!(&quot;我(x)的值仅仅是被复制了，我还拥有值的所有权，不信你看：{:?}&quot;,x);

    let s = &quot;aaa&quot;.to_string();
    let s1 = s;
    // 会报错
    println!(&quot;我(s)的值被转移给了s1，我已经失去所有权了: {}&quot;,s);
}
</code></pre></pre>
<p>这里的<code>x</code>是数值类型，因此实现了<code>Copy</code>特征，当赋值给<code>y</code>时，仅仅是复制了值，并没有把所有权转移给<code>y</code>，但是<code>s</code>恰好相反，它没有实现<code>Copy</code>特征，当赋值后，所有权被转移给<code>s1</code>，最终导致了最后一行代码的报错.</p>
<p>根据之前的所有权学习章节，所有权转移时的仅仅是复制一个引用，并不会复制底层的数据，例如上面代码中，<code>s</code>的所有权转移给<code>s1</code>时，仅仅是复制了一个引用，该引用继续指向之前的字符串底层数据，因此<strong>所有权转移的性能是非常高的</strong>。</p>
<p>但是如果一切都这么完美，也不会出现这篇文章了，实际上是怎么样？先来看一段代码.</p>
<h2 id="move时发生了数据的深拷贝"><a class="header" href="#move时发生了数据的深拷贝">move时发生了数据的深拷贝</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">struct LargeArray {
    a: [i128; 10000],
}

impl LargeArray {
    #[inline(always)]
    fn transfer(mut self) -&gt; Self {
        println!(&quot;{:?}&quot;, &amp;mut self.a[1] as *mut i128);

        // 改变数组中的值
        self.a[1] += 23;
        self.a[4] += 24;

        // 返回所有权
        self
    }
}

fn main() {
    let mut f = LargeArray { a: [10i128; 10000] };

    println!(&quot;{:?}&quot;, &amp;mut f.a[1] as *mut i128);

    let mut f2 = f.transfer();

    println!(&quot;{:?}&quot;, &amp;mut f2.a[1] as *mut i128);
}
</code></pre></pre>
<p>上面的例子很简单，创建了一个结构体<code>f</code>(内部有一个大数组)，接着将它的所有权转移给<code>transfer</code>方法，最后再通过<code>Self</code>返回，转移给<code>f2</code>，在此过程中，观察结构体中的数组第二个元素的内存地址如何变化。</p>
<p>这里还有几个注意点：</p>
<ul>
<li><code>LargeArray</code>没有实现<code>Copy</code>特征，因此在所有权转移时， <strong>本应该</strong>只是复制一下引用，底层的数组并不会被复制</li>
<li><code>transfer</code>方法的参数<code>self</code>表示接收所有权，而不是借用，返回类型<code>Self</code>也表示返回所有权，而不是返回借用, 具体内容在<a href="https://course.rs/basic/method.html">方法</a>章节有介绍</li>
</ul>
<p>从上可知，我们并不应该去复制底层的数组，那么底层数组的地址也不应该变化，换而言之三次内存地址输出应该是同一个地址。但是真的如此吗？世事难料：</p>
<pre><code class="language-console">0x16f9d6870
0x16fa4bbc0
0x16fa24ac0
</code></pre>
<p>果然，结果让人大跌眼镜，竟然三次地址都不一样，意味着每次转移所有权都发生了底层数组的深拷贝！什么情况？！！如果这样，我们以后还能信任Rust吗？完全不符合官方的宣传。</p>
<p>在福建有一个武夷山5A景区，不仅美食特别好吃，而且风景非常优美，其中最著名的就是历时1个多小时的九曲十八弯漂流，而我们的结论是否也能像漂游一样来个大转折？大家拭目以待。</p>
<h2 id="罪魁祸首println"><a class="header" href="#罪魁祸首println">罪魁祸首println?</a></h2>
<p>首先，通过谷歌搜索，我发现了一些蛛丝马迹，有文章提到如果通过<code>println</code>输出内存地址，可能会导致编译器优化失效，也就是从本该有的所有权转移变成了深拷贝，不妨来试试。</p>
<p>但是问题又来了，如果不用<code>println</code>或者类似的方法，我们怎么观察内存地址？好像陷入了绝路。。。只能从Rust之外去想办法了，此时大学学过的汇编发挥了作用：</p>
<pre><code class="language-asm">.LCPI0_0:
        .quad   10
        .quad   0
example::xxx:
        mov     eax, 160000
        call    __rust_probestack
        sub     rsp, rax
        mov     rax, rsp
        lea     rcx, [rsp + 160000]
        vbroadcasti128  ymm0, xmmword ptr [rip + .LCPI0_0]
.LBB0_1:
        vmovdqu ymmword ptr [rax], ymm0
        vmovdqu ymmword ptr [rax + 32], ymm0
        vmovdqu ymmword ptr [rax + 64], ymm0
        vmovdqu ymmword ptr [rax + 96], ymm0
        vmovdqu ymmword ptr [rax + 128], ymm0
        vmovdqu ymmword ptr [rax + 160], ymm0
        vmovdqu ymmword ptr [rax + 192], ymm0
        vmovdqu ymmword ptr [rax + 224], ymm0
        vmovdqu ymmword ptr [rax + 256], ymm0
        vmovdqu ymmword ptr [rax + 288], ymm0
        vmovdqu ymmword ptr [rax + 320], ymm0
        vmovdqu ymmword ptr [rax + 352], ymm0
        vmovdqu ymmword ptr [rax + 384], ymm0
        vmovdqu ymmword ptr [rax + 416], ymm0
        vmovdqu ymmword ptr [rax + 448], ymm0
        vmovdqu ymmword ptr [rax + 480], ymm0
        vmovdqu ymmword ptr [rax + 512], ymm0
        vmovdqu ymmword ptr [rax + 544], ymm0
        vmovdqu ymmword ptr [rax + 576], ymm0
        vmovdqu ymmword ptr [rax + 608], ymm0
        add     rax, 640
        cmp     rax, rcx
        jne     .LBB0_1
        mov     rax, qword ptr [rsp + 16]
        mov     rdx, qword ptr [rsp + 24]
        add     rax, 69
        adc     rdx, 0
        add     rsp, 160000
        vzeroupper
        ret
</code></pre>
<p>去掉所有<code>println</code>后的汇编生成如上所示(大家可以在godbolt上自己尝试)，以我蹩脚的汇编水平来看，貌似没有任何数组拷贝的发生，也就是说：
如同量子的不可观测性，我们的<code>move</code>也这么傲娇？我们用println观测，它就傲娇去复制，不观测时，就老老实实转移所有权？WTF!</p>
<p>事情感觉进入了僵局，下一步该如何办？</p>
<h2 id="栈和堆的不同move行为"><a class="header" href="#栈和堆的不同move行为">栈和堆的不同move行为</a></h2>
<p>我突然灵光一现，想到一个问题，之前的所有权转移其实可以分为两类：<strong>栈上数据的复制和堆上数据的转移</strong>，这也是非常符合直觉的，例如<code>i32</code>这种类型实现了<code>Copy</code>特征，可以存储在栈上，因此它就是复制行为，而<code>String</code>类型是引用存储在栈上，底层数据存储在堆上，因此转移所有权时只需要复制一下引用即可。</p>
<p>那问题来了，我们的<code>LargeArray</code>存在哪里？这也许就是一个破局点！</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LargeArray {
    a: [i128; 10000],
}
<span class="boring">}
</span></code></pre></pre>
<p>结构体是一个复合类型，它内部字段的数据存在哪里，就大致决定了它存在哪里。而该结构体里面的<code>a</code>字段是一个数组，而不是动态数组<code>Vec</code>，从<a href="https://course.rs/basic/compound-type/array.html#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84">数组</a>章节可知：数组是存储在栈上的数据结构！</p>
<p>再想想，栈上的数据在<code>move</code>的时候，是要从一个栈复制到另外一个栈的，那是不是内存地址就变了？！因此，就能完美解释，为什么使用<code>println</code>时，数组的地址会变化了，是因为栈上的数组发生了复制。</p>
<p>但是问题还有，为什么不使用<code>println</code>，数组地址就不变？要解释清楚这个问题，先从编译器优化讲起。</p>
<h2 id="编译器对move的优化"><a class="header" href="#编译器对move的优化">编译器对move的优化</a></h2>
<p>从根本上来说，<code>move</code>就意味着拷贝复制，只不过看是浅拷贝还是深拷贝，对于堆上的数据来说，浅拷贝只复制引用，而栈上的数据则是整个复制。</p>
<p>但是在实际场景中，由于编译器的复杂实现，它能优化的场景远比我们想象中更多，例如对于<code>move</code>过程中的复制，编译器有可能帮你优化掉，在没有<code>println</code>的代码中，该<code>move</code>过程就被Rust编译器优化了。</p>
<p>但是这种编译器优化非常复杂，而且随着Rust的版本更新在不停变化，因此几乎没有人能说清楚这里面的门门道道，但是有一点可以知道：<strong><code>move</code>确实存在被优化的可能性，最终避免了复制的发生</strong>.</p>
<p>那么<code>println</code>没有被优化的原因也呼之欲出了: 它阻止了编译器对<code>move</code>的优化。</p>
<h2 id="println阻止了优化"><a class="header" href="#println阻止了优化">println阻止了优化</a></h2>
<p>编译器优化的一个基本准则就是：中间过程没有其它代码在使用，则可以尝试消除这些中间过程。</p>
<p>回头来看看<code>println</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{:?}&quot;, &amp;mut f.a[1] as *mut i128);
<span class="boring">}
</span></code></pre></pre>
<p>它需要打印数组在各个点的内存地址，假如编译器优化了复制，那这些中间状态的内存地址是不是就丢失了？对于这种可能会导致状态丢失的情况，编译器是不可能进行优化的，因此<code>move</code>时的栈上数组复制就顺理成章的发生了, 还是2次。</p>
<h2 id="最佳实践-1"><a class="header" href="#最佳实践-1">最佳实践</a></h2>
<p>那么，在实践中遇到这种情况怎么办？</p>
<h4 id="mut-self"><a class="header" href="#mut-self">&amp;mut self</a></h4>
<p>其实办法也很多，首当其冲的就是使用<code>&amp;mut self</code>进行可变借用，而不是转移进来所有权，再转移出去。</p>
<h4 id="box分配到堆上"><a class="header" href="#box分配到堆上">Box分配到堆上</a></h4>
<p>如果你确实需要依赖所有权的转移来实现某个功能(例如链式方法调用:<code>x.a().b()...</code>)，那么就需要使用<code>Box</code>把该数组分配在堆上，而不是栈上：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct LargeArray {
    a: Box&lt;[i128; 10000]&gt;,
}

impl LargeArray {
    #[inline(always)]
    fn transfer(mut self) -&gt; Self {
        println!(&quot;{:?}&quot;, &amp;mut self.a[1] as *mut i128);

        //do some stuff to alter it
        self.a[1] += 23;
        self.a[4] += 24;

        //return the same object
        self
    }
}

fn main() {
    let mut f = LargeArray { a: Box::new([10i128; 10000] )};

    println!(&quot;{:?}&quot;, &amp;mut f.a[1] as *mut i128);

    let mut f2 = f.transfer();

    println!(&quot;{:?}&quot;, &amp;mut f2.a[1] as *mut i128);
}
</code></pre></pre>
<p>输出如下:</p>
<pre><code>0x138008010
0x138008010
0x138008010
</code></pre>
<p>完美符合了我们对堆上数据的预期，hooray!</p>
<h4 id="神龟莫测的编译器优化"><a class="header" href="#神龟莫测的编译器优化">神龟莫测的编译器优化</a></h4>
<p>当然，你也可以选择相信编译器的优化，虽然很难识它真面目，同时它的行为也神鬼莫测，但是总归是在之前的例子中证明了，它确实可以，不是嘛？ = , =</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="糟糕的提前优化"><a class="header" href="#糟糕的提前优化">糟糕的提前优化</a></h1>
<h2 id="函数调用"><a class="header" href="#函数调用">函数调用</a></h2>
<p>由于Rust的编译器和LLVM很强大，因此就算你使用了多层函数调用去完成一件事(嵌套函数调用往往出于设计上的考虑)，依然不会有性能上的影响，因为最终生成的机器码会消除这些多余的函数调用。</p>
<p>总之用Rust时，你不必操心多余的函数调用，只要写合理的代码，然后Rust会帮助你运行的更快!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clone和copy"><a class="header" href="#clone和copy">Clone和Copy</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmark"><a class="header" href="#benchmark">benchmark</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="减少runtime-check"><a class="header" href="#减少runtime-check">减少runtime check</a></h1>
<h2 id="减少集合访问的边界检查"><a class="header" href="#减少集合访问的边界检查">减少集合访问的边界检查</a></h2>
<p>以下代码，我们实现了两种循环方式：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 第一种
let collection = [1, 2, 3, 4, 5];
for i in 0..collection.len() {
  let item = collection[i];
  // ...
}

// 第二种
for item in collection {

}
<span class="boring">}
</span></code></pre></pre>
<p>第一种方式是循环索引，然后通过索引下标去访问集合，第二种方式是直接循环迭代集合中的元素，优劣如下：</p>
<ul>
<li><strong>性能</strong>：第一种使用方式中<code>collection[index]</code>的索引访问，会因为边界检查(bounds checking)导致运行时的性能损耗 - Rust会检查并确认<code>index</code>是落在集合内也就是合法的，但是第二种直接迭代的方式就不会触发这种检查,因为编译器会在编译时就完成分析并证明这种访问是合法的`</li>
</ul>
<h2 id="boxleak-2"><a class="header" href="#boxleak-2">Box::leak</a></h2>
<p>https://www.reddit.com/r/rust/comments/rntx7s/why_use_boxleak/</p>
<h2 id="bounds-check"><a class="header" href="#bounds-check">bounds check</a></h2>
<p>https://www.reddit.com/r/rust/comments/rnbubh/whats_the_big_deal_with_bounds_checking/</p>
<p>https://www.reddit.com/r/rust/comments/s6u65e/optimization_of_bubble_sort_fails_without_hinting/</p>
<h2 id="使用assert-优化检查性能"><a class="header" href="#使用assert-优化检查性能">使用assert 优化检查性能</a></h2>
<p>https://www.reddit.com/r/rust/comments/rui1zz/write_assertions_that_clarify_code_to_both_the/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cpu缓存性能优化"><a class="header" href="#cpu缓存性能优化">CPU缓存性能优化</a></h1>
<p>https://github.com/TC5027/blog/blob/master/false_sharing.md</p>
<h1 id="on-a-use-of-the-repr-attribute-in-rust"><a class="header" href="#on-a-use-of-the-repr-attribute-in-rust">On a use of the &quot;repr&quot; attribute in Rust</a></h1>
<p>Consider we work with the following struct representing a counter,</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counter(u64);
<span class="boring">}
</span></code></pre></pre>
<p>and we want to increment it with random <code>u8</code> values with the help of a for loop : </p>
<pre><pre class="playground"><code class="language-rust edition2021">use rand::Rng;
fn main() {
	let mut counter = Counter(0);
	let mut rng = rand::thread_rng();
	
	for _ in 0..1_000_000 {
		counter.0 += rng.gen::&lt;u8&gt;() as u64;
	}
}
</code></pre></pre>
<p>This takes 1.90ms to run on my laptop using <code>cargo run --release</code>. Remember this timing as it will be our reference value :)
Now suppose we were given this struct, holding not 1 but 2 counters : </p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counters {
	c1 : u64,
	c2 : u64
}
<span class="boring">}
</span></code></pre></pre>
<p>Using the same approach, performing the increments for the 2 counters in a single-threaded fashion, we would expect to be twice slower (in fact it takes 3.71ms to execute).
Can we do better ? Well, as our 2 counters are independent, we could spawn 2 threads, assign them one counter and increment concurrently ! Given I have 4 CPUs on my laptop, I would expect to be just as fast as the first scenario. Let's see !</p>
<p>First thing, we could create a local variable in each thread which would be incremented and then we would set the counter value to this incremented one (spoiler : good idea). But we could also save these 2 variables and share the <code>Counter</code> between the 2 threads with an <code>Arc</code> (spoiler : definitely not worth). Let's do this second option ! ^^</p>
<p>Doing the following code, </p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	let counters = Arc::new(Counters{c1:0, c2:0});
	let counters_clone = counters.clone();
	
	let handler1 = thread::spawn(move || {
		let mut rng = rand::thread_rng();
		for _ in 0..1_000_000 {
			counters.c1 += rng.gen::&lt;u8&gt;() as u64;
		}
	});
	let handler2 = thread::spawn(move || {
		let mut rng = rand::thread_rng();
		for _ in 0..1_000_000 {
			counters_clone.c2 += rng.gen::&lt;u8&gt;() as u64;
		}
	});
	handler1.join(); handler2.join();
}
</code></pre></pre>
<p>we end up with an error : </p>
<p><strong>cannot assign to data in an <code>Arc</code></strong>
<strong>cannot assign</strong>
<strong>help: trait <code>DerefMut</code> is required to modify through a dereference, but it is not implemented for <code>std::sync::Arc&lt;Counters&gt;</code>rustc(E0594)</strong></p>
<p>Unlucky. Maybe we could use <strong>atomic types</strong>. These types provide operations that synchronize updates between threads. In fact, as an equivalent of <code>+=</code> we could use the <code>fetch_add</code> method which has the following signature : <code>pub fn fetch_add(&amp;self, val: u64, order: Ordering) -&gt; u64</code>. What should be highlighted is the <code>&amp;self</code>. We could expect a <code>&amp;mut self</code> given the modification we want to perform using it but thanks to the property that an atomic operation is performed without interruptions we don't need exclusive access to the variable to safely update it.
We can solve the error replacing the counter's type by <code>AtomicU64</code> as like that we only require <code>Arc</code> to implement the <code>Deref</code> trait (given the signature of <code>fetch_add</code>) and it is the case !</p>
<p>We so have to change a bit our struct to : </p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counters {
	c1 : AtomicU64,
	c2 : AtomicU64,
}
<span class="boring">}
</span></code></pre></pre>
<p>and our code to :</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let counters = Arc::new(Counters{
        c1 :  AtomicU64::new(0),
        c2 : AtomicU64::new(0)
    });
    let counters_clone = counters.clone();
    let handler1 = thread::spawn(move || {
        let mut rng = rand::thread_rng();
        for _ in 0..1_000_000 {
            counters.c1.fetch_add(rng.gen::&lt;u8&gt;() as u64,Relaxed);
        }
    });
    let handler2 = thread::spawn(move || {
        let mut rng = rand::thread_rng();
        for _ in 0..1_000_000 {
            counters_clone.c2.fetch_add(rng.gen::&lt;u8&gt;() as u64,Relaxed);
        }
    });
    handler1.join();handler2.join();
}
</code></pre></pre>
<p>We could naturally expect the operation on Atomics to be a bit slower than the ones on <code>u64</code> but let's see !
30.22ms .. ok... that's terrible ^^
Do Atomics operations explain all this ?
I ran a benchmark to compare <code>+=</code> and <code>fetch_add( ,Relaxed)</code> to figure it out : </p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut sum = 0;
let start = Instant::now();
for _ in 0..10_000_000 {
	sum += rng.gen::&lt;u8&gt;() as u64;
}
println!(&quot;time spent u64 sum : {:?}&quot;, start.elapsed());
let atomic_sum = AtomicU64::new(0);
let start = Instant::now();
for _ in 0..10_000_000 {
	atomic_sum.fetch_add(rng.gen::&lt;u8&gt;() as u64, Relaxed);
}
println!(&quot;time spent AtomicU64 sum : {:?}&quot;, start.elapsed());
<span class="boring">}
</span></code></pre></pre>
<p>The <code>u64</code> sums takes 20.07ms while the <code>AtomicU64</code> one takes 70.28ms. So we should only be 3 times slower than 2ms but we are 15 times slower how can it be ???</p>
<p>Hint : CPU cache... but why should we care ?
CPU cache is a data storage, located close to CPU, offering a fast access to data.
In a computer, when the CPU needs to read or write a value, it checks if it is present inside the cache or not. If it is the case then the CPU directly uses the cached data. Otherwise, the cache allocates a new entry and copies data from main memory, an entry being of fixed size and called <em>cache line</em>.
CPU cache is relatively small compared to RAM but much faster, and that's why a program should be designed to use as much as possible data lying in cache, based on a locality principle, to avoid expensive access to RAM.</p>
<p>If we represent our current situation it looks like this :
<img src="https://github.com/TC5027/blog/blob/master/pngs/false_sharing.png" alt="figure" /></p>
<p>The red square corresponds to the first counter and the green one to the second. They can potentially lie in the same cache line !</p>
<p>If data is modified through CPU 0 in its L1 cache we expect our computer to reflect the changes both in memory and in the other L1 cache. To ensure this coherency, there exists coherence protocols which can force the <strong>whole cache line</strong> impacted by the change to be propagated through the whole system, in order to update the copies of the value changed.</p>
<p>With that in mind, what is happening in our code comes from that : we suffer from coherency protocol due to our 2 counters lying on the same cache line. Updating first counter through CPU 0 involves an update in the system of the data stored in the cache line where the second counter (unchanged) potentially lies. During this update, CPU 1 cannot access the second counter whereas it is clearly independent from the change made by CPU 0, and that's why we are slow.
How can we solve then ? well by making sure that the counters lie on different cache lines and that's where we can use the <code>repr</code> attribute.</p>
<p>In Rust, we can specify the alignment we want for our type with the <code>repr(align)</code> attribute. We use it like this : </p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(align(64))]
struct CachePadded(AtomicU64);
<span class="boring">}
</span></code></pre></pre>
<p>A data of alignment X is stored in memory at address multiple of X. Knowing this, giving to our counters an alignment equal to the size of a cache line, we ensure that the 2 counters won't be stored in the same cache line !</p>
<p>We can get the size of cache lines with command <code>getconf LEVEL1_DCACHE_LINESIZE</code>. On my laptop the output value is 64.</p>
<p>With those changes we have now a timing of 7.16ms which seems decent given we work with Atomics. Mission succeeded ! </p>
<p>Finally given my remark at the beginning, I wanted to share a potentially better solution, using local variables in the threads, and channels to communicate these local variables back to the main thread :</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc::channel;
fn main() {
    let (s1,t1) = channel();
    let (s2,t2) = channel();
    let h1 = thread::spawn(move || {
        let mut local_counter = 0;
        let mut rng = rand::thread_rng();
        for _ in 0..1_000_000 {
            local_counter += rng.gen::&lt;u8&gt;() as u64;
        }
        s1.send(local_counter)
    });
    let h2 = thread::spawn(move || {
        let mut local_counter = 0;
        let mut rng = rand::thread_rng();
        for _ in 0..1_000_000 {
            local_counter += rng.gen::&lt;u8&gt;() as u64;
        }
        s2.send(local_counter)
    });
    
    h1.join();
    h2.join();
    let counter = Counters{c1: t1.recv().unwrap(),c2: t2.recv().unwrap()};
}
</code></pre></pre>
<p>It takes 2.03 ms to execute :)</p>
<h2 id="动态和静态分发"><a class="header" href="#动态和静态分发">动态和静态分发</a></h2>
<p>https://www.reddit.com/r/rust/comments/ruavjm/is_there_a_difference_in_performance_between/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="计算性能优化"><a class="header" href="#计算性能优化">计算性能优化</a></h1>
<p>https://www.reddit.com/r/rust/comments/rn7ozz/find_perfect_number_comparison_go_java_rust/</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;math&quot;
	&quot;time&quot;
)

func main() {
	n := 320000
	nums := make(map[int][]int)
	start := time.Now()
	calPerfs(n, nums)
	fmt.Printf(&quot;runtime: %s\n&quot;, time.Since(start))
}

func calPerfs(n int, nums map[int][]int) {
	for i := 1; i &lt;= n; i++ {
		d := divs(i)
		if sum(d) == i {
			nums[i] = all(d)
		}
	}
}

func divs(num int) map[int]struct{} {
	r := make(map[int]struct{})
	r[1] = struct{}{}
	mid := int(math.Sqrt(float64(num)))
	for i := 2; i &lt;= mid; i++ {
		if num%i == 0 {
			r[i] = struct{}{}
			r[num/i] = struct{}{}
		}
	}
	return r
}

func sum(ds map[int]struct{}) int {
	var n int
	for k := range ds {
		n += k
	}
	return n
}

func all(ds map[int]struct{}) []int {
	var a []int
	for k := range ds {
		a = append(a, k)
	}
	return a
}
</code></pre>
<h2 id="120ms"><a class="header" href="#120ms">120ms</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use std::time::Instant;

const N: usize = 320_000	;

fn is_perfect(n: usize) -&gt; bool {
    //println!(&quot;{:?}&quot;, n);
    let mut sum = 1;
    let end = (n as f64).sqrt() as usize;
    for i in 2..end  + 1{
        if n % i == 0 {
            if i * i == n {
                sum += i;
            }
            else {
                sum += i + n / i;
            }
        }
    }
    sum == n
}

fn find_perfs(n: usize) -&gt; Vec&lt;usize&gt; {
    let mut perfs:Vec&lt;usize&gt; = vec![];
    for i in 2..n + 1 {
        if is_perfect(i) {
            perfs.push(i)
        }
    }
    perfs
}

fn main() {
    let start = Instant::now();
    let perfects = find_perfs(N);
    println!(&quot;{:?}&quot;, start.elapsed());
    println!(&quot;{:?}, in {:?}&quot;, perfects, N);
}
</code></pre></pre>
<h2 id="90ms"><a class="header" href="#90ms">90ms</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use {
    std::{time::Instant},
};

const N: usize = 320000;

// Optimized, takes about 320ms on an Core i7 6700 @ 3.4GHz
fn cal_perfs2(n: usize) -&gt; Vec&lt;usize&gt; {
    (1..=n)
        .into_iter()
        .filter(|i| cal2(*i) == *i)
        .collect::&lt;Vec&lt;_&gt;&gt;()
}

fn cal2(n: usize) -&gt; usize {
    (2..=(n as f64).sqrt() as usize)
        .into_iter()
        .filter_map(|i| if n % i == 0 { Some([i, n / i]) } else { None })
        .map(|a| a[0] + a[1])
        .sum::&lt;usize&gt;()
        + 1
}


fn main() {
    let start = Instant::now();
    let perf2 = cal_perfs2(N);
    println!(&quot;{:?}&quot;,perf2);
    println!(&quot;Optimized: {:?}&quot;, start.elapsed());
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="堆和栈"><a class="header" href="#堆和栈">堆和栈</a></h1>
<p>https://www.reddit.com/r/rust/comments/rkddg3/stackheap_question_regarding_performance/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存allocator-todo"><a class="header" href="#内存allocator-todo">内存allocator todo</a></h1>
<p>https://www.reddit.com/r/rust/comments/s28g4x/allocating_many_boxes_at_once/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常用性能测试工具"><a class="header" href="#常用性能测试工具">常用性能测试工具</a></h1>
<p>https://era.co/blog/unbuffered-io-slows-rust-programs</p>
<h1 id="profiling"><a class="header" href="#profiling">profiling</a></h1>
<p>https://www.reddit.com/r/rust/comments/rxj81f/rust_profiling/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum内存优化-todo"><a class="header" href="#enum内存优化-todo">Enum内存优化 todo</a></h1>
<p>https://blog.zhuangty.com/rust-enum-layout/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="对抗编译检查-1"><a class="header" href="#对抗编译检查-1">对抗编译检查</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常见属性标记"><a class="header" href="#常见属性标记">常见属性标记</a></h1>
<h2 id="强制内存对齐"><a class="header" href="#强制内存对齐">强制内存对齐</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(align(64))]
struct CachePadded(AtomicU64);
<span class="boring">}
</span></code></pre></pre>
<p>A data of alignment X is stored in memory at address multiple of X</p>
<p>https://doc.rust-lang.org/reference/attributes.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="优化编译速度"><a class="header" href="#优化编译速度">优化编译速度</a></h1>
<p>https://www.reddit.com/r/rust/comments/rnkyc0/why_does_my_code_compile_faster_on_nightly/</p>
<p>https://www.reddit.com/r/rust/comments/rv8126/speedup_compilation_time/</p>
<p>https://www.reddit.com/r/rust/comments/rsfcgb/why_is_my_rust_build_so_slow/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编译器优化"><a class="header" href="#编译器优化">编译器优化</a></h1>
<p>在Rust中，一段很不起眼的代码中可能也隐藏着玄机，编译器在细无声的为我们做着各种优化，本章将记录这些优化，帮助大家更好的理解程序的性能。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option枚举"><a class="header" href="#option枚举">Option枚举</a></h1>
<p>https://www.reddit.com/r/learnrust/comments/rz34ht/where_does_the_data_go_if_you_replace_some_with/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="日志和监控"><a class="header" href="#日志和监控">日志和监控</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="日志"><a class="header" href="#日志">日志</a></h1>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   if cfg!(debug_assertions) {
       eprintln!(&quot;debug: {:?} -&gt; {:?}&quot;,
              record, fields);
     }
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可观测性"><a class="header" href="#可观测性">可观测性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="监控apm"><a class="header" href="#监控apm">监控(APM)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标准库解析"><a class="header" href="#标准库解析">标准库解析</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="寻找你想要的内容"><a class="header" href="#寻找你想要的内容">寻找你想要的内容</a></h1>
<p>https://www.reddit.com/r/rust/comments/rk8lf6/how_do_you_find_all_the_functions_available_for_a/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector常用方法"><a class="header" href="#vector常用方法">Vector常用方法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator常用方法"><a class="header" href="#iterator常用方法">Iterator常用方法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录"><a class="header" href="#附录">附录</a></h1>
<p>附录中包含了一些Rust常用概念的快速索引，方便你的日常查询使用。</p>
<blockquote>
<p>大部分的附录借鉴了Rust Book以及相应的<a href="https://rustwiki.org/zh-CN/book/">中文翻译书籍</a>，但同时做了一些的修改，增加准确性和阅读流畅度</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="附录-a关键字"><a class="header" href="#附录-a关键字">附录 A：关键字</a></h2>
<p>下面的列表包含 Rust 中正在使用或者以后会用到的关键字。因此，这些关键字不能被用作标识符（除了<a href="appendix/keywords.html#%E5%8E%9F%E7%94%9F%E6%A0%87%E8%AF%86%E7%AC%A6">原生标识符</a>），包括函数、变量、参数、结构体字段、模块、包、常量、宏、静态值、属性、类型、特征或生命周期。</p>
<h3 id="目前正在使用的关键字"><a class="header" href="#目前正在使用的关键字">目前正在使用的关键字</a></h3>
<p>如下关键字目前有对应其描述的功能。</p>
<ul>
<li><code>as</code> - 强制类型转换，或<code>use</code> 和 <code>extern crate</code>包和模块引入语句中的重命名</li>
<li><code>break</code> - 立刻退出循环</li>
<li><code>const</code> - 定义常量或原生常量指针（constant raw pointer）</li>
<li><code>continue</code> - 继续进入下一次循环迭代</li>
<li><code>crate</code> - 链接外部包</li>
<li><code>dyn</code> - 动态分发特征对象</li>
<li><code>else</code> - 作为 <code>if</code> 和 <code>if let</code> 控制流结构的 fallback</li>
<li><code>enum</code> - 定义一个枚举类型</li>
<li><code>extern</code> - 链接一个外部包,或者一个宏变量(该变量定义在另外一个包中)</li>
<li><code>false</code> - 布尔值 <code>false</code></li>
<li><code>fn</code> - 定义一个函数或 <strong>函数指针类型</strong> (<em>function pointer type</em>)</li>
<li><code>for</code> - 遍历一个迭代器或实现一个 trait 或者指定一个更高级的生命周期</li>
<li><code>if</code> - 基于条件表达式的结果来执行相应的分支</li>
<li><code>impl</code> - 为结构体或者特征实现具体功能</li>
<li><code>in</code> - <code>for</code> 循环语法的一部分</li>
<li><code>let</code> - 绑定一个变量</li>
<li><code>loop</code> - 无条件循环</li>
<li><code>match</code> - 模式匹配</li>
<li><code>mod</code> - 定义一个模块</li>
<li><code>move</code> - 使闭包获取其所捕获项的所有权</li>
<li><code>mut</code> - 在引用、原生指针或模式绑定中使用，表明变量是可变的</li>
<li><code>pub</code> - 表示结构体字段、<code>impl</code> 块或模块的公共可见性</li>
<li><code>ref</code> - 通过引用绑定</li>
<li><code>return</code> - 从函数中返回</li>
<li><code>Self</code> - 实现特征类型的类型别名</li>
<li><code>self</code> - 表示方法本身或当前模块</li>
<li><code>static</code> - 表示全局变量或在整个程序执行期间保持其生命周期</li>
<li><code>struct</code> - 定义一个结构体</li>
<li><code>super</code> - 表示当前模块的父模块</li>
<li><code>trait</code> - 定义一个特征</li>
<li><code>true</code> - 布尔值 <code>true</code></li>
<li><code>type</code> - 定义一个类型别名或关联类型</li>
<li><code>unsafe</code> - 表示不安全的代码、函数、特征或实现</li>
<li><code>use</code> - 在当前代码范围内(模块或者花括号对)引入外部的包、模块等</li>
<li><code>where</code> - 表示一个约束类型的从句</li>
<li><code>while</code> - 基于一个表达式的结果判断是否继续循环</li>
</ul>
<h3 id="保留做将来使用的关键字"><a class="header" href="#保留做将来使用的关键字">保留做将来使用的关键字</a></h3>
<p>如下关键字没有任何功能，不过由 Rust 保留以备将来的应用。</p>
<ul>
<li><code>abstract</code></li>
<li><code>async</code></li>
<li><code>await</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3 id="原生标识符"><a class="header" href="#原生标识符">原生标识符</a></h3>
<p>原生标识符（Raw identifiers）允许你使用通常不能使用的关键字，其带有 <code>r#</code> 前缀。</p>
<p>例如，<code>match</code> 是关键字。如果尝试编译如下使用 <code>match</code> 作为名字的函数：</p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
</code></pre>
<p>会得到这个错误：</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>该错误表示你不能将关键字 <code>match</code> 用作函数标识符。你可以使用原生标识符将 <code>match</code> 作为函数名称使用：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<p>此代码编译没有任何错误。注意 <code>r#</code> 前缀需同时用于函数名定义和 <code>main</code> 函数中的调用。</p>
<p>原生标识符允许使用你选择的任何单词作为标识符，即使该单词恰好是保留关键字。 此外，原生标识符允许你使用其它Rust版本编写的库。比如，<code>try</code> 在Rust 2015 edition 中不是关键字，却在Rust 2018 edition是关键字。所以如果用2015 edition 编写的库中带有 <code>try</code> 函数，在 2018 edition 中调用时就需要使用原始标识符语法，在这里是 <code>r#try</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="附录-b运算符与符号"><a class="header" href="#附录-b运算符与符号">附录 B：运算符与符号</a></h2>
<p>该附录包含了 Rust 目前出现过的各种符号，这些符号之前都分散在各个章节中。</p>
<h3 id="运算符"><a class="header" href="#运算符">运算符</a></h3>
<p>表 B-1 包含了 Rust 中的运算符、上下文中的示例、简短解释以及该运算符是否可重载。如果一个运算符是可重载的，则该运算符上用于重载的特征也会列出。</p>
<p>下表中，<code>expr</code>是表达式，<code>ident</code>是标识符,<code>type</code>是类型,<code>var</code>是变量，<code>trait</code>是特征,<code>pat</code>是匹配分支(pattern)。</p>
<p><span class="caption">表 B-1: 运算符</span></p>
<table><thead><tr><th>运算符</th><th>示例</th><th>解释</th><th>是否可重载</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>宏展开</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>按位非或逻辑非</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>var != expr</code></td><td>不等比较</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>算术求余</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>算术求余与赋值</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>借用</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>借用指针类型</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>按位与</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>按位与及赋值</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>逻辑与</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>算术乘法</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>算术乘法与赋值</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>解引用</td><td></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>原生指针</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>复合类型限制</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>算术加法</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>算术加法与赋值</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>参数以及元素分隔符</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>算术取负</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>算术减法</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>算术减法与赋值</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code></td><td>函数与闭包，返回类型</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>成员访问</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>右半开区间</td><td>PartialOrd</td></tr>
<tr><td><code>..=</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>闭合区间</td><td>PartialOrd</td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>结构体更新语法</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>“代表剩余部分”的模式绑定</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>(不推荐使用，用<code>..=</code>替代) 闭合区间</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>算术除法</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>算术除法与赋值</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>约束</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>结构体字段初始化</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>循环标志</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>语句和语句结束符</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>固定大小数组语法的部分</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>左移</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>左移与赋值</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>小于比较</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>小于等于比较</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>赋值/等值</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>等于比较</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>匹配分支语法的部分</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>大于比较</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>大于等于比较</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>右移</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>右移与赋值</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>模式绑定</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>按位异或</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>按位异或与赋值</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>模式匹配中的多个可选条件</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>按位或</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>按位或与赋值</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>逻辑或</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>错误传播</td><td></td></tr>
</tbody></table>
<h3 id="非运算符符号"><a class="header" href="#非运算符符号">非运算符符号</a></h3>
<p><span class="caption">表 B-2：独立语法</span></p>
<table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>生命周期名称或循环标签</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, 等</td><td>指定类型的数值常量</td></tr>
<tr><td><code>&quot;...&quot;</code></td><td>字符串常量</td></tr>
<tr><td><code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code>, etc.</td><td>原生字符串, 未转义字符</td></tr>
<tr><td><code>b&quot;...&quot;</code></td><td>字节字符串; 结果是一个 <code>[u8]</code> 类型而非<code>string</code>类型</td></tr>
<tr><td><code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code>, 等</td><td>原生字节字符串，原生和字节字符串字面值的结合</td></tr>
<tr><td><code>'...'</code></td><td>Char字符</td></tr>
<tr><td><code>b'...'</code></td><td>ASCII字节</td></tr>
<tr><td><code>|...| expr</code></td><td>闭包</td></tr>
<tr><td><code>!</code></td><td>代表总是空的类型，用于发散函数(无返回值函数)</td></tr>
<tr><td><code>_</code></td><td>模式绑定中表示忽略的意思；也用于增强整型字面值的可读性</td></tr>
</tbody></table>
<p>表 B-3展示了模块和对象调用路径的语法。</p>
<p><span class="caption">表 B-3：路径相关语法</span></p>
<table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>命名空间路径</td></tr>
<tr><td><code>::path</code></td><td>从当前的包的根路径开始的相对路径</td></tr>
<tr><td><code>self::path</code></td><td>与当前模块相对的路径（如一个显式相对路径）</td></tr>
<tr><td><code>super::path</code></td><td>与父模块相对的路径</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>关联常量、关联函数、关联类型</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>不可以被直接命名的关联项类型（如 <code>&lt;&amp;T&gt;::...</code>，<code>&lt;[T]&gt;::...</code>， 等）</td></tr>
<tr><td><code>trait::method(...)</code></td><td>使用特征名进行方法调用，以消除方法调用的二义性</td></tr>
<tr><td><code>type::method(...)</code></td><td>使用类型名进行方法调用, 以消除方法调用的二义性</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>将类型转换为特征，再进行方法调用,以消除方法调用的二义性</td></tr>
</tbody></table>
<p>表 B-4 展示了使用泛型参数时用到的符号。</p>
<p><span class="caption">表 B-4：泛型</span></p>
<table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>为一个类型中的泛型指定具体参数（如 <code>Vec&lt;u8&gt;</code>）</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>为一个泛型、函数或表达式中的方法指定具体参数，通常指双冒号(turbofish)（如 <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>）</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>泛型函数定义</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>泛型结构体定义</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>泛型枚举定义</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>实现泛型</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>高阶生命周期限制</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>泛型，其一个或多个相关类型必须被指定为特定类型（如 <code>Iterator&lt;Item=T&gt;</code>）</td></tr>
</tbody></table>
<p>表 B-5 展示了使用特征约束来限制泛型参数的符号。</p>
<p><span class="caption">表 B-5: 特征约束</span></p>
<table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>泛型参数 <code>T</code>需实现<code>U</code>类型</td></tr>
<tr><td><code>T: 'a</code></td><td>泛型 <code>T</code> 的生命周期必须长于 <code>'a</code>（意味着该类型不能传递包含生命周期短于 <code>'a</code> 的任何引用）</td></tr>
<tr><td><code>T : 'static</code></td><td>泛型 T只能使用声明周期为'static的引用</td></tr>
<tr><td><code>'b: 'a</code></td><td>生命周期<code>'b</code>必须长于生命周期<code>'a</code></td></tr>
<tr><td><code>T: ?Sized</code></td><td>使用一个不定大小的泛型类型</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>多个类型组成的复合类型限制</td></tr>
</tbody></table>
<p>表 B-6 展示了宏以及在一个对象上定义属性的符号。</p>
<p><span class="caption">表 B-6: 宏与属性</span></p>
<table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>外部属性</td></tr>
<tr><td><code>#![meta]</code></td><td>内部属性</td></tr>
<tr><td><code>$ident</code></td><td>宏替换</td></tr>
<tr><td><code>$ident:kind</code></td><td>宏捕获</td></tr>
<tr><td><code>$(…)…</code></td><td>宏重复</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>宏调用</td></tr>
</tbody></table>
<p>表 B-7 展示了写注释的符号。</p>
<p><span class="caption">表 B-7: 注释</span></p>
<table><thead><tr><th>符号</th><th>注释</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>行注释</td></tr>
<tr><td><code>//!</code></td><td>内部行(hang)文档注释</td></tr>
<tr><td><code>///</code></td><td>外部行文档注释</td></tr>
<tr><td><code>/*...*/</code></td><td>块注释</td></tr>
<tr><td><code>/*!...*/</code></td><td>内部块文档注释</td></tr>
<tr><td><code>/**...*/</code></td><td>外部块文档注释</td></tr>
</tbody></table>
<p>表 B-8 展示了出现在使用元组时的符号。</p>
<p><span class="caption">表 B-8: 元组</span></p>
<table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>空元组（亦称单元），即是字面值也是类型</td></tr>
<tr><td><code>(expr)</code></td><td>括号表达式</td></tr>
<tr><td><code>(expr,)</code></td><td>单一元素元组表达式</td></tr>
<tr><td><code>(type,)</code></td><td>单一元素元组类型</td></tr>
<tr><td><code>(expr, ...)</code></td><td>元组表达式</td></tr>
<tr><td><code>(type, ...)</code></td><td>元组类型</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>函数调用表达式；也用于初始化元组结构体 <code>struct</code> 以及元组枚举 <code>enum</code> 变体</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, etc.</td><td>元组索引</td></tr>
</tbody></table>
<p>表 B-9 展示了使用大括号的上下文。</p>
<p><span class="caption">表 B-9: 大括号</span></p>
<table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>代码块表达式</td></tr>
<tr><td><code>Type {...}</code></td><td>结构体字面值</td></tr>
</tbody></table>
<p>表 B-10 展示了使用方括号的上下文。</p>
<p><span class="caption">表 B-10: 方括号</span></p>
<table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>数组</td></tr>
<tr><td><code>[expr; len]</code></td><td>数组里包含<code>len</code>个<code>expr</code></td></tr>
<tr><td><code>[type; len]</code></td><td>数组里包含了<code>len</code>个<code>type</code>类型的对象</td></tr>
<tr><td><code>expr[expr]</code></td><td>集合索引。 重载（<code>Index</code>, <code>IndexMut</code>）</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>集合索引，也称为集合切片，索引要实现以下特征中的其中一个：<code>Range</code>，<code>RangeFrom</code>，<code>RangeTo</code> 或 <code>RangeFull</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-表达式"><a class="header" href="#c-表达式">C-表达式</a></h1>
<p>在[语句与表达式]章节中，我们对表达式有过介绍，下面对这些常用表达式进行一一说明。</p>
<h3 id="基本表达式"><a class="header" href="#基本表达式">基本表达式</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let n = 3;
let s = &quot;test&quot;;
<span class="boring">}
</span></code></pre></pre>
<h3 id="if表达式"><a class="header" href="#if表达式">if表达式</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let var1 = 10;

    let var2 = if var1 &gt;= 10 {
        var1
    } else {
        var1 + 10
    };
    
    println!(&quot;{}&quot;, var2);
}
</code></pre></pre>
<p>通过<code>if</code>表达式将值赋予<code>var2</code>.</p>
<p>你还可以在循环中结合<code>continue</code>、<code>break</code>来使用：`</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = 0;
for i in 1..10 {
    v = if i == 9 { 
        continue 
    } else { 
        i 
    }
}
println!(&quot;{}&quot;,v);
<span class="boring">}
</span></code></pre></pre>
<h3 id="if-let表达式"><a class="header" href="#if-let表达式">if let表达式</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let o = Some(3);
let v = if let Some(x) = o {
    x
} else {
    0
};
<span class="boring">}
</span></code></pre></pre>
<h3 id="match表达式"><a class="header" href="#match表达式">match表达式</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let o = Some(3);
let v = match o {
    Some(x) =&gt; x,
    _ =&gt; 0
};
<span class="boring">}
</span></code></pre></pre>
<h3 id="loop表达式"><a class="header" href="#loop表达式">loop表达式</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut n = 0;
let v = loop {
    if n == 10 {
        break n
    }
    n += 1;
};
<span class="boring">}
</span></code></pre></pre>
<h3 id="语句块"><a class="header" href="#语句块">语句块{}</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut n = 0;
let v = {
    println!(&quot;before: {}&quot;, n);
    n += 1;
    println!(&quot;after: {}&quot;, n);
    n
};
println!(&quot;{}&quot;, v);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="附录-d可派生的-trait"><a class="header" href="#附录-d可派生的-trait">附录 D：可派生的 trait</a></h2>
<p>在本书的各个部分中，我们讨论了可应用于结构体和枚举定义的 <code>derive</code> 属性。被 <code>derive</code> 标记的对象会自动实现对应的默认特征代码，继承相应的功能。</p>
<p>在本附录中,我们列举了所有标准库存在的 <code>derive</code> 特征，每个特征覆盖了以下内容</p>
<ul>
<li>该特征将会派生什么样的操作符和方法</li>
<li>由 <code>derive</code> 提供什么样的特征实现</li>
<li>实现特征对于类型意味着什么</li>
<li>你需要什么条件来实现该特征</li>
<li>特征示例</li>
</ul>
<p>如果你希望不同于 <code>derive</code> 属性所提供的行为，请查阅 <a href="https://doc.rust-lang.org/std/index.html">标准库文档</a> 中每个特征的细节以了解如何手动实现它们。</p>
<p>除了本文列出的特征之外，标准库中定义的其它特征不能通过 <code>derive</code> 在类型上实现。这些特征不存在有意义的默认行为，所以由你负责以合理的方式实现它们。</p>
<p>一个无法被派生的特征例子是为终端用户处理格式化的 <code>Display</code> 。你应该时常考虑使用合适的方法来为终端用户显示一个类型。终端用户应该看到类型的什么部分？他们会找出相关部分吗？对他们来说最关心的数据格式是什么样的？Rust 编译器没有这样的洞察力，因此无法为你提供合适的默认行为。</p>
<p>本附录所提供的可派生特征列表其实并不全面：库可以为其内部的特征实现 <code>derive</code> ，因此除了本文列出的标准库 <code>derive</code> 之外，还有很多很多其它库的 <code>derive</code> 。实现 <code>derive</code> 涉及到过程宏的应用，这在第十九章的 <a href="appendix/../macro/intro">宏</a>中有介绍。</p>
<h3 id="用于程序员debug输出的-debug"><a class="header" href="#用于程序员debug输出的-debug">用于程序员Debug输出的 <code>Debug</code></a></h3>
<p><code>Debug</code> 特征可以让指定对象输出调试格式的字符串，通过在 <code>{}</code> 占位符中增加 <code>:?</code> 表明，例如<code>println!(&quot;show you some debug info: {:?}&quot;, MyObject);</code>.</p>
<p><code>Debug</code> 特征允许以调试为目的来打印一个类型的实例，所以程序员可以在执行过程中看到该实例的具体信息。</p>
<p>例如，在使用 <code>assert_eq!</code> 宏时， <code>Debug</code> 特征是必须的。如果断言失败，这个宏就把给定实例的值打印出来，这样程序员就能看到两个实例为什么不相等。</p>
<h3 id="相等比较的-partialeq-和-eq"><a class="header" href="#相等比较的-partialeq-和-eq">相等比较的 <code>PartialEq</code> 和 <code>Eq</code></a></h3>
<p><code>PartialEq</code> 特征可以比较一个类型的实例以检查是否相等，并开启了 <code>==</code> 和 <code>!=</code> 运算符的功能。</p>
<p>派生的 <code>PartialEq</code> 实现了 <code>eq</code> 方法。当 <code>PartialEq</code> 在结构体上派生时，只有<em>所有</em> 的字段都相等时两个实例才相等，同时只要有任何字段不相等则两个实例就不相等。当在枚举上派生时，每一个成员都和其自身相等，且和其他成员都不相等。</p>
<p>例如，当使用 <code>assert_eq!</code> 宏时，需要比较一个类型的两个实例是否相等，则 <code>PartialEq</code> 特征是必须的。</p>
<p><code>Eq</code> 特征没有方法, 其作用是表明每一个被标记类型的值都等于其自身。 <code>Eq</code> 特征只能应用于那些实现了 <code>PartialEq</code> 的类型，但并非所有实现了 <code>PartialEq</code> 的类型都可以实现 <code>Eq</code>。浮点类型就是一个例子：浮点数的实现表明两个非数字（ <code>NaN</code> ，not-a-number）值是互不相等的。</p>
<p>例如，对于一个 <code>HashMap&lt;K, V&gt;</code> 中的 key 来说， <code>Eq</code> 是必须的，这样 <code>HashMap&lt;K, V&gt;</code> 就可以知道两个 key 是否一样。</p>
<h3 id="partialord-和-ord-用于次序比较"><a class="header" href="#partialord-和-ord-用于次序比较"><code>PartialOrd</code> 和 <code>Ord</code> 用于次序比较</a></h3>
<p><code>PartialOrd</code> 特征可以让一个类型的多个实例实现排序功能。实现了 <code>PartialOrd</code> 的类型可以使用 <code>&lt;</code>、 <code>&gt;</code>、<code>&lt;=</code> 和 <code>&gt;=</code> 操作符。一个类型想要实现 <code>PartialOrd</code> 的前提是该类型已经实现了 <code>PartialEq</code> 。</p>
<p>派生 <code>PartialOrd</code> 实现了 <code>partial_cmp</code> 方法，一般情况下其返回一个 <code>Option&lt;Ordering&gt;</code>，但是当给定的值无法进行排序时将返回 <code>None</code>。尽管大多数类型的值都可以比较，但一个无法产生顺序的例子是：浮点类型的非数字值。当在浮点数上调用 <code>partial_cmp</code> 时， <code>NaN</code> 的浮点数将返回 <code>None</code>。</p>
<p>当在结构体上派生时， <code>PartialOrd</code> 以在结构体定义中字段出现的顺序比较每个字段的值来比较两个实例。当在枚举上派生时，认为在枚举定义中声明较早的枚举项小于其后的枚举项。</p>
<p>例如，对于来自于 <code>rand</code> 包的 <code>gen_range</code> 方法来说，当在一个大值和小值指定的范围内生成一个随机值时， <code>PartialOrd</code> trait 是必须的。</p>
<p>对于派生了 <code>Ord</code> 特征的类型，任何两个该类型的值都能进行排序。 <code>Ord</code> 特征实现了 <code>cmp</code> 方法，它返回一个 <code>Ordering</code> 而不是 <code>Option&lt;Ordering&gt;</code>，因为总存在一个合法的顺序。一个类型要想使用 <code>Ord</code> 特征，它必须要先实现 <code>PartialOrd</code> 和 <code>Eq</code> 。当在结构体或枚举上派生时， <code>cmp</code> 方法 和 <code>PartialOrd</code> 的 <code>partial_cmp</code> 方法表现是一致的。</p>
<p>例如，当在 <code>BTreeSet&lt;T&gt;</code>（一种基于有序值存储数据的数据结构）上存值时， <code>Ord</code> 是必须的。</p>
<h3 id="clone-和-copy-用于值复制"><a class="header" href="#clone-和-copy-用于值复制"><code>Clone</code> 和 <code>Copy</code> 用于值复制</a></h3>
<p><code>Clone</code> 特征用于创建一个值的深拷贝（deep copy），复制过程可能包含代码的执行以及堆上数据的复制。查阅 <a href="appendix/../core/ownership.html#%E9%80%9A%E8%BF%87Clone%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D">“通过Clone来进行深拷贝”</a>获取有关 <code>Clone</code> 的更多信息。</p>
<p>派生 <code>Clone</code> 实现了 <code>clone</code> 方法，当为整个的类型实现 <code>Clone</code> 时，在该类型的每一部分上都会调用 <code>clone</code> 方法。这意味着类型中所有字段或值也必须实现了 <code>Clone</code>，这样才能够派生 <code>Clone</code> 。</p>
<p>例如，当在一个切片（slice）上调用 <code>to_vec</code> 方法时， <code>Clone</code> 是必须的。切片只是一个引用，并不拥有其所包含的实例数据，但是从 <code>to_vec</code> 中返回的Vector需要拥有实例数据，因此， <code>to_vec</code> 需要在每个元素上调用 <code>clone</code> 来逐个复制。因此，存储在切片中的类型必须实现 <code>Clone</code>。</p>
<p><code>Copy</code> 特征允许你通过只拷贝存储在栈上的数据来复制值(浅拷贝),而无需复制存储在堆上的底层数据。查阅第四章<a href="appendix/../core/ownership.html#%E9%80%9A%E8%BF%87Copy%E5%A4%8D%E5%88%B6%E6%A0%88%E6%95%B0%E6%8D%AE">通过Copy复制栈数据</a> 的部分来获取有关 <code>Copy</code> 的更多信息。</p>
<p>实际上 <code>Copy</code> 特征并不阻止你在实现时使用了深拷贝，只是，我们不应该这么做，毕竟遵循一个语言的惯例是很重要的。当用户看到 <code>Copy</code> 时，潜意识就应该知道这是浅拷贝，复制一个值会非常快。</p>
<p>当一个类型的内部字段全部实现了 <code>Copy</code> 时，你就可以在该类型上派上 <code>Copy</code> 特征。 一个类型如果要实现 <code>Copy</code> 它必须先实现 <code>Clone</code> ，因为一个类型实现 <code>Clone</code> 后，就等于顺便实现了 <code>Copy</code> 。</p>
<p>总之， <code>Copy</code> 拥有更好的性能，当浅拷贝足够的时候，就不要使用 <code>Clone</code> ，不然会导致你的代码运行更慢，对于<a href="appendix/../performance/intro.html">性能优化</a>来说，一个很大的方面就是减少热点路径深拷贝的发生。</p>
<h3 id="hash-用于实现值映射内存存储"><a class="header" href="#hash-用于实现值映射内存存储"><code>Hash</code> 用于实现值映射内存存储</a></h3>
<p><code>Hash</code> 特征允许你使用 <code>hash</code> 函数把一个任意大小的实例映射到一个固定大小的值上。派生 <code>Hash</code> 实现了 <code>hash</code> 方法，对某个类型进行 <code>hash</code> 调用，其实就是对该类型下每个字段单独进行 <code>hash</code> 调用，然后把结果进行汇总，这意味着该类型下的所有的字段也必须实现了 <code>Hash</code>，这样才能够派生 <code>Hash</code>。</p>
<p>例如，在 <code>HashMap&lt;K, V&gt;</code> 上存储数据，存放 key 的时候， <code>Hash</code> 是必须的。</p>
<h3 id="default-用于获取默认值"><a class="header" href="#default-用于获取默认值"><code>Default</code> 用于获取默认值</a></h3>
<p><code>Default</code> 特征会帮你创建一个类型的默认值。 派生 <code>Default</code> 意味着自动实现了 <code>default</code> 函数。 <code>default</code> 函数的派生实现调用了类型每部分的 <code>default</code> 函数，这意味着类型中所有的字段也必须实现了 <code>Default</code>，这样才能够派生 <code>Default</code> 。</p>
<p><code>Default::default</code> 函数通常结合结构体更新语法一起使用，这在第五章的 <a href="appendix/../basic/compound-type/struct.html#%E7%BB%93%E6%9E%84%E4%BD%93%E6%9B%B4%E6%96%B0%E8%AF%AD%E6%B3%95">结构体更新语法</a> 部分有讨论。可以自定义一个结构体的一小部分字段而剩余字段则使用 <code>..Default::default()</code> 设置为默认值。</p>
<p>例如，当你在 <code>Option&lt;T&gt;</code> 实例上使用 <code>unwrap_or_default</code> 方法时， <code>Default</code> 特征是必须的。如果 <code>Option&lt;T&gt;</code> 是 <code>None</code> 的话, <code>unwrap_or_default</code> 方法将返回 <code>T</code> 类型的 <code>Default::default</code> 的结果。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="e-prelude模块"><a class="header" href="#e-prelude模块">E-prelude模块</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="f-难点索引"><a class="header" href="#f-难点索引">F-难点索引</a></h1>
<p>不可否认，Rust难点很多，而且知识点也很多，随着时间的进行，或多或少都会对一些难点逐渐模糊，这些难点无法通过目录章节名进行索引，因此集中放在此附录中，进行索引，方便读者朋友查阅。</p>
<table><thead><tr><th>难点及链接</th><th>简介</th></tr></thead><tbody>
<tr><td><a href="appendix/../basic/result-error/result.html#%E4%BC%A0%E6%92%AD%E7%95%8C%E7%9A%84%E5%A4%A7%E6%98%8E%E6%98%9F:">?</a></td><td>用于简化错误传播</td></tr>
<tr><td><a href="appendix/../basic/base-type/function.html#%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC">()</a></td><td>元类型</td></tr>
<tr><td><code>!</code> : <a href="appendix/../basic/base-type/function.html#%E6%B0%B8%E4%B8%8D%E8%BF%94%E5%9B%9E%E7%9A%84%E5%87%BD%E6%95%B0">1</a>, <a href="appendix/../advance/custom-type.html#!%E4%BB%8E%E4%B8%8D%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B">2</a></td><td>永不返回</td></tr>
<tr><td><a href="appendix/../basic/match-pattern/all-patterns.html#%E7%BB%91%E5%AE%9A">@</a></td><td>为一个字段绑定另外一个变量</td></tr>
<tr><td><a href="appendix/../advance/lifetime/advance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BA%A6%E6%9D%9F">'a: 'b</a></td><td>生命周期约束</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录-grust版本发布"><a class="header" href="#附录-grust版本发布">附录 G：Rust版本发布</a></h1>
<h2 id="rust版本说明"><a class="header" href="#rust版本说明">Rust版本说明</a></h2>
<p>早在第一章，我们见过 <code>cargo new</code> 在 <em>Cargo.toml</em> 中增加了一些有关 <code>edition</code> 的元数据。本附录将解释其意义！</p>
<p>与其它语言相比，Rust的更新迭代较为频繁(得益于精心设计过的发布流程以及Rust语言开发者团队管理)：</p>
<ul>
<li>每6周发布一个迭代版本</li>
<li>2-3年发布一个新的大版本：Rust 2021 edtion, 每一个版本会结合已经落地的功能，并提供一个清晰的带有完整更新文档和工具的功能包。新版本会作为常规的 6 周发布过程的一部分发布。</li>
</ul>
<p>好处在于，可以满足不同的用户群体的需求：</p>
<ul>
<li>对于活跃的Rust用户，他们总是能很快获取到新的语言内容，毕竟，尝鲜是技术爱好者的共同特点:)</li>
<li>对于一般的用户，edition的发布会告诉这些用户：Rust语言相比上次大版本发布，有了重大的改进，值得一看</li>
<li>对于Rust语言开发者，可以让他们的工作成果更快的被世人所知，不必锦衣夜行</li>
</ul>
<p>在本文档编写时，Rust 已经有三个版本：Rust 2015、2018、2021。本书基于 Rust 2021 edition 编写。</p>
<p><em>Cargo.toml</em> 中的 <code>edition</code> 字段表明代码应该使用哪个版本编译。如果该字段不存在，其默认为 <code>2021</code> 以提供后向兼容性。</p>
<p>每个项目都可以选择不同于默认的 2021 edition 的版本。这样，版本可能会包含不兼容的修改，比如新版本中新增的关键字可能会与老代码中的标识符冲突并导致错误。不过，除非你选择应用这些修改，否则旧代码依然能够被编译，即便你升级了编译器版本。</p>
<p>所有 Rust 编译器都支持任何之前存在的编译器版本，并可以链接任何支持版本的包。编译器修改只影响最初的解析代码的过程。因此，如果你使用 Rust 2021 而某个依赖使用 Rust 2018，你的项目仍旧能够编译并使用该依赖。反之，若项目使用 Rust 2018 而依赖使用 Rust 2021 亦可工作。</p>
<p>有一点需要明确：大部分功能在所有版本中都能使用。开发者使用任何 Rust 版本将能继续接收最新稳定版的改进。然而在一些情况，主要是增加了新关键字的时候，则可能出现了只能用于新版本的功能。只需切换版本即可利用新版本的功能。</p>
<p>请查看 <a href="https://rust-lang-nursery.github.io/edition-guide/">Edition Guide</a> 了解更多细节，这是一个完全介绍版本的书籍，包括如何通过 <code>cargo fix</code> 自动将代码迁移到新版本。</p>
<h2 id="rust自身开发流程"><a class="header" href="#rust自身开发流程">Rust自身开发流程</a></h2>
<p>本附录介绍 Rust语言自身是如何开发的以及这如何影响作为 Rust 开发者的你。</p>
<h3 id="无停滞稳定"><a class="header" href="#无停滞稳定">无停滞稳定</a></h3>
<p>作为一个语言，Rust <strong>十分</strong> 注重代码的稳定性。我们希望 Rust 成为你代码坚实的基础，假如持续地有东西在变，这个希望就实现不了。但与此同时，如果不能实验新功能的话，在发布之前我们又无法发现其中重大的缺陷，而一旦发布便再也没有修改的机会了。</p>
<p>对于这个问题我们的解决方案被称为 “无停滞稳定”（“stability without stagnation”），其指导性原则是：无需担心升级到最新的稳定版 Rust。每次升级应该是无痛的，并应带来新功能，更少的 bug 和更快的编译速度。</p>
<h3 id="choo-choo--小火车发布流程启动"><a class="header" href="#choo-choo--小火车发布流程启动">Choo, Choo! ~~ 小火车发布流程启动</a></h3>
<p>开发Rust语言是基于一个<strong>火车时刻表</strong>来进行的：所有的开发工作在Master分支上完成，但是发布就像火车时刻表一样，拥有不同的时间，发布采用的软件发布列车模型，被用于思科IOS和等其它软件项目。Rust 有三个 <strong>发布通道</strong>（<em>release channel</em>）：</p>
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable（稳定版）</li>
</ul>
<p>大部分 Rust 开发者主要采用稳定版通道，不过希望实验新功能的开发者可能会使用 nightly 或 beta 版。</p>
<p>如下是一个开发和发布过程如何运转的例子：假设 Rust 团队正在进行 Rust 1.5 的发布工作。该版本发布于 2015 年 12 月，这个版本和时间显然比较老了，不过这里只是为了提供一个真实的版本。Rust 新增了一项功能：一个 <code>master</code> 分支的新提交。每天晚上，会产生一个新的 nightly 版本。每天都是发布版本的日子，而这些发布由发布基础设施自动完成。所以随着时间推移，发布轨迹看起来像这样，版本一天一发：</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>每 6 周时间，是准备发布新版本的时候了！Rust 仓库的 <code>beta</code> 分支会从用于 nightly 的 <code>master</code> 分支产生。现在，有了两个发布版本：</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>大部分 Rust 用户不会主要使用 beta 版本，不过在 CI 系统中对 beta 版本进行测试能够帮助 Rust 发现可能的回归缺陷（regression）。同时，每天仍产生 nightly 发布：</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>比如我们发现了一个回归缺陷。好消息是在这些缺陷流入稳定发布之前还有一些时间来测试 beta 版本！fix 被合并到 <code>master</code>，为此 nightly 版本得到了修复，接着这些 fix 将 backport 到 <code>beta</code> 分支，一个新的 beta 发布就产生了：</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>第一个 beta 版的 6 周后，是发布稳定版的时候了！<code>stable</code> 分支从 <code>beta</code> 分支生成：</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>好的！Rust 1.5 发布了！然而，我们忘了些东西：因为又过了 6 周，我们还需发布 <strong>新版</strong> Rust 的 beta 版，Rust 1.6。所以从 <code>beta</code> 生成 <code>stable</code> 分支后，新版的 <code>beta</code> 分支也再次从 <code>nightly</code> 生成：</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>这被称为 “train model”，因为每 6 周，一个版本 “离开车站”（“leaves the station”），不过从 beta 通道到达稳定通道还有一段旅程。</p>
<p>Rust 每 6 周发布一个版本，如时钟般准确。如果你知道了某个 Rust 版本的发布时间，就可以知道下个版本的时间：6 周后。每 6 周发布版本的一个好的方面是下一班车会来得更快。如果特定版本碰巧缺失某个功能也无需担心：另一个版本很快就会到来！这有助于减少因临近发版时间而偷偷释出未经完善的功能的压力。</p>
<p>多亏了这个过程，你总是可以切换到下一版本的 Rust 并验证是否可以轻易的升级：如果 beta 版不能如期工作，你可以向 Rust 团队报告并在发布稳定版之前得到修复！beta 版造成的破坏是非常少见的，不过 <code>rustc</code> 也不过是一个软件，可能会存在 bug。</p>
<h3 id="不稳定功能"><a class="header" href="#不稳定功能">不稳定功能</a></h3>
<p>这个发布模型中另一个值得注意的地方：不稳定功能（unstable features）。Rust 使用一个被称为 “功能标记”（“feature flags”）的技术来确定给定版本的某个功能是否启用。如果新功能正在积极地开发中，其提交到了 <code>master</code>，因此会出现在 nightly 版中，不过会位于一个 <strong>功能标记</strong> 之后。作为用户，如果你希望尝试这个正在开发的功能，则可以在源码中使用合适的标记来开启，不过必须使用 nightly 版。</p>
<p>如果使用的是 beta 或稳定版 Rust，则不能使用任何功能标记。这是在新功能被宣布为永久稳定之前获得实用价值的关键。这既满足了希望使用最尖端技术的同学，那些坚持稳定版的同学也知道其代码不会被破坏。这就是无停滞稳定。</p>
<p>本书只包含稳定的功能，因为还在开发中的功能仍可能改变，当其进入稳定版时肯定会与编写本书的时候有所不同。你可以在网上获取 nightly 版的文档。</p>
<h3 id="rustup-和-rust-nightly-的职责"><a class="header" href="#rustup-和-rust-nightly-的职责">Rustup 和 Rust Nightly 的职责</a></h3>
<h4 id="安装rust-nightly版本"><a class="header" href="#安装rust-nightly版本">安装Rust Nightly版本</a></h4>
<p>Rustup 使得改变不同发布通道的 Rust 更为简单，其在全局或分项目的层次工作。其默认会安装稳定版 Rust。例如为了安装 nightly：</p>
<pre><code class="language-text">$ rustup install nightly
</code></pre>
<p>你会发现 <code>rustup</code> 也安装了所有的 <strong>工具链</strong>（<em>toolchains</em>， Rust 和其相关组件）。如下是一位作者的 Windows 计算机上的例子：</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<h4 id="在指定目录使用rust-nightly"><a class="header" href="#在指定目录使用rust-nightly">在指定目录使用Rust Nightly</a></h4>
<p>如你所见，默认是稳定版。大部分 Rust 用户在大部分时间使用稳定版。你可能也会这么做，不过如果你关心最新的功能，可以为特定项目使用 nightly 版。为此，可以在项目目录使用 <code>rustup override</code> 来设置当前目录 <code>rustup</code> 使用 nightly 工具链：</p>
<pre><code class="language-text">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>现在，每次在 *~/需要nightly的项目/*下(在项目的根目录下，也就是Cargo.toml所在的目录) 调用 <code>rustc</code> 或 <code>cargo</code>，<code>rustup</code> 会确保使用 nightly 版 Rust。在你有很多 Rust 项目时大有裨益！</p>
<h3 id="rfc-过程和团队"><a class="header" href="#rfc-过程和团队">RFC 过程和团队</a></h3>
<p>那么你如何了解这些新功能呢？Rust 开发模式遵循一个 <strong>Request For Comments (RFC) 过程</strong>。如果你希望改进 Rust，可以编写一个提议，也就是 RFC。</p>
<p>任何人都可以编写 RFC 来改进 Rust，同时这些 RFC 会被 Rust 团队评审和讨论，他们由很多不同分工的子团队组成。这里是 <a href="https://www.rust-lang.org/governance">Rust 官网上</a> 所有团队的总列表，其包含了项目中每个领域的团队：语言设计、编译器实现、基础设施、文档等。各个团队会阅读相应的提议和评论，编写回复，并最终达成接受或回绝功能的一致。</p>
<p>如果功能被接受了，在 Rust 仓库会打开一个 issue，人们就可以实现它。实现功能的人可能不是最初提议功能的人！当实现完成后，其会合并到 <code>master</code> 分支并位于一个特性开关（feature gate）之后，正如 <a href="appendix/rust-version.html#%E4%B8%8D%E7%A8%B3%E5%AE%9A%E5%8A%9F%E8%83%BD">不稳定功能</a> 部分所讨论的。</p>
<p>在稍后的某个时间，一旦使用 nightly 版的 Rust 团队能够尝试这个功能了，团队成员会讨论这个功能在 nightly 中运行的情况，并决定是否应该进入稳定版。如果决定继续推进，特性开关会移除，然后这个功能就被认为是稳定的了！乘着“发布的列车”，最终在新的稳定版 Rust 中出现。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="h-rust更新版本列表"><a class="header" href="#h-rust更新版本列表">H-Rust更新版本列表</a></h1>
<p>本目录包含了Rust历次版本更新的重要内容解读，需要注意，每个版本实际更新的内容要比这里记录的更多，全部内容请访问每节开头的官方链接查看。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="158"><a class="header" href="#158">1.58</a></h1>
<p>众所周知，Rust小版本发布非常频繁，6周就发布一次，因此通常不会有特别值得普通用户关注的内容，但是这次1.58版本不同，新增了(stable化了)一个非常好用的功能：在格式化字符串时捕获环境中的值。</p>
<blockquote>
<p>Rust 1.58 官方 release doc:  <a href="https://blog.rust-lang.org/2022/01/13/Rust-1.58.0.html">Announcing Rust 1.58.0 | Rust Blog</a></p>
</blockquote>
<h2 id="在格式化字符串时捕获环境中的值"><a class="header" href="#在格式化字符串时捕获环境中的值">在格式化字符串时捕获环境中的值</a></h2>
<p>在以前，想要输出一个函数的返回值，你需要这么做：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_person() -&gt; String {
    String::from(&quot;sunface&quot;)
}
fn main() {
    let p = get_person();
    println!(&quot;Hello, {}!&quot;, p);                // implicit position
    println!(&quot;Hello, {0}!&quot;, p);               // explicit index
    println!(&quot;Hello, {person}!&quot;, person = p);
}
</code></pre></pre>
<p>问题倒也不大，但是一旦格式化字符串长了后，就会非常冗余，而在1.58后，我们可以这么写：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_person() -&gt; String {
    String::from(&quot;sunface&quot;)
}
fn main() {
    let person = get_person();
    println!(&quot;Hello, {person}!&quot;);
}
</code></pre></pre>
<p>是不是清晰、简洁了很多？甚至还可以将环境中的值用于格式化参数:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (width, precision) = get_format();
for (name, score) in get_scores() {
  println!(&quot;{name}: {score:width$.precision$}&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>但也有局限，它只能捕获普通的变量，对于更复杂的类型(例如表达式)，可以先将它赋值给一个变量或使用以前的<code>name = expression</code>形式的格式化参数。
目前除了<code>panic!</code>外，其它接收格式化参数的宏，都可以使用新的特性。对于<code>panic!</code> 而言，如果还在使用<code>Rust2015</code>或<code>2018</code>大版本 ，那<code>panic!(&quot;{ident}&quot;)</code>依然会被当成 正常的字符串来处理，同时编译器会给予<code>warn</code>提示。而对于<code>2021版本</code>，则可以正常使用:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_person() -&gt; String {
    String::from(&quot;sunface&quot;)
}
fn main() {
    let person = get_person();
    panic!(&quot;Hello, {person}!&quot;);
}
</code></pre></pre>
<p>输出:</p>
<pre><code class="language-console">thread 'main' panicked at 'Hello, sunface!', src/main.rs:6:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<h2 id="比unwrap更危险的unwrap_unchecked"><a class="header" href="#比unwrap更危险的unwrap_unchecked">比unwrap更危险的unwrap_unchecked</a></h2>
<p>在1.58中为<code>Option</code>和<code>Result</code>新增了<code>unwrap_unchecked</code>方法，与<code>unwrap</code>遇到错误或者空值直接<code>panic</code>不同，<code>unwrap_unchecked</code>遇到错误时处理方式糟糕的多：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_num() -&gt; Option&lt;i32&gt; {
   None
}
fn main() {
    unsafe {
        let n = get_num().unwrap_unchecked();
    }
}
</code></pre></pre>
<p>输出如下：</p>
<pre><code class="language-console">zsh: segmentation fault  cargo run
</code></pre>
<p>嗯，段错误了，对比下<code>panic</code>，有一种泪流满面的冲动：我要这不安全的方法何用？ </p>
<p>其实，还真有些用：</p>
<ul>
<li>想要较小的可执行文件时(嵌入式，wasm等)，该方法就可以大显身手。因为panic会导致<a href="https://zhuanlan.zhihu.com/p/445465092">二进制可执行文件变大不少</a></li>
<li>它还可以提高一点性能， 因为编译器可能无法优化掉unwrap的指令分支， 虽然它只会增加区区几条分支预测指令</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="assets/ferris.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
