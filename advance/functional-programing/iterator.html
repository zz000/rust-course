<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>迭代器iterator - Rust语言圣经(Rust教程 Rust Course)</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../assets/ferris.css">
        <link rel="stylesheet" href="../../assets/theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../into-rust.html">进入Rust编程世界</a></li><li class="chapter-item expanded affix "><a href="../../about-book.html">关于本书</a></li><li class="chapter-item expanded affix "><a href="../../sth-you-should-not-do.html">避免从入门到放弃</a></li><li class="chapter-item expanded "><a href="../../first-try/intro.html"><strong aria-hidden="true">1.</strong> 寻找牛刀，以便小试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../first-try/installation.html"><strong aria-hidden="true">1.1.</strong> 安装Rust环境</a></li><li class="chapter-item "><a href="../../first-try/editor.html"><strong aria-hidden="true">1.2.</strong> 墙推VSCode!</a></li><li class="chapter-item "><a href="../../first-try/cargo.html"><strong aria-hidden="true">1.3.</strong> 认识Cargo</a></li><li class="chapter-item "><a href="../../first-try/hello-world.html"><strong aria-hidden="true">1.4.</strong> 不仅仅是Hello world</a></li></ol></li><li class="chapter-item expanded "><a href="../../basic/intro.html"><strong aria-hidden="true">2.</strong> Rust基础入门</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../basic/variable.html"><strong aria-hidden="true">2.1.</strong> 变量绑定与解构</a></li><li class="chapter-item "><a href="../../basic/base-type/index.html"><strong aria-hidden="true">2.2.</strong> 基本类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../basic/base-type/numbers.html"><strong aria-hidden="true">2.2.1.</strong> 数值类型</a></li><li class="chapter-item "><a href="../../basic/base-type/char-bool.html"><strong aria-hidden="true">2.2.2.</strong> 字符、布尔、元类型</a></li><li class="chapter-item "><a href="../../basic/base-type/statement-expression.html"><strong aria-hidden="true">2.2.3.</strong> 语句与表达式</a></li><li class="chapter-item "><a href="../../basic/base-type/function.html"><strong aria-hidden="true">2.2.4.</strong> 函数</a></li></ol></li><li class="chapter-item "><a href="../../basic/ownership/index.html"><strong aria-hidden="true">2.3.</strong> 所有权和借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../basic/ownership/ownership.html"><strong aria-hidden="true">2.3.1.</strong> 所有权</a></li><li class="chapter-item "><a href="../../basic/ownership/borrowing.html"><strong aria-hidden="true">2.3.2.</strong> 引用与借用</a></li></ol></li><li class="chapter-item "><a href="../../basic/compound-type/intro.html"><strong aria-hidden="true">2.4.</strong> 复合类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../basic/compound-type/string-slice.html"><strong aria-hidden="true">2.4.1.</strong> 字符串与切片</a></li><li class="chapter-item "><a href="../../basic/compound-type/tuple.html"><strong aria-hidden="true">2.4.2.</strong> 元组</a></li><li class="chapter-item "><a href="../../basic/compound-type/struct.html"><strong aria-hidden="true">2.4.3.</strong> 结构体</a></li><li class="chapter-item "><a href="../../basic/compound-type/enum.html"><strong aria-hidden="true">2.4.4.</strong> 枚举</a></li><li class="chapter-item "><a href="../../basic/compound-type/array.html"><strong aria-hidden="true">2.4.5.</strong> 数组</a></li></ol></li><li class="chapter-item "><a href="../../basic/flow-control.html"><strong aria-hidden="true">2.5.</strong> 流程控制</a></li><li class="chapter-item "><a href="../../basic/match-pattern/intro.html"><strong aria-hidden="true">2.6.</strong> 模式匹配</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../basic/match-pattern/match-if-let.html"><strong aria-hidden="true">2.6.1.</strong> match和if let</a></li><li class="chapter-item "><a href="../../basic/match-pattern/option.html"><strong aria-hidden="true">2.6.2.</strong> 解构Option</a></li><li class="chapter-item "><a href="../../basic/match-pattern/pattern-match.html"><strong aria-hidden="true">2.6.3.</strong> 模式适用场景</a></li><li class="chapter-item "><a href="../../basic/match-pattern/all-patterns.html"><strong aria-hidden="true">2.6.4.</strong> 全模式列表</a></li></ol></li><li class="chapter-item "><a href="../../basic/method.html"><strong aria-hidden="true">2.7.</strong> 方法Method</a></li><li class="chapter-item "><a href="../../basic/trait/intro.html"><strong aria-hidden="true">2.8.</strong> 泛型和特征</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../basic/trait/generic.html"><strong aria-hidden="true">2.8.1.</strong> 泛型Generics</a></li><li class="chapter-item "><a href="../../basic/trait/trait.html"><strong aria-hidden="true">2.8.2.</strong> 特征Trait</a></li><li class="chapter-item "><a href="../../basic/trait/trait-object.html"><strong aria-hidden="true">2.8.3.</strong> 特征对象</a></li><li class="chapter-item "><a href="../../basic/trait/advance-trait.html"><strong aria-hidden="true">2.8.4.</strong> 进一步深入特征</a></li></ol></li><li class="chapter-item "><a href="../../basic/collections/intro.html"><strong aria-hidden="true">2.9.</strong> 集合类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../basic/collections/vector.html"><strong aria-hidden="true">2.9.1.</strong> 动态数组Vector</a></li><li class="chapter-item "><a href="../../basic/collections/hashmap.html"><strong aria-hidden="true">2.9.2.</strong> KV存储HashMap</a></li></ol></li><li class="chapter-item "><a href="../../basic/converse.html"><strong aria-hidden="true">2.10.</strong> 类型转换</a></li><li class="chapter-item "><a href="../../basic/result-error/intro.html"><strong aria-hidden="true">2.11.</strong> 返回值和错误</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../basic/result-error/panic.html"><strong aria-hidden="true">2.11.1.</strong> panic深入剖析!</a></li><li class="chapter-item "><a href="../../basic/result-error/result.html"><strong aria-hidden="true">2.11.2.</strong> 返回值Result和?</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../advance/intro.html"><strong aria-hidden="true">3.</strong> Rust高级进阶</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../advance/lifetime/intro.html"><strong aria-hidden="true">3.1.</strong> 生命周期</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../advance/lifetime/basic.html"><strong aria-hidden="true">3.1.1.</strong> 认识生命周期</a></li><li class="chapter-item "><a href="../../advance/lifetime/advance.html"><strong aria-hidden="true">3.1.2.</strong> 深入生命周期</a></li></ol></li><li class="chapter-item expanded "><a href="../../advance/functional-programing/intro.html"><strong aria-hidden="true">3.2.</strong> 函数式编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../advance/functional-programing/closure.html"><strong aria-hidden="true">3.2.1.</strong> 闭包closure</a></li><li class="chapter-item expanded "><a href="../../advance/functional-programing/iterator.html" class="active"><strong aria-hidden="true">3.2.2.</strong> 迭代器iterator</a></li></ol></li><li class="chapter-item "><a href="../../advance/crate-module/intro.html"><strong aria-hidden="true">3.3.</strong> 包和模块</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../advance/crate-module/crate.html"><strong aria-hidden="true">3.3.1.</strong> 包crate</a></li><li class="chapter-item "><a href="../../advance/crate-module/module.html"><strong aria-hidden="true">3.3.2.</strong> 模块Module</a></li><li class="chapter-item "><a href="../../advance/crate-module/use.html"><strong aria-hidden="true">3.3.3.</strong> 使用use引入模块及受限可见性</a></li></ol></li><li class="chapter-item "><a href="../../advance/comment.html"><strong aria-hidden="true">3.4.</strong> 注释和文档</a></li><li class="chapter-item "><a href="../../advance/custom-type.html"><strong aria-hidden="true">3.5.</strong> 深入类型之newtype和Sized</a></li><li class="chapter-item "><a href="../../advance/formatted-output.html"><strong aria-hidden="true">3.6.</strong> 格式化输出</a></li><li class="chapter-item "><a href="../../advance/smart-pointer/intro.html"><strong aria-hidden="true">3.7.</strong> 智能指针</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../advance/smart-pointer/box.html"><strong aria-hidden="true">3.7.1.</strong> Box堆对象分配</a></li><li class="chapter-item "><a href="../../advance/smart-pointer/deref.html"><strong aria-hidden="true">3.7.2.</strong> Deref解引用</a></li><li class="chapter-item "><a href="../../advance/smart-pointer/drop.html"><strong aria-hidden="true">3.7.3.</strong> Drop释放资源</a></li><li class="chapter-item "><a href="../../advance/smart-pointer/rc-arc.html"><strong aria-hidden="true">3.7.4.</strong> Rc与Arc实现1vN所有权机制</a></li><li class="chapter-item "><a href="../../advance/smart-pointer/cell-refcell.html"><strong aria-hidden="true">3.7.5.</strong> Cell与RefCell内部可变性</a></li></ol></li><li class="chapter-item "><a href="../../advance/circle-self-ref/intro.html"><strong aria-hidden="true">3.8.</strong> 循环引用与自引用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../advance/circle-self-ref/circle-reference.html"><strong aria-hidden="true">3.8.1.</strong> Weak与循环引用</a></li><li class="chapter-item "><a href="../../advance/circle-self-ref/self-referential.html"><strong aria-hidden="true">3.8.2.</strong> 结构体中的自引用</a></li></ol></li><li class="chapter-item "><a href="../../advance/concurrency-with-threads/intro.html"><strong aria-hidden="true">3.9.</strong> 多线程并发编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../advance/concurrency-with-threads/concurrency-parallelism.html"><strong aria-hidden="true">3.9.1.</strong> 并发和并行</a></li><li class="chapter-item "><a href="../../advance/concurrency-with-threads/thread.html"><strong aria-hidden="true">3.9.2.</strong> 使用多线程</a></li><li class="chapter-item "><a href="../../advance/concurrency-with-threads/message-passing.html"><strong aria-hidden="true">3.9.3.</strong> 线程同步：消息传递</a></li><li class="chapter-item "><a href="../../advance/concurrency-with-threads/sync1.html"><strong aria-hidden="true">3.9.4.</strong> 线程同步：锁、Condvar和信号量</a></li><li class="chapter-item "><a href="../../advance/concurrency-with-threads/sync2.html"><strong aria-hidden="true">3.9.5.</strong> 线程同步：Atomic原子操作与内存顺序</a></li><li class="chapter-item "><a href="../../advance/concurrency-with-threads/send-sync.html"><strong aria-hidden="true">3.9.6.</strong> 基于Send和Sync的线程安全</a></li><li class="chapter-item "><a href="../../advance/concurrency-with-threads/web-server.html"><strong aria-hidden="true">3.9.7.</strong> 实践应用：多线程Web服务器 todo</a></li></ol></li><li class="chapter-item "><a href="../../advance/unsafe/intro.html"><strong aria-hidden="true">3.10.</strong> Unsafe Rust todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../advance/unsafe/raw-pointer.html"><strong aria-hidden="true">3.10.1.</strong> 原生指针 todo</a></li><li class="chapter-item "><a href="../../advance/unsafe/ffi.html"><strong aria-hidden="true">3.10.2.</strong> FFI外部语言用 todo</a></li></ol></li><li class="chapter-item "><a href="../../advance/global-variable.html"><strong aria-hidden="true">3.11.</strong> 全局变量</a></li><li class="chapter-item "><a href="../../advance/errors/intro.html"><strong aria-hidden="true">3.12.</strong> 错误处理 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../advance/errors/simplify.html"><strong aria-hidden="true">3.12.1.</strong> 简化错误处理 todo</a></li><li class="chapter-item "><a href="../../advance/errors/user-define.html"><strong aria-hidden="true">3.12.2.</strong> 自定义错误 todo</a></li><li class="chapter-item "><a href="../../advance/errors/pretty-format.html"><strong aria-hidden="true">3.12.3.</strong> 让错误输出更优雅 todo</a></li><li class="chapter-item "><a href="../../advance/errors/panic-codes.html"><strong aria-hidden="true">3.12.4.</strong> 会导致panic的代码 todo</a></li></ol></li><li class="chapter-item "><a href="../../advance/hrtb.html"><strong aria-hidden="true">3.13.</strong> 高阶特征约束(HRTB) todo</a></li></ol></li><li class="chapter-item expanded "><a href="../../async/intro.html"><strong aria-hidden="true">4.</strong> async/await异步编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../async/getting-started.html"><strong aria-hidden="true">4.1.</strong> async编程入门</a></li><li class="chapter-item "><a href="../../async/future-excuting.html"><strong aria-hidden="true">4.2.</strong> 底层探秘: Future执行与任务调度</a></li><li class="chapter-item "><a href="../../async/pin-unpin.html"><strong aria-hidden="true">4.3.</strong> 定海神针Pin和Unpin</a></li><li class="chapter-item "><a href="../../async/async-await.html"><strong aria-hidden="true">4.4.</strong> async/await和Stream流处理</a></li><li class="chapter-item "><a href="../../async/multi-futures-simultaneous.html"><strong aria-hidden="true">4.5.</strong> 同时运行多个Future</a></li><li class="chapter-item "><a href="../../async/pain-points-and-workarounds.html"><strong aria-hidden="true">4.6.</strong> 一些疑难问题的解决办法</a></li><li class="chapter-item "><a href="../../async/web-server.html"><strong aria-hidden="true">4.7.</strong> 实践应用：Async Web服务器</a></li></ol></li><li class="chapter-item expanded "><a href="../../tokio/intro.html"><strong aria-hidden="true">5.</strong> tokio使用指南 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../tokio/overview.html"><strong aria-hidden="true">5.1.</strong> tokio概览</a></li><li class="chapter-item "><a href="../../tokio/getting-startted.html"><strong aria-hidden="true">5.2.</strong> 使用初印象</a></li><li class="chapter-item "><a href="../../tokio/spawning.html"><strong aria-hidden="true">5.3.</strong> 创建异步任务</a></li></ol></li><li class="chapter-item expanded "><a href="../../fight-with-compiler/intro.html"><strong aria-hidden="true">6.</strong> 对抗编译检查 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../fight-with-compiler/phantom-data.html"><strong aria-hidden="true">6.1.</strong> 幽灵数据(todo)</a></li><li class="chapter-item "><a href="../../fight-with-compiler/lifetime/intro.html"><strong aria-hidden="true">6.2.</strong> 生命周期</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../fight-with-compiler/lifetime/too-long1.html"><strong aria-hidden="true">6.2.1.</strong> 生命周期过大-01</a></li><li class="chapter-item "><a href="../../fight-with-compiler/lifetime/too-long2.html"><strong aria-hidden="true">6.2.2.</strong> 生命周期过大-02</a></li><li class="chapter-item "><a href="../../fight-with-compiler/lifetime/loop.html"><strong aria-hidden="true">6.2.3.</strong> 循环中的生命周期</a></li><li class="chapter-item "><a href="../../fight-with-compiler/lifetime/closure-with-static.html"><strong aria-hidden="true">6.2.4.</strong> 闭包碰到特征对象-01</a></li></ol></li><li class="chapter-item "><a href="../../fight-with-compiler/borrowing/intro.html"><strong aria-hidden="true">6.3.</strong> 重复借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../fight-with-compiler/borrowing/ref-exist-in-out-fn.html"><strong aria-hidden="true">6.3.1.</strong> 同时在函数内外使用引用</a></li><li class="chapter-item "><a href="../../fight-with-compiler/borrowing/borrow-distinct-fields-of-struct.html"><strong aria-hidden="true">6.3.2.</strong> 智能指针引起的重复借用错误</a></li></ol></li><li class="chapter-item "><a href="../../fight-with-compiler/unconstrained.html"><strong aria-hidden="true">6.4.</strong> 类型未限制(todo)</a></li></ol></li><li class="chapter-item expanded "><a href="../../pitfalls/index.html"><strong aria-hidden="true">7.</strong> Rust陷阱系列</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../pitfalls/use-vec-in-for.html"><strong aria-hidden="true">7.1.</strong> for循环中使用外部数组</a></li><li class="chapter-item "><a href="../../pitfalls/stack-overflow.html"><strong aria-hidden="true">7.2.</strong> 线程类型导致的栈溢出</a></li><li class="chapter-item "><a href="../../pitfalls/arithmetic-overflow.html"><strong aria-hidden="true">7.3.</strong> 算术溢出导致的panic</a></li><li class="chapter-item "><a href="../../pitfalls/closure-with-lifetime.html"><strong aria-hidden="true">7.4.</strong> 闭包中奇怪的生命周期</a></li><li class="chapter-item "><a href="../../pitfalls/the-disabled-mutability.html"><strong aria-hidden="true">7.5.</strong> 可变变量不可变？</a></li><li class="chapter-item "><a href="../../pitfalls/multiple-mutable-references.html"><strong aria-hidden="true">7.6.</strong> 可变借用失败引发的深入思考</a></li><li class="chapter-item "><a href="../../pitfalls/lazy-iterators.html"><strong aria-hidden="true">7.7.</strong> 不太勤快的迭代器</a></li><li class="chapter-item "><a href="../../pitfalls/weird-ranges.html"><strong aria-hidden="true">7.8.</strong> 奇怪的序列x..y</a></li><li class="chapter-item "><a href="../../pitfalls/iterator-everywhere.html"><strong aria-hidden="true">7.9.</strong> 无处不在的迭代器</a></li><li class="chapter-item "><a href="../../pitfalls/main-with-channel-blocked.html"><strong aria-hidden="true">7.10.</strong> 线程间传递消息导致主线程无法结束</a></li></ol></li><li class="chapter-item expanded "><a href="../../practice/intro.html"><strong aria-hidden="true">8.</strong> Rust最佳实践 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../practice/third-party-libs.html"><strong aria-hidden="true">8.1.</strong> 日常开发三方库精选</a></li><li class="chapter-item "><a href="../../practice/coding-tips.html"><strong aria-hidden="true">8.2.</strong> 一些写代码的技巧 todo</a></li><li class="chapter-item "><a href="../../practice/best-pratice.html"><strong aria-hidden="true">8.3.</strong> 最佳实践 todo</a></li><li class="chapter-item "><a href="../../practice/good-sourcecode.html"><strong aria-hidden="true">8.4.</strong> 值得学习的源代码 todo</a></li><li class="chapter-item "><a href="../../practice/style-guide/intro.html"><strong aria-hidden="true">8.5.</strong> 代码规范 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../practice/style-guide/naming.html"><strong aria-hidden="true">8.5.1.</strong> 命名规范</a></li><li class="chapter-item "><a href="../../practice/style-guide/code.html"><strong aria-hidden="true">8.5.2.</strong> 代码风格(todo)</a></li><li class="chapter-item "><a href="../../practice/style-guide/mark.html"><strong aria-hidden="true">8.5.3.</strong> 代码标记 todo</a></li><li class="chapter-item "><a href="../../practice/style-guide/clippy.html"><strong aria-hidden="true">8.5.4.</strong> Clippy todo</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> 如何实现一个链表 todo</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Javascript 和 WASM todo</div></li><li class="chapter-item expanded "><a href="../../converse/intro.html"><strong aria-hidden="true">11.</strong> 进阶类型转换</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../converse/enum-int.html"><strong aria-hidden="true">11.1.</strong> 枚举和整数</a></li></ol></li><li class="chapter-item expanded "><a href="../../errorindex/intro.html"><strong aria-hidden="true">12.</strong> 复杂错误索引 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../errorindex/borrowing/intro.html"><strong aria-hidden="true">12.1.</strong> 所有权和借用 todo</a></li><li class="chapter-item "><a href="../../errorindex/lifetime/intro.html"><strong aria-hidden="true">12.2.</strong> 生命周期 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../../cargo/intro.html"><strong aria-hidden="true">13.</strong> Cargo详解 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../cargo/commands.html"><strong aria-hidden="true">13.1.</strong> 常用命令 todo</a></li><li class="chapter-item "><a href="../../cargo/layout.html"><strong aria-hidden="true">13.2.</strong> 项目结构 todo</a></li><li class="chapter-item "><a href="../../cargo/cargo-toml-lock.html"><strong aria-hidden="true">13.3.</strong> Cargo.toml和Cargo.lock todo</a></li><li class="chapter-item "><a href="../../cargo/dependency.html"><strong aria-hidden="true">13.4.</strong> 依赖管理 todo</a></li><li class="chapter-item "><a href="../../cargo/cache.html"><strong aria-hidden="true">13.5.</strong> 构建缓存 todo</a></li><li class="chapter-item "><a href="../../cargo/version.html"><strong aria-hidden="true">13.6.</strong> 版本管理 todo</a></li><li class="chapter-item "><a href="../../cargo/workspace.html"><strong aria-hidden="true">13.7.</strong> 工作空间 todo</a></li><li class="chapter-item "><a href="../../cargo/feature.html"><strong aria-hidden="true">13.8.</strong> 条件编译、条件依赖 todo</a></li><li class="chapter-item "><a href="../../cargo/manifest.html"><strong aria-hidden="true">13.9.</strong> 配置参数 todo</a></li><li class="chapter-item "><a href="../../cargo/build-js.html"><strong aria-hidden="true">13.10.</strong> 自定义构建脚本 todo</a></li><li class="chapter-item "><a href="../../cargo/profile.html"><strong aria-hidden="true">13.11.</strong> Cargo profile todo</a></li></ol></li><li class="chapter-item expanded "><a href="../../test/intro.html"><strong aria-hidden="true">14.</strong> 测试 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../test/unit.html"><strong aria-hidden="true">14.1.</strong> 单元测试 todo</a></li><li class="chapter-item "><a href="../../test/intergration.html"><strong aria-hidden="true">14.2.</strong> 集成测试 todo</a></li><li class="chapter-item "><a href="../../test/benchmark.html"><strong aria-hidden="true">14.3.</strong> 性能测试 todo</a></li><li class="chapter-item "><a href="../../test/ci.html"><strong aria-hidden="true">14.4.</strong> 持续集成 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../../traits/intro.html"><strong aria-hidden="true">15.</strong> 常见特征解析 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../traits/from-into.html"><strong aria-hidden="true">15.1.</strong> 类型转换From/Into todo</a></li><li class="chapter-item "><a href="../../traits/as-ref-as-mut.html"><strong aria-hidden="true">15.2.</strong> AsRef, AsMut todo</a></li><li class="chapter-item "><a href="../../traits/borrow-family.html"><strong aria-hidden="true">15.3.</strong> Borrow, BorrowMut, ToOwned todo</a></li><li class="chapter-item "><a href="../../traits/deref.html"><strong aria-hidden="true">15.4.</strong> Deref和引用隐式转换 todo</a></li><li class="chapter-item "><a href="../../traits/cow.html"><strong aria-hidden="true">15.5.</strong> 写时拷贝Cow todo</a></li><li class="chapter-item "><a href="../../traits/eq.html"><strong aria-hidden="true">15.6.</strong> Eq todo</a></li></ol></li><li class="chapter-item expanded "><a href="../../memory/intro.html"><strong aria-hidden="true">16.</strong> 深入内存 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../memory/pointer-ref.html"><strong aria-hidden="true">16.1.</strong> 指针和引用 todo</a></li><li class="chapter-item "><a href="../../memory/uninit.html"><strong aria-hidden="true">16.2.</strong> 未初始化内存 todo</a></li><li class="chapter-item "><a href="../../memory/allocation.html"><strong aria-hidden="true">16.3.</strong> 内存分配 todo</a></li><li class="chapter-item "><a href="../../memory/layout.html"><strong aria-hidden="true">16.4.</strong> 内存布局 todo</a></li><li class="chapter-item "><a href="../../memory/virtual.html"><strong aria-hidden="true">16.5.</strong> 虚拟内存 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../../web/intro.html"><strong aria-hidden="true">17.</strong> Web应用开发 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../web/serialization.html"><strong aria-hidden="true">17.1.</strong> 编解码与序列化 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../../object-oriented/intro.html"><strong aria-hidden="true">18.</strong> 面向对象 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../object-oriented/characteristics.html"><strong aria-hidden="true">18.1.</strong> 为何OO todo</a></li><li class="chapter-item "><a href="../../object-oriented/design-pattern.html"><strong aria-hidden="true">18.2.</strong> 设计模式 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../../macro/intro.html"><strong aria-hidden="true">19.</strong> 宏编程 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../macro/procedure-macro.html"><strong aria-hidden="true">19.1.</strong> 过程宏(todo)</a></li></ol></li><li class="chapter-item expanded "><a href="../../performance/intro.html"><strong aria-hidden="true">20.</strong> 性能调优 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../performance/deep-into-move.html"><strong aria-hidden="true">20.1.</strong> 深入理解move</a></li><li class="chapter-item "><a href="../../performance/early-optimise.html"><strong aria-hidden="true">20.2.</strong> 糟糕的提前优化 todo</a></li><li class="chapter-item "><a href="../../performance/clone-copy.html"><strong aria-hidden="true">20.3.</strong> Clone和Copy todo</a></li><li class="chapter-item "><a href="../../performance/benchmark.html"><strong aria-hidden="true">20.4.</strong> Benchmark性能测试(todo)</a></li><li class="chapter-item "><a href="../../performance/runtime-check.html"><strong aria-hidden="true">20.5.</strong> 减少Runtime check(todo)</a></li><li class="chapter-item "><a href="../../performance/cpu-cache.html"><strong aria-hidden="true">20.6.</strong> CPU缓存性能优化 todo</a></li><li class="chapter-item "><a href="../../performance/calculate.html"><strong aria-hidden="true">20.7.</strong> 计算性能优化 todo</a></li><li class="chapter-item "><a href="../../performance/heap-stack.html"><strong aria-hidden="true">20.8.</strong> 堆和栈 todo</a></li><li class="chapter-item "><a href="../../performance/allocator.html"><strong aria-hidden="true">20.9.</strong> 内存allocator todo</a></li><li class="chapter-item "><a href="../../performance/tools.html"><strong aria-hidden="true">20.10.</strong> 常用性能测试工具 todo</a></li><li class="chapter-item "><a href="../../performance/enum.html"><strong aria-hidden="true">20.11.</strong> Enum内存优化 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../../compiler/intro.html"><strong aria-hidden="true">21.</strong> 编译器 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../compiler/attributes.html"><strong aria-hidden="true">21.1.</strong> 常见属性标记 todo</a></li><li class="chapter-item "><a href="../../compiler/speed-up.html"><strong aria-hidden="true">21.2.</strong> 提升编译速度 todo</a></li><li class="chapter-item "><a href="../../compiler/optimization/intro.html"><strong aria-hidden="true">21.3.</strong> 编译器优化 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../compiler/optimization/option.html"><strong aria-hidden="true">21.3.1.</strong> Option枚举 todo</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../monitor/intro.html"><strong aria-hidden="true">22.</strong> 日志和监控 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../monitor/log.html"><strong aria-hidden="true">22.1.</strong> 日志 todo</a></li><li class="chapter-item "><a href="../../monitor/observability.html"><strong aria-hidden="true">22.2.</strong> 可观测性 todo</a></li><li class="chapter-item "><a href="../../monitor/apm.html"><strong aria-hidden="true">22.3.</strong> 监控(APM) todo</a></li></ol></li><li class="chapter-item expanded "><a href="../../std/intro.html"><strong aria-hidden="true">23.</strong> 标准库解析 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../std/search.html"><strong aria-hidden="true">23.1.</strong> 如何寻找你想要的内容 todo</a></li><li class="chapter-item "><a href="../../std/vector.html"><strong aria-hidden="true">23.2.</strong> Vector常用方法 todo</a></li><li class="chapter-item "><a href="../../std/hashmap.html"><strong aria-hidden="true">23.3.</strong> HashMap todo</a></li><li class="chapter-item "><a href="../../std/iterator.html"><strong aria-hidden="true">23.4.</strong> Iterator常用方法 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../../appendix/intro.html"><strong aria-hidden="true">24.</strong> 附录</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../appendix/keywords.html"><strong aria-hidden="true">24.1.</strong> A-关键字</a></li><li class="chapter-item "><a href="../../appendix/operators.html"><strong aria-hidden="true">24.2.</strong> B-运算符与符号</a></li><li class="chapter-item "><a href="../../appendix/expressions.html"><strong aria-hidden="true">24.3.</strong> C-表达式</a></li><li class="chapter-item "><a href="../../appendix/derive.html"><strong aria-hidden="true">24.4.</strong> D-派生特征derive</a></li><li class="chapter-item "><a href="../../appendix/prelude.html"><strong aria-hidden="true">24.5.</strong> E-prelude模块 todo</a></li><li class="chapter-item "><a href="../../appendix/difficulties.html"><strong aria-hidden="true">24.6.</strong> F-难点索引</a></li><li class="chapter-item "><a href="../../appendix/rust-version.html"><strong aria-hidden="true">24.7.</strong> G-Rust版本说明</a></li><li class="chapter-item "><a href="../../appendix/rust-versions/intro.html"><strong aria-hidden="true">24.8.</strong> H-Rust更新版本列表</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../appendix/rust-versions/1.58.html"><strong aria-hidden="true">24.8.1.</strong> 1.58</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust语言圣经(Rust教程 Rust Course)</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-course" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-course/edit/main/book/contents/advance/functional-programing/iterator.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="迭代器iterator"><a class="header" href="#迭代器iterator">迭代器Iterator</a></h1>
<p>如果你询问一个Rust资深开发：写Rust项目最需要掌握什么？相信迭代器往往就是答案之一。无论你是编程新手亦或是高手，实际上大概率都用过迭代器，虽然自己可能并没有意识到这一点:)</p>
<p>迭代器允许我们迭代一个连续的集合，例如数组、动态数组Vec、<code>HashMap</code>等，在此过程中，只需关心集合中的元素如何处理，而无需去关心如何开始、如何结束、按照什么样的索引去访问等问题。</p>
<h2 id="for循环与迭代器"><a class="header" href="#for循环与迭代器">For循环与迭代器</a></h2>
<p>从用途来看，迭代器跟<code>for</code>循环颇为相似，都是去遍历一个集合，但是实际上它们存在不小的差别，其中最主要的差别就是：<strong>是否通过索引来访问集合</strong>。</p>
<p>例如以下的JS代码就是一个循环:</p>
<pre><code class="language-javascript">let arr = [1, 2, 3];
for (let i = 0; i &lt; arr.length; i++) {
    console.log(arr[i]);
}
</code></pre>
<p>在上面代码中，我们设置索引的开始点和结束点，然后再通过索引去访问元素<code>arr[i]</code>，这就是典型的循环，来对比下Rust中的<code>for</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr = [1, 2, 3];
for v in arr {
    println!(&quot;{}&quot;,v);
}
<span class="boring">}
</span></code></pre></pre>
<p>首先，不得不说这两语法还挺像！与JS循环不同，<code>Rust</code>中没有使用索引，它把<code>arr</code>数组当成一个迭代器，直接去遍历其中的元素，从哪里开始，从哪里结束，都无需操心。因此严格来说，Rust中的<code>for</code>循环是编译器提供的语法糖，最终还是对迭代器中的元素进行遍历。</p>
<p>那又有同学要发问了，在Rust中数组是迭代器吗？因为在之前的代码中直接对数组<code>arr</code>进行了迭代，答案是<code>No</code>。那既然数组不是迭代器，为啥咱可以对它的元素进行迭代呢？</p>
<p>简而言之就是数组实现了<code>IntoIterator</code>特征，Rust通过<code>for</code>语法糖，自动把实现了该特征的数组类型转换为迭代器(你也可以为自己的集合类型实现此特征)，最终让我们可以直接对一个数组进行迭代，类似的还有：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 1..10 {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<p>直接对数值序列进行迭代，也是很常见的使用方式。</p>
<p><code>IntoIterator</code>特征拥有一个<code>into_iter</code>方法，因此我们还可以显式的把数组转换成迭代器：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr = [1, 2, 3];
for v in arr.into_iter() {
    println!(&quot;{}&quot;, v);
}
<span class="boring">}
</span></code></pre></pre>
<p>迭代器是函数语言的核心特性，它赋予了Rust远超于循环的强大表达能力，我们也将在本章中一一为大家进行展现。</p>
<h2 id="惰性初始化"><a class="header" href="#惰性初始化">惰性初始化</a></h2>
<p>在Rust中，迭代器是惰性的，意味着如果你不使用它，那么它将不会发生任何事：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!(&quot;{}&quot;, val);
}
<span class="boring">}
</span></code></pre></pre>
<p>在<code>for</code>循环之前，我们只是简单的创建了一个迭代器<code>v1_iter</code>，此时不会发生任何迭代行为，只有在<code>for</code>循环开始后，迭代器才会开始迭代其中的元素，最后打印出来。</p>
<p>这种惰性初始化的方式确保了创建迭代器不会有任何额外的性能损耗，其中的元素也不会被消耗，只有到使用该迭代器的时候，一切才开始。</p>
<h2 id="next方法"><a class="header" href="#next方法">next方法</a></h2>
<p>对于<code>for</code>如何遍历迭代器，还有一个问题，它如何取出迭代器中的元素？</p>
<p>先来看一个特征:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // 省略其余有默认实现的方法
}
<span class="boring">}
</span></code></pre></pre>
<p>呦，该特征竟然和迭代器iterator同名，难不成。。。没错，它们就是有一腿。<strong>迭代器之所以成为迭代器，就是因为实现了<code>Iterator</code>特征</strong>，要实现该特征，最主要的就是实现其中的<code>next</code>方法，该方法控制如何从集合中取值，最终返回值的类型是<a href="https://course.rs/basic/trait/advance-trait#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B">关联类型</a><code>Item</code>.</p>
<p>因此，之前问题的答案已经很明显：<code>for</code>循环通过不停调用迭代器上的<code>next</code>方法，来获取迭代器中的元素。</p>
<p>既然<code>for</code>可以调用<code>next</code>方法，是不是意味着我们也可以？来试试:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let arr = [1, 2, 3];
    let mut arr_iter = arr.into_iter();

    assert_eq!(arr_iter.next(), Some(1));
    assert_eq!(arr_iter.next(), Some(2));
    assert_eq!(arr_iter.next(), Some(3));
    assert_eq!(arr_iter.next(), None);
}
</code></pre></pre>
<p>果不其然，将<code>arr</code>转换成迭代器后，通过调用其上的<code>next</code>方法，我们获取了<code>arr</code>中的元素, 有两点需要注意:</p>
<ul>
<li><code>next</code>方法返回的是<code>Option</code>类型，当有值时返回<code>Some(i32)</code>,无值时返回<code>None</code></li>
<li>遍历是按照迭代器中元素的排列顺序依次进行的，因此我们严格按照数组中元素的顺序取出了<code>Some(1)</code>,<code>Some(2)</code>,<code>Some(3)</code></li>
<li>手动迭代必须将迭代器声明为<code>mut</code>可变，因为调用<code>next</code>会改变迭代器其中的状态数据(当前遍历的位置等)，而<code>for</code>循环去迭代则无需标注<code>mut</code>，因为它会帮我们自动完成</li>
</ul>
<p>总之，<code>next</code>方法对<strong>迭代器的遍历是消耗性的</strong>，每次消耗它一个元素，最终迭代器中将没有任何元素, 只能返回<code>None</code>.</p>
<h4 id="例子模拟实现for循环"><a class="header" href="#例子模拟实现for循环">例子：模拟实现for循环</a></h4>
<p>因为for循环是迭代器的语法糖，因此我们完全可以通过迭代器来模拟实现它：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let values = vec![1, 2, 3];

{
    let result = match IntoIterator::into_iter(values) {
        mut iter =&gt; loop {
            match iter.next() {
                Some(x) =&gt; { println!(&quot;{}&quot;, x); },
                None =&gt; break,
            }
        },
    };
    result
}
<span class="boring">}
</span></code></pre></pre>
<p><code>IntoIterator::into_iter</code>是使用<a href="https://course.rs/basic/trait/advance-trait.html#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95">完全限定</a>的方式去调用<code>into_iter</code>方法，这种调用方式跟<code>values.into_iter()</code>是等价的。</p>
<p>同时我们使用了<code>loop</code>循环配合<code>next</code>方法来遍历迭代器中的元素，当迭代器返回<code>None</code>时，跳出循环。</p>
<h2 id="intoiterator特征"><a class="header" href="#intoiterator特征">IntoIterator特征</a></h2>
<p>其实有一个细节，由于<code>Vec</code>动态数组实现了<code>IntoIterator</code>特征，因此可以通过<code>into_iter</code>将其转换为迭代器，那如果本身就是一个迭代器，该怎么办？实际上，迭代器自身也实现了<code>IntoIterator</code>，标准库早就帮我们考虑好了:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;I: Iterator&gt; IntoIterator for I {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>最终你完全可以写出这样的奇怪代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let values = vec![1, 2, 3];

    for v in values.into_iter().into_iter().into_iter() {
        println!(&quot;{}&quot;,v)
    }
}
</code></pre></pre>
<h4 id="into_iter-iter-iter_mut"><a class="header" href="#into_iter-iter-iter_mut">into_iter, iter, iter_mut</a></h4>
<p>在之前的代码中，我们统一使用了<code>into_iter</code>的方式将数组转化为迭代器，除此之外，还有<code>iter</code>和<code>iter_mut</code>，聪明的读者应该大概能猜到这三者的区别：</p>
<ul>
<li><code>into_iter</code>会夺走所有权</li>
<li><code>iter</code>是借用</li>
<li><code>iter_mut</code>是可变借用</li>
</ul>
<p>其实如果以后见多识广了，你会发现这种问题一眼就能看穿，<code>into_</code>之类的，都是拿走所有权，<code>_mut</code>之类的都是可变借用，剩下的就是不可变借用。</p>
<p>使用一段代码来解释下:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let values = vec![1, 2, 3];

    for v in values.into_iter() {
        println!(&quot;{}&quot;, v)
    }

    // 下面的代码将报错，因为values的所有权在上面`for`循环中已经被转移走
    // println!(&quot;{:?}&quot;,values);

    let values = vec![1, 2, 3];
    let _values_iter = values.iter();

    // 不会报错，因为values_iter是借用了values中的元素
    println!(&quot;{:?}&quot;, values);

    let mut values = vec![1, 2, 3];
    // 对values中的元素进行可变借用
    let mut values_iter_mut = values.iter_mut();

    // 取出第一个元素，并修改为0
    if let Some(v) = values_iter_mut.next() {
        *v = 0;
    }

    // 输出[0, 2, 3]
    println!(&quot;{:?}&quot;, values);
}
</code></pre></pre>
<p>具体解释在代码注释中，就不再赘述,不过有两点需要注意的是：</p>
<ul>
<li><code>.iter()</code>方法实现的迭代器，调用<code>next</code>方法返回的类型是<code>Some(&amp;T)</code></li>
<li><code>.iter_mut()</code>方法实现的迭代器，调用<code>next</code>方法返回的类型是<code>Some(&amp;mut T)</code>, 因此在<code>if let Some(v) = values_iter_mut.next()</code>中，<code>v</code>的类型是<code>&amp;mut i32</code>，最终我们可以通过<code>*v = 0</code>的方式修改其值</li>
</ul>
<h4 id="iterator和intoiterator的区别"><a class="header" href="#iterator和intoiterator的区别">Iterator和IntoIterator的区别</a></h4>
<p>这两个其实还蛮容易搞混的，但我们只需要记住，<code>Iterator</code>就是迭代器特征，只有实现了它才能称为迭代器，才能调用<code>next</code>。</p>
<p>而<code>IntoIterator</code>强调的是某一个类型如果实现了该特征，它可以通过<code>into_iter</code>，<code>iter</code>等方法变成一个迭代器.</p>
<h2 id="消费者与适配器"><a class="header" href="#消费者与适配器">消费者与适配器</a></h2>
<p>消费者是迭代器上的方法，它会消费掉迭代器中的元素，然后返回其它类型的值，这些消费者都有一个共同的特点：在它们的定义中，都依赖<code>next</code>方法来消费元素，因此这也是为什么迭代器要实现<code>Iterator</code>特征，而该特征必须要实现<code>next</code>方法的原因。</p>
<h4 id="消费者适配器"><a class="header" href="#消费者适配器">消费者适配器</a></h4>
<p>只要迭代器上的某个方法<code>A</code>在其内部调用了<code>next</code>方法，那么<code>A</code>就被称为<strong>消费性适配器</strong>: 因为<code>next</code>方法会消耗掉迭代器上的元素，可以推出方法<code>A</code>的调用也会消耗掉迭代器上的元素。</p>
<p>其中一个例子是<code>sum</code>方法，它会拿走迭代器的所有权，然后通过不断调用<code>next</code>方法对里面的元素进行求和:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
    
    // v1_iter是借用了v1，因此v1可以照常使用
    println!(&quot;{:?}&quot;,v1);

    // 以下代码会报错，因为`sum`拿到了迭代器`v1_iter`的所有权
    // println!(&quot;{:?}&quot;,v1_iter);
}
</code></pre></pre>
<p>如代码注释中所说明的：在使用<code>sum</code>方法后，我们将无法再使用<code>v1_iter</code>，因为<code>sum</code>拿走了该迭代器的所有权:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum&lt;S&gt;(self) -&gt; S
    where
        Self: Sized,
        S: Sum&lt;Self::Item&gt;,
    {
        Sum::sum(self)
    }

<span class="boring">}
</span></code></pre></pre>
<p>从<code>sum</code>源码中也可以清晰看出，<code>self</code>类型的方法参数拿走了所有权。</p>
<h4 id="迭代器适配器"><a class="header" href="#迭代器适配器">迭代器适配器</a></h4>
<p>既然消费者适配器是消费掉迭代器，然后返回一个值。那么迭代器适配器，顾名思义，会返回一个新的迭代器，这是实现链式方法调用的关键:<code>v.iter().map().filter()...</code>。</p>
<p>与消费者适配器不同，迭代器适配器是惰性的，意味着你<strong>需要一个消费者适配器来收尾，最终将迭代器转换成一个具体的值</strong>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
<span class="boring">}
</span></code></pre></pre>
<p>运行后输出:</p>
<pre><code class="language-console">warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed // 迭代器map是惰性的，这里不产生任何效果
</code></pre>
<p>如上述中文注释所说，这里的<code>map</code>方法是一个迭代者适配器，它是惰性的，不产生任何行为，因此我们还需要一个消费者适配器进行收尾:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}
</span></code></pre></pre>
<h4 id="collect"><a class="header" href="#collect">collect</a></h4>
<p>上面代码中，使用了<code>collect</code>方法，该方法就是一个消费者适配器，使用它可以将一个迭代器中的元素收集到指定类型中，这里我们为<code>v2</code>标注了<code>Vec&lt;_&gt;</code>类型，就是为了告诉<code>collect</code>：请把迭代器中的元素消费掉，然后把值收集成<code>Vec&lt;_&gt;</code>类型，至于为何使用<code>_</code>，因为编译器会帮我们自动推导。</p>
<p>为何<code>collect</code>在消费时要指定类型？是因为该方法其实很强大，可以收集成多种不同的集合类型，<code>Vec&lt;T&gt;</code>仅仅是其中之一，因此我们必须显式的告诉编译器我们想要收集成的集合类型。</p>
<p>还有一点值得注意,<code>map</code>会对迭代器中的每一个值进行一系列操作，然后把该值转换成另外一个新值， 该操作是通过闭包<code>|x| x + 1</code>来完成: 最终迭代器中的每个值都增加了<code>1</code>，从<code>[1, 2, 3]</code>变为<code>[2, 3, 4]</code>.</p>
<p>再来看看如何使用<code>collect</code>收集成<code>HashMap</code>集合：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::HashMap;
fn main() {
    let names = [&quot;sunface&quot;, &quot;sunfei&quot;];
    let ages = [18, 18];
    let folks: HashMap&lt;_, _&gt; = names.into_iter().zip(ages.into_iter()).collect();

    println!(&quot;{:?}&quot;,folks);
}
</code></pre></pre>
<p><code>zip</code>是一个迭代器适配器，它的作用就是将两个迭代器的内容压缩到一起，形成<code>Iterator&lt;Item=(ValueFromA, ValueFromB)&gt;</code> 这样的新的迭代器,在此处就是形如<code>[(name1, age1), (name2, age2)]</code>的迭代器。</p>
<p>然后再通过<code>collect</code>将新迭代器中<code>(K, V)</code>形式的值收集成<code>HashMap&lt;K, V&gt;</code>，同样的，这里必须显式声明类型，然后<code>HashMap</code>内部的<code>KV</code>类型可以交给编译器去推导，最终编译器会推导出<code>HashMap&lt;&amp;str, i32&gt;</code>，完全正确！</p>
<h4 id="闭包作为适配器参数"><a class="header" href="#闭包作为适配器参数">闭包作为适配器参数</a></h4>
<p>之前的<code>map</code>方法中，我们使用闭包来作为迭代器适配器的参数，它最大的好处不仅在于就地实现迭代器中元素的处理，还在于可以捕获环境值:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}
<span class="boring">}
</span></code></pre></pre>
<p><code>filter</code>是迭代器适配器，用于对迭代器中的每个值进行过滤。 它使用闭包作为参数，该闭包的参数<code>s</code>是来自迭代器中的值，然后使用<code>s</code>跟外部环境中的<code>shoe_size</code>进行比较，若相等，则在迭代器中保留<code>s</code>值，若不相等，则从迭代器中剔除<code>s</code>值，最终通过<code>collect</code>收集为<code>Vec&lt;Shoe&gt;</code>类型.</p>
<h2 id="实现iterator特征"><a class="header" href="#实现iterator特征">实现Iterator特征</a></h2>
<p>之前的内容我们一直基于数组来创建迭代器，实际上，不仅仅是数组，基于其它集合类型一样可以创建迭代器，例如<code>HashMap</code>。 你也可以创建自己的迭代器 - 只要为自定义类型实现<code>Iterator</code>特征即可。</p>
<p>首先，创建一个计数器：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们为计数器<code>Counter</code>实现了一个关联函数<code>new</code>，用于创建新的计数器实例。下面们继续为计数器实现<code>Iterator</code>特征：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.count &lt; 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>首先，将该特征的关联类型设置为<code>u32</code>，由于我们的计数器保存的<code>count</code>字段就是<code>u32</code>类型， 因此在<code>next</code>方法中，最后返回的是实际上是<code>Option&lt;u32&gt;</code>类型.</p>
<p>每次调用<code>next</code>方法，都会让计数器的值加一，然后返回最新的计数值，一旦计数大于5，就返回<code>None</code>。</p>
<p>最后，使用我们新建的<code>Counter</code>进行迭代：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let mut counter = Counter::new();

assert_eq!(counter.next(), Some(1));
assert_eq!(counter.next(), Some(2));
assert_eq!(counter.next(), Some(3));
assert_eq!(counter.next(), Some(4));
assert_eq!(counter.next(), Some(5));
assert_eq!(counter.next(), None);
<span class="boring">}
</span></code></pre></pre>
<h4 id="实现iterator特征的其它方法"><a class="header" href="#实现iterator特征的其它方法">实现Iterator特征的其它方法</a></h4>
<p>可以看出，实现自己的迭代器非常简单，但是<code>Iterator</code>特征中，不仅仅是只有<code>next</code>一个方法，那为什么我们只需要实现它呢？因为其它方法都具有<a href="https://course.rs/basic/trait/trait.html#%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0">默认实现</a>，无需像<code>next</code>这样手动去实现，而且这些默认实现的方法其实都是基于<code>next</code>方法实现的。</p>
<p>下面的代码演示了部分方法的使用：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sum: u32 = Counter::new()
    .zip(Counter::new().skip(1))
    .map(|(a, b)| a * b)
    .filter(|x| x % 3 == 0)
    .sum();
assert_eq!(18, sum);
<span class="boring">}
</span></code></pre></pre>
<p>其中<code>zip</code>, <code>map</code>, <code>filter</code>是迭代器适配器：</p>
<ul>
<li><code>zip</code>把两个迭代器合并成一个迭代器，新迭代器中，每个元素都是一个元组，由之前两个迭代器的元素组成。例如将<strong>形如</strong><code>[1, 2, 3]</code>和<code>[4, 5, 6]</code>的迭代器合并后，新的迭代器形如<code>[(1, 4),(2, 5),(3, 6)]</code></li>
<li><code>map</code>是将迭代器中的值经过映射后，转换成新的值</li>
<li><code>filter</code>对迭代器中的元素进行过滤，若闭包返回<code>true</code>则保留元素，反之剔除</li>
</ul>
<p>而<code>sum</code>是消费者适配器，对迭代器中的所有元素求和，最终返回一个<code>u32</code>值<code>18</code>。</p>
<h5 id="enumerate"><a class="header" href="#enumerate">enumerate</a></h5>
<p>在之前的流程控制章节，针对<code>for</code>循环，我们提供了一种方法可以获取迭代时的索引:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1u64, 2, 3, 4, 5, 6];
for (i,v) in v.iter().enumerate() {
    println!(&quot;第{}个值是{}&quot;,i,v)
}
<span class="boring">}
</span></code></pre></pre>
<p>相信当时，很多读者还是很迷茫的，不知道为什么要这么复杂才能获取到索引，学习本章节后，相信你有了全新的理解，首先<code>v.iter()</code>创建迭代器，其次
调用<code>Iterator</code>特征上的方法<code>enumerate</code>，该方法产生一个新的迭代器，其中每个元素均是元组<code>(索引，值)</code>。</p>
<p>因为<code>enumerate</code>是迭代器适配器，因此我们可以对它返回的迭代器调用其它<code>Iterator</code>特征方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1u64, 2, 3, 4, 5, 6];
let val = v.iter()
    .enumerate()
    // 每两个元素剔除一个
    // [1, 3, 5]
    .filter(|&amp;(idx, _)| idx % 2 == 0)
    .map(|(idx, val)| val)
    // 累加 1+3+5 = 9
    .fold(0u64, |sum, acm| sum + acm);

println!(&quot;{}&quot;, val);
<span class="boring">}
</span></code></pre></pre>
<h2 id="迭代器的性能"><a class="header" href="#迭代器的性能">迭代器的性能</a></h2>
<p>前面提到，要完成集合遍历，既可以使用for循环也可以使用迭代器，那么二者之间该怎么选择呢，性能有多大差距呢？</p>
<p>理论分析不会有结果，直接测试最为靠谱：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span>#![feature(test)]

<span class="boring">fn main() {
</span>extern crate rand;
extern crate test;

fn sum_for(x: &amp;[f64]) -&gt; f64 {
    let mut result: f64 = 0.0;
    for i in 0..x.len() {
        result += x[i];
    }
    result
}

fn sum_iter(x: &amp;[f64]) -&gt; f64 {
    x.iter().sum::&lt;f64&gt;()
}

#[cfg(test)]
mod bench {
    use test::Bencher;
    use rand::{Rng,thread_rng};
    use super::*;

    const LEN: usize = 1024*1024;

    fn rand_array(cnt: u32) -&gt; Vec&lt;f64&gt; {
        let mut rng = thread_rng();
        (0..cnt).map(|_| rng.gen::&lt;f64&gt;()).collect()
    }

    #[bench]
    fn bench_for(b: &amp;mut Bencher) {
        let samples = rand_array(LEN as u32);
        b.iter(|| {
            sum_for(&amp;samples)
        })
    }

    #[bench]
    fn bench_iter(b: &amp;mut Bencher) {
        let samples = rand_array(LEN as u32);
        b.iter(|| {
            sum_iter(&amp;samples)
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面的代码对比了for循环和迭代器iterator完成同样的求和任务的性能对比，可以看到迭代器还要更快一点。</p>
<pre><code class="language-console">test bench::bench_for  ... bench:     998,331 ns/iter (+/- 36,250)
test bench::bench_iter ... bench:     983,858 ns/iter (+/- 44,673)
</code></pre>
<p>迭代器是 Rust 的 <strong>零成本抽象</strong>（zero-cost abstractions）之一，意味着抽象并不会引入运行时开销，这与 <code>Bjarne Stroustrup</code>（C++ 的设计和实现者）在 <code>Foundations of C++（2012）</code> 中所定义的 <strong>零开销</strong>（zero-overhead）如出一辙：</p>
<pre><code>In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for.
And further: What you do use, you couldn’t hand code any better.

一般来说，C++的实现遵循零开销原则：没有使用时，你不必为其买单。
更进一步说，需要使用时，你也无法写出更优的代码了。
（翻译一下：用就完事了）
</code></pre>
<p>总之，迭代器是 Rust 受函数式语言启发而提供的高级语言特性，可以写出更加简洁、逻辑清晰的代码。编译器还可以通过循环展开（Unrolling）、向量化、消除边界检查等优化手段，使得迭代器和for循环都有极为高效的执行效率。</p>
<p>所以请放心大胆的使用迭代器，在获得更高的表达力的同时，也不会导致运行时的损失，何乐而不为呢！</p>
<h2 id="学习其它方法"><a class="header" href="#学习其它方法">学习其它方法</a></h2>
<p>迭代器用的好不好，就在于你是否掌握了它的常用方法，且能活学活用，因此多多看看<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">标准库</a>是有好处的，只有知道有什么方法，在需要的时候你才能知道该用什么，就和算法学习一样。</p>
<p>同时，本书在后续章节还提供了对迭代器常用方法的<a href="https://course.rs/std/iterator">深入讲解</a>，方便大家学习和查阅。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../advance/functional-programing/closure.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../advance/crate-module/intro.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../advance/functional-programing/closure.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../advance/crate-module/intro.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../../assets/ferris.js"></script>


    </body>
</html>
